[
    {
        "id": "ct_async_1",
        "code": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');",
        "question": "What will be logged to the console, in order?",
        "correctAnswer": "Start, End, Promise, Timeout",
        "options": [
            "Start, End, Promise, Timeout",
            "Start, Timeout, Promise, End",
            "Start, Promise, Timeout, End",
            "Start, End, Timeout, Promise"
        ],
        "explanation": "Synchronous code runs first (Start, End). Then microtasks (Promises) run before macrotasks (setTimeout). So 'Promise' logs before 'Timeout' even with 0ms delay."
    },
    {
        "id": "ct_closure_1",
        "code": "function outer() {\n  let count = 0;\n  return function inner() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = outer();\nconsole.log(counter());\nconsole.log(counter());\nconsole.log(counter());",
        "question": "What will be logged to the console?",
        "correctAnswer": "1, 2, 3",
        "options": [
            "1, 2, 3",
            "1, 1, 1",
            "0, 1, 2",
            "undefined, undefined, undefined"
        ],
        "explanation": "The inner function forms a closure over 'count'. Each call increments and returns the same 'count' variable, so we get 1, 2, 3."
    },
    {
        "id": "ct_hoisting_1",
        "code": "console.log(x);\nvar x = 5;\nconsole.log(x);",
        "question": "What will be logged to the console?",
        "correctAnswer": "undefined, 5",
        "options": [
            "undefined, 5",
            "5, 5",
            "ReferenceError, 5",
            "null, 5"
        ],
        "explanation": "Variable declarations with 'var' are hoisted but not their values. So 'x' exists but is undefined until the assignment line runs."
    },
    {
        "id": "ct_letconst_1",
        "code": "console.log(a);\nlet a = 10;",
        "question": "What happens when this code runs?",
        "correctAnswer": "ReferenceError: Cannot access 'a' before initialization",
        "options": [
            "ReferenceError: Cannot access 'a' before initialization",
            "undefined",
            "10",
            "null"
        ],
        "explanation": "'let' and 'const' are hoisted but remain in the Temporal Dead Zone until their declaration. Accessing them before throws a ReferenceError."
    },
    {
        "id": "ct_array_1",
        "code": "const arr = [1, 2, 3];\nconst result = arr.map(x => x * 2).filter(x => x > 2);\nconsole.log(result);",
        "question": "What will be logged?",
        "correctAnswer": "[4, 6]",
        "options": [
            "[4, 6]",
            "[2, 4, 6]",
            "[4]",
            "[1, 2, 3]"
        ],
        "explanation": "map() doubles each element: [2, 4, 6]. Then filter() keeps only values > 2: [4, 6]."
    },
    {
        "id": "ct_react_state_1",
        "code": "function Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  \n  // After one click, what is count?\n}",
        "question": "After clicking the button once, what will 'count' be?",
        "correctAnswer": "1",
        "options": [
            "1",
            "3",
            "2",
            "0"
        ],
        "explanation": "All three setCount calls use the same 'count' value (0) from the closure. They all set count to 0+1=1. Batching means only 1 render with count=1."
    },
    {
        "id": "ct_react_state_2",
        "code": "function Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(c => c + 1);\n    setCount(c => c + 1);\n    setCount(c => c + 1);\n  };\n  \n  // After one click, what is count?\n}",
        "question": "After clicking the button once, what will 'count' be?",
        "correctAnswer": "3",
        "options": [
            "3",
            "1",
            "2",
            "0"
        ],
        "explanation": "Using the functional form (c => c + 1) ensures each update uses the latest state. Each call increments from the previous value: 0→1→2→3."
    },
    {
        "id": "ct_this_1",
        "code": "const obj = {\n  name: 'Alice',\n  greet: function() {\n    console.log(this.name);\n  }\n};\n\nconst greetFn = obj.greet;\ngreetFn();",
        "question": "What will be logged?",
        "correctAnswer": "undefined (or error in strict mode)",
        "options": [
            "undefined (or error in strict mode)",
            "Alice",
            "greet",
            "obj"
        ],
        "explanation": "When assigned to a variable and called, 'this' is no longer bound to 'obj'. In non-strict mode, 'this' is the global object (no 'name' property). In strict mode, it throws an error."
    },
    {
        "id": "ct_spread_1",
        "code": "const a = { x: 1, y: 2 };\nconst b = { y: 3, z: 4 };\nconst c = { ...a, ...b };\nconsole.log(c);",
        "question": "What will be logged?",
        "correctAnswer": "{ x: 1, y: 3, z: 4 }",
        "options": [
            "{ x: 1, y: 3, z: 4 }",
            "{ x: 1, y: 2, z: 4 }",
            "{ x: 1, y: 2, y: 3, z: 4 }",
            "{ y: 3, z: 4 }"
        ],
        "explanation": "Spread operator merges objects left to right. 'y' from 'b' (3) overwrites 'y' from 'a' (2). Result is { x: 1, y: 3, z: 4 }."
    },
    {
        "id": "ct_equality_1",
        "code": "console.log([] == false);\nconsole.log([] === false);\nconsole.log(!![]);",
        "question": "What will be logged?",
        "correctAnswer": "true, false, true",
        "options": [
            "true, false, true",
            "false, false, true",
            "true, true, true",
            "false, false, false"
        ],
        "explanation": "[] == false: Both coerce to 0, so true. [] === false: Different types, so false. !![]: Empty array is truthy, so !![] is true."
    }
]