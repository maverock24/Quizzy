[
  {
    "name": "AI/ML kehittäjille",
    "image": "https://images.unsplash.com/photo-1620712943543-95fc696293AE",
    "questions": [
      {
        "question": "Olet kouluttanut luokitusmallin Scikit-learnillä Python-skriptissä. Mikä on yleisin ja käytännöllisin tapa saada tämä malli verkkosovelluksesi käytettäväksi?",
        "answers": [
          {
            "answer": "Kirjoita mallilogiikka uudelleen suoraan JavaScriptiin toimimaan käyttöliittymässä."
          },
          {
            "answer": "Kääri malli verkkopalvelinsovellukseen (esim. Flaskilla tai FastAPI:lla) ja paljasta se REST API -päätepisteeksi."
          },
          {
            "answer": "Tallenna mallin tulos kaikkia mahdollisia syötteitä varten tietokantaan ja tee siitä kysely."
          },
          {
            "answer": "Yhdistä käyttöliittymä suoraan Python-skriptiin käyttämällä WebSocketia jokaiselle ennusteelle."
          }
        ],
        "answer": "Kääri malli verkkopalvelinsovellukseen (esim. Flaskilla tai FastAPI:lla) ja paljasta se REST API -päätepisteeksi.",
        "explanation": "Täyden pinon kehittäjälle tutuin ja järein tapa on käsitellä tekoälymallia mikropalveluna. Käyttäisit kevyttä Python-verkkokehystä, kuten **Flask** tai **FastAPI**, lataamaan harjoitellut mallisi ja luomaan API-päätepisteen (esim. `/predict'). Verkkosovelluksesi (etu- tai takapäätepyyntö) voi lähettää datan tavalliseen päätepisteeseen. JSON-hyötykuorma) ja vastaanottaa mallin ennusteen vastauksena."
      },
      {
        "question": "Missä seuraavista tehtävistä GPU (Graphics Processing Unit) tarjoaisi tyypillisesti merkittävimmän suorituskyvyn parannuksen suorittimeen verrattuna?",
        "answers": [
          {
            "answer": "Palvelee yksinkertaista REST-sovellusliittymää, joka isännöi pientä päätöspuumallia."
          },
          { "answer": "Käytetään Node.js-verkkopalvelinta." },
          {
            "answer": "Koulutetaan laaja syväoppimismalli kuvantunnistusta varten."
          },
          { "answer": "SQL-tietokannan kysely." }
        ],
        "answer": "Koulutetaan laaja syväoppimismalli kuvantunnistusta varten.",
        "explanation": "GPU:t suorittavat erinomaisesti suuria määriä rinnakkaisia ​​matemaattisia operaatioita, mikä on juuri sitä, mitä tarvitaan syvien hermoverkkojen koulutukseen liittyviin matriisikertoimiin. Vaikka CPU pystyy suorittamaan nämä tehtävät, GPU pystyy suorittamaan ne suuruusluokkaa nopeammin. Tehtäviin, kuten yksinkertaisen API:n palvelemiseen, verkkopalvelimen käyttämiseen tai tietokantakyselyihin, on usein sopivampi prosessori."
      },
      {
        "question": "Tiimisi on lisättävä käyttäjien kommentteihin mielipideanalyysi (luokittelemalla teksti positiiviseksi, negatiiviseksi tai neutraaliksi). Mikä on yleensä aika- ja kustannustehokkain ensimmäinen lähestymistapa?",
        "answers": [
          {
            "answer": "Kerää tuhansia kommentteja, merkitse ne manuaalisesti ja harjoittele uusi syväoppimismalli tyhjästä."
          },
          {
            "answer": "Käytä valmiiksi koulutettua mallia kirjastosta, kuten Hugging Face Transformers, tai käytä pilvi-AI-palvelusovellusliittymää (kuten Google NLP tai Azure Cognitive Services)."
          },
          {
            "answer": "Luo monimutkainen järjestelmä avainsanahaulle ja säännöllisille lausekkeille."
          },
          {
            "answer": "Palkaa datatieteilijöiden tiimi viettämään kuusi kuukautta mukautetun ratkaisun rakentamiseen."
          }
        ],
        "answer": "Käytä esikoulutettua mallia kirjastosta, kuten Hugging Face Transformers, tai käytä pilvi-AI-palvelusovellusliittymää (kuten Google NLP tai Azure Cognitive Services).",
        "explanation": "Mallin opettaminen tyhjästä on aikaa vievää ja vaatii suuren merkittyä tietojoukkoa. Käytännöllisin tapa yleiseen tehtävään, kuten tunneanalyysiin, on käyttää **esikoulutettua mallia**. **Hugging Face Transformersin** kaltaiset kirjastot antavat sinulle pääsyn tuhansiin malleihin, joita voit käyttää sovellusliittymän ja palveluntarjoajan vaihtoehtoisesti vain muutamalla rivillä, pilvikoodilla. pay-as-you-go-ratkaisu ilman infrastruktuurin hallintaa."
      },
      {
        "question": "Mikä on Pandan kaltaisen kirjaston ensisijainen rooli tyypillisessä Python-pohjaisessa koneoppimisen työnkulussa?",
        "answers": [
          { "answer": "Monimutkaisten hermoverkkojen rakentaminen ja kouluttaminen." },
          { "answer": "Vuorovaikutteisten datavisualisaatioiden ja kaavioiden luominen." },
          { "answer": "Koneoppimismallien käyttöönotto skaalautuvina sovellusliittyminä." },
          {
            "answer": "Lataa, puhdistaa, käsitellä ja tutkia strukturoitua dataa lähteistä, kuten CSV-tiedostoista tai tietokannoista."
          }
        ],
        "answer": "Lataa, puhdistaa, käsitellä ja tutkia strukturoitua dataa lähteistä, kuten CSV-tiedostoista tai tietokannoista.",
        "explanation": "`Pandas` on Pythonin tietojenkäsittelyn ja analyysin peruskirjasto. Sen ensisijainen tietorakenne, **DataFrame**, on pohjimmiltaan taulukkoa tai SQL-taulukkoa muistuttava taulukko. Ennen kuin harjoitat mallia, sinun on lähes aina puhdistettava tietosi (esim. käsiteltävä puuttuvia arvoja), valittava asianmukaiset sarakkeet (ominaisuudet) ja muutettava se käytettäväksi työkaluksi. esikäsittelyvaiheet."
      },
      {
        "question": "Mikä on MLOpsin (Machine Learning Operations) ydinidea ja miten se liittyy käsitteeseen, joka on tuttu täyden pinon kehittäjille?",
        "answers": [
          {
            "answer": "Se on erityinen algoritmi mallin suorituskyvyn optimoimiseksi."
          },
          {
            "answer": "Se on käytäntö käyttää koneoppimismalleja yksinomaan mobiililaitteissa."
          },
          {
            "answer": "Se soveltaa DevOps-periaatteita (kuten CI/CD, automaatio ja valvonta) koneoppimisen elinkaareen."
          },
          {
            "answer": "Se on visuaalinen, vedä ja pudota työkalu mallien rakentamiseen ilman koodia."
          }
        ],
        "answer": "Se soveltaa DevOps-periaatteita (kuten CI/CD, automaatio ja valvonta) koneoppimisen elinkaareen.",
        "explanation": "**MLOps** on koneoppimiseen, mitä **DevOps** on ohjelmistokehitykseen. Se on joukko käytäntöjä, joiden tavoitteena on luotettavasti ja tehokkaasti rakentaa, ottaa käyttöön ja ylläpitää koneoppimismalleja tuotannossa. Tämä sisältää dataputkien automatisoinnin, mallin koulutuksen, käyttöönoton (CI/CD), suorituskyvyn heikkenemisen seurannan (mallin koko elinkaaren hallinnan)."
      },
      {
        "question": "Verkkokauppasovelluksesi on annettava välittömiä tuotesuosituksia käyttäjän selattaessa. Millaista mallin ennusteprosessia tarvitaan?",
        "answers": [
          { "answer": "Eräpäätelmä" },
          { "answer": "Offline-koulutus" },
          { "answer": "Reaaliaikainen (tai online-) päättely" },
          { "answer": "Tiedon lisäys" }
        ],
        "answer": "Reaaliaikainen (tai online-) päättely",
        "explanation": "**Reaaliaikainen johtopäätös** tarkoittaa ennusteen tekemistä pyynnöstä yhdelle datapisteelle (tai pienelle määrälle niitä), jolla on erittäin pieni viive. Tämä on välttämätöntä interaktiivisissa sovelluksissa, joissa käyttäjä odottaa välitöntä vastausta. Sitä vastoin **eräpäätelmä** sisältää suuren datakokoelman käsittelyn kerralla, tyypillisesti aikataulun mukaan (esim. ensisijainen myyntiraportti ei ole joka yö)."
      },
      {
        "question": "Mitä on 'hienosäätö' suurten kielimallien (LLM) yhteydessä?",
        "answers": [
          {
            "answer": "Säädetään mallin API-vasteaikaa ja palvelinasetuksia."
          },
          {
            "answer": "Otetaan suuri, esikoulutettu malli ja jatketaan sen harjoittelua pienemmällä, verkkotunnuskohtaisella tietojoukolla."
          },
          {
            "answer": "Kirjoitetaan mallin lähdekoodia uudelleen sen suorituskyvyn optimoimiseksi."
          },
          {
            "answer": "Muokkaa mallin parametreja manuaalisesti asetustiedostossa."
          }
        ],
        "answer": "Otetaan suuri, esikoulutettu malli ja jatketaan sen harjoittelua pienemmässä, verkkotunnuskohtaisessa tietojoukossa.",
        "explanation": "**Hienosäätö** on siirto-oppimisen muoto. Sen sijaan, että kouluttaisit massiivisen mallin tyhjästä (joka maksaa miljoonia dollareita), aloitat tehokkaalla, yleiskäyttöisellä esikoulutetulla mallilla (kuten GPT tai Llama). Jatka sitten koulutusprosessia paljon pienemmällä, kuroidulla tietojoukolla, joka on omaa tehtävääsi koskevia (esim. lääketieteellisen yrityksesi lakiasiakirjat, tai lääketieteellisen yrityksesi lakiasiakirjat, tai transcript-tuki). mallia tiettyyn verkkotunnukseesi ja parantaa sen suorituskykyä kohdekäyttötapauksessasi."
      },
      {
        "question": "Miksi on yleinen ja erittäin suositeltava käytäntö käyttää virtuaaliympäristöjä (kuten Conda tai Pythonin 'venv') AI/ML-projekteissa?",
        "answers": [
          { "answer": "Varmuuskopioi koodi automaattisesti pilveen." },
          {
            "answer": "Python-koodin suorittaminen huomattavasti nopeammin kuin järjestelmän oletus Python."
          },
          {
            "answer": "Hallitsee projektikohtaisia ​​riippuvuuksia ja kirjastoversioita välttäen projektien välisiä ristiriitoja."
          },
          {
            "answer": "Tarjoaa graafisen käyttöliittymän komentosarjojen suorittamiseen."
          }
        ],
        "answer": "Hallinnoi projektikohtaisia ​​riippuvuuksia ja kirjastoversioita välttäen projektien välisiä ristiriitoja.",
        "explanation": "Tämä konsepti on samanlainen kuin nvm:n käyttäminen Node.js-versioissa tai riippuvuuksien hallinta paketilla. json. AI/ML-projektit perustuvat usein tiettyihin kirjastojen versioihin (esim. TensorFlow, PyTorch, Scikit-learn). Yksi projekti saattaa tarvita TensorFlow 2.1 -ympäristön, kun taas toinen projekti tarvitsee A** 2.1:n. erillinen tila jokaiselle projektille, joten voit asentaa sen tarvitsemat riippuvuudet vaikuttamatta globaaliin Python-asennukseen tai muihin projekteihin. Tämä on toistettavuuden ja yhteistyön kannalta ratkaisevaa."
      },
      {
        "question": "Kuinka käyttöliittymäsovellus (esim. Reactilla rakennettu) saa yleensä ennusteen käyttöönotetusta koneoppimismallin sovellusliittymästä?",
        "answers": [
          {
            "answer": "Käymällä suoraan palvelimen tiedostojärjestelmään mallitiedoston lukemiseksi."
          },
          {
            "answer": "Tekemällä normaali HTTP-pyyntö (esim. POST-pyyntö käyttämällä 'fetch' tai 'axios') mallin API-päätepisteeseen."
          },
          {
            "answer": "Upottamalla Python-tulkin selaimeen mallin suorittamiseksi."
          },
          {
            "answer": "Yhdistämällä mallin tietokantaan ja suorittamalla SQL-kyselyn."
          }
        ],
        "answer": "Tekemällä normaali HTTP-pyyntö (esim. POST-pyyntö käyttämällä 'fetch' tai 'axios') mallin API-päätepisteeseen.",
        "explanation": "Vuorovaikutus on täsmälleen sama kuin minkä tahansa muun tausta-sovellusliittymän kanssa, jota rakentaisit tai käytät täyden pinon kehittäjänä. Käyttöliittymän ei tarvitse tietää, että malli on kirjoitettu Pythonilla tai käyttää koneoppimista. Sen tarvitsee vain tietää API-päätepisteen URL-osoite ja odotettu pyyntömuoto (esim. JSON-runko syöttöominaisuuksilla). Se lähettää JSON-vastauksen ja standardin `saaxiostch-pyynnön. ennustus."
      },
      {
        "question": "Sinun täytyy ennustaa asuntojen hinnat perustuen ominaisuuksiin, kuten neliömetriin, makuuhuoneiden lukumäärään ja sijaintiin. Millainen yksinkertainen, klassinen koneoppimismalli on hyvä lähtökohta tälle tehtävälle?",
        "answers": [
          { "answer": "Konvoluutiohermoverkko (CNN)" },
          { "answer": "K-Meansin kaltainen klusterointialgoritmi" },
          {
            "answer": "Lineaarinen regressio tai puupohjainen malli, kuten Gradient Boosting"
          },
          { "answer": "Large Language Model (LLM)" }
        ],
        "answer": "Lineaarinen regressio tai puupohjainen malli, kuten Gradient Boosting",
        "explanation": "Tämä on klassinen **regressio**-ongelma (ennakoi jatkuvan arvon). Sinun ei tarvita monimutkaista syväoppimismallia aloittaaksesi. **Lineaarinen regressio** on yksinkertaisin perusmalli. **Puuhun perustuvat mallit**, kuten Random Forest tai Gradient Boosting (käyttäen kirjastoja, kuten Scikit-learn tai XGBoost) ovat usein erittäin hyvin tulkittavia ja hyvin tulkittavia rakennelmia. taulukkotietoja, mikä tekee niistä erinomaisen ja käytännöllisen lähtökohdan."
      },
      {
        "question": "Miksi työkalut, kuten Jupyter Notebooks tai VS Code Notebooks, ovat niin suosittuja datatieteessä ja ML-kokeilussa?",
        "answers": [
          {
            "answer": "Ne ovat ainoita ympäristöjä, jotka pystyvät suorittamaan Python-koodia."
          },
          {
            "answer": "Ne on suunniteltu lopullisten, tuotantovalmiiden sovellusten rakentamiseen ja käyttöönottoon."
          },
          {
            "answer": "Ne mahdollistavat koodin interaktiivisen suorittamisen soluissa, koodin, tekstin ja visualisointien sekoittamisen yhdessä asiakirjassa, mikä on ihanteellinen tutkimiseen."
          },
          {
            "answer": "Ne muotoilevat koodin automaattisesti PEP 8 -standardien mukaiseksi."
          }
        ],
        "answer": "Ne mahdollistavat koodin interaktiivisen suorittamisen soluissa, koodin, tekstin ja visualisointien sekoittamisen yhdessä asiakirjassa, mikä on ihanteellinen tutkimiseen.",
        "explanation": "Jupyter Notebookit tarjoavat vuorovaikutteisen, solupohjaisen ympäristön. Tämä sopii täydellisesti ML-työn tutkivaan luonteeseen, jossa haluat ladata tietoja, tarkastaa niitä, visualisoida ne, suorittaa mallin harjoitusvaiheen ja nähdä tulosteen välittömästi ilman koko skriptin uudelleen suorittamista. Kehittäjälle se on kuin REPL (Read-Eval-Print) -työnkulku, joka on suunniteltu erityisesti steroidien datakeskuksille."
      },
      {
        "question": "Mitä eroa on tyypillisessä ML-projektissa 'validation set' ja 'test set'?",
        "answers": [
          {
            "answer": "Ei eroa, termit ovat keskenään vaihdettavissa."
          },
          {
            "answer": "Validointisarjaa käytetään loppuarviointiin ja testisarjaa koulutukseen."
          },
          {
            "answer": "Validointijoukkoa käytetään mallin hyperparametrien virittämiseen kehityksen aikana, kun taas testijoukkoa käytetään vain kerran lopulliseen, puolueettomaan arviointiin."
          },
          {
            "answer": "Tarkistusjoukko sisältää vain merkittyjä tietoja, kun taas testisarja sisältää nimeämätöntä dataa."
          }
        ],
        "answer": "Validointijoukkoa käytetään mallin hyperparametrien virittämiseen kehityksen aikana, kun taas testijoukkoa käytetään vain kerran lopulliseen, puolueettomaan arviointiin.",
        "explanation": "Tämä on tärkeä käsite. Ajattele sitä kuin kokeeseen opiskelemista: \n1. **Koulutussarja:** Oppikirja ja muistiinpanot, joista opit. \n2. **Validointisarja:** Harjoittele suorittamasi kokeet nähdäksesi, mitkä opiskelumenetelmät toimivat parhaiten (esim. säädä hyperparametreja, kuten voit usein parantaa oppimisnopeuttasi. **Testisarja:** Viimeinen, virallinen koe Suoritat sen vain kerran saadaksesi lopullisen pisteesi. Testisarjan käyttäminen toistuvasti mallin virittämiseen olisi kuin 'huijaamista' ja antaisi sinulle liian optimistisen kuvan sen todellisesta suorituskyvystä."
      },
      {
        "question": "Mitä on 'ominaisuussuunnittelu' koneoppimisen yhteydessä?",
        "answers": [
          {
            "answer": "Markkinoinnin pyyntö uuden ominaisuuden lisäämiseksi sovellukseen."
          },
          {
            "answer": "Parhaan koneoppimismallin valinta tietylle ominaisuudelle."
          },
          {
            "answer": "Prosessi, jossa raakadataa käytetään luomaan uusia, informatiivisempia syöttömuuttujia (ominaisuuksia) mallille."
          },
          {
            "answer": "Prosessi, jossa mallin ominaisuudet dokumentoidaan muille kehittäjille."
          }
        ],
        "answer": "Prosessi, jossa raakadataa käytetään luomaan uusia, informatiivisempia syöttömuuttujia (ominaisuuksia) mallille.",
        "explanation": "**Ominaisuuksien suunnittelu** on kriittinen, luova vaihe tehokkaiden mallien luomisessa. Siinä on kyse raakadatan muuntamisesta ominaisuuksiksi, jotka kuvaavat paremmin ennakoivien mallien taustalla olevaa ongelmaa. Jos sinulla on esimerkiksi 'aikaleima' raakatiedoissasi, voit suunnitella uusia ominaisuuksia, kuten 'viikon_päivä', 'kuukausi' tai 'on_viikonlopun ennustava malli'. aikaleima yksin."
      },
      {
        "question": "Petosten havaitsemismallin käyttöönoton jälkeen huomaat, että sen tarkkuus alkaa heikentyä useiden kuukausien jälkeen, koska käyttäjien tapahtumamallit ovat muuttuneet. Millä nimellä tätä ilmiötä yleisesti kutsutaan?",
        "answers": [
          { "answer": "Deployment decay" },
          { "answer": "Mallin tai käsitteen ajautuminen" },
          { "answer": "Ylisovitus" },
          { "answer": "Tekninen velka" }
        ],
        "answer": "Mallin tai konseptin ajautuminen",
        "explanation": "**Mallin ajautuminen** tapahtuu, kun kohdemuuttujan tai syöteominaisuuksien tilastolliset ominaisuudet muuttuvat ajan myötä, jolloin mallin suorituskyky heikkenee. Malli opetettiin historiallisilla tiedoilla, ja kun todellinen maailma muuttuu, mallin oppimat mallit eivät ole enää yhtä tärkeitä. Tästä syystä mallien seuranta tuotannossa ja niiden ajoittainen uudelleenkoulutus uusilla tiedoilla on MLOpsin ydinosa."
      },
      {
        "kysymys": "Mikä Python-kirjasto on yleisin 'yhden luukun kirjasto' klassisten koneoppimismallien rakentamiseen sellaisille tehtäville kuin logistinen regressio, päätöspuut, k-keskiarvoklusterit ja satunnaiset metsät?",
        "answers": [
          { "answer": "TensorFlow" },
          { "answer": "PyTorch" },
          { "answer": "Pandat" },
          { "answer": "Scikit-learn" }
        ],
        "answer": "Scikit-learn",
        "explanation": "**Scikit-learn** on olennainen kirjasto perinteiselle koneoppimiselle Pythonissa. Vaikka TensorFlow ja PyTorch ovat hallitsevia puitteita syväoppimiselle ja hermoverkkoille, Scikit-learn tarjoaa helppokäyttöiset ja tehokkaat työkalut laajalle valikoimalle klassisia ML-algoritmeja ja usein myös tietojen esikäsittelytyökaluja. tavoitat sinut uudessa ML-projektissa."
      },
      {
        "question": "Mihin TensorFlow'ta ja PyTorchia käytetään ensisijaisesti AI/ML-ekosysteemissä?",
        "answers": [
          {
            "answer": "Ne ovat relaatiotietokantoja, jotka on optimoitu ominaisuustietojen tallentamiseen."
          },
          {
            "answer": "Ne ovat puitteita syväoppimismallien, erityisesti hermoverkkojen, rakentamiseen ja koulutukseen."
          },
          {
            "answer": "Ne ovat tietojen visualisointikirjastoja, jotka ovat samanlaisia ​​kuin Matplotlib tai Seaborn."
          },
          {
            "answer": "Ne ovat projektinhallintatyökaluja ML-kokeilujen seurantaan."
          }
        ],
        "answer": "Ne ovat puitteita syväoppimismallien, erityisesti hermoverkkojen, rakentamiseen ja koulutukseen.",
        "explanation": "**TensorFlow** (Google) ja **PyTorch** (Meta/Facebook) ovat kaksi johtavaa avoimen lähdekoodin puitteet syväoppimiseen. Ne tarjoavat tarvittavat rakennuspalikat monimutkaisten hermoverkkojen luomiseen (esim. kerrokset, aktivointitoiminnot, optimoijat) ja ovat erittäin optimoituja suorittamaan tarvittavat tensorin (multi-ray-dim) -operaatiot."
      },
      {
        "question": "Raakaennusteen (esim. 'spam' tai 'not_spam') lisäksi mikä on ratkaiseva tieto sisällytettäväksi luokitusmallin API:n JSON-vastaukseen?",
        "answers": [
          { "answer": "Käytetyn Python-tulkin versionumero." },
          { "answer": "Aika, joka mallilta kesti kouluttautumiseen." },
          { "answer": "Ennustuksen luottamuspiste tai todennäköisyys." },
          { "answer": "Linkki mallin lähdekoodiin GitHubissa." }
        ],
        "answer": "Ennustuksen luottamuspiste tai todennäköisyys.",
        "explanation": "Pelkään lopullisen luokkatunnisteen (esim. 'roskaposti') palauttaminen voi olla rajoittavaa. Paljon hyödyllisempi API-vastaus sisältää **luottamuspisteen** tai todennäköisyyden, jonka malli määrittää ennusteelleen (esim. 'ennuste': 'roskaposti', 'luottamus}' sallii tämän sovelluksen tehdä päätöksen8: 0.9). Voit esimerkiksi poistaa sähköpostin automaattisesti vain, jos roskapostin luotettavuus on > 0,99, mutta merkitä sen tarkistettavaksi, jos luottamus on välillä 0,900,99.",
      },
      {
        "kysymys": "Mikä on vektoritietokannan (esim. Pinecone, Weaviate, Chroma) ensisijainen tarkoitus nykyaikaisissa tekoälysovelluksissa, erityisesti niissä, joissa on semanttinen haku tai RAG LLM:ien kanssa?",
        "answers": [
          {
            "answer": "Perinteisten relaatiotietojen, kuten käyttäjätaulukoiden, tallentamiseen."
          },
          { "answer": "Sosiaalisia verkostoja edustavien kaaviotietojen tallentamiseen." },
          {
            "answer": "Tehokkaasti tallentaa, indeksoida ja tehdä kyselyjä korkeadimensionaalisille vektoriupotuksille löytääkseen samankaltaisimmat kohteet."
          },
          {
            "answer": "API-pyyntöjen ja vastausten välimuistiin nopeuttamiseksi."
          }
        ],
        "answer": "Tehokkaasti tallentaa, indeksoida ja tehdä kyselyjä korkeadimensionaalisille vektoriupotuksille löytääkseen samankaltaisimmat kohteet.",
        "explanation": "Kun teksti tai kuvat muunnetaan numeerisiksi esityksiksi, joita kutsutaan **upotuksiksi**, niistä tulee korkeaulotteisia vektoreita. **Vektoritietokanta** on erikoistunut tietokanta, joka on suunniteltu suorittamaan erittäin nopeita samankaltaisuushakuja näille vektoreille. Esimerkiksi RAG-järjestelmässä (Retrieval-Augmented Generation) voit muuntaa käyttäjän tietokannan vektoriksi useimmissa kysymyksissä. semanttisesti olennaisia ​​tekstinpätkiä asiakirjoistasi syötettäväksi LLM:lle."
      },
      {
        "question": "Mikä on LLM:n RAG-mallin (Retrieval-Augmented Generation) ydinajatus?",
        "answers": [
          {
            "answer": "Menetelmä, jolla LLM saa aikaan satunnaisemman ja luovamman tekstin."
          },
          {
            "answer": "Tekniikka LLM:n hienosäätämiseksi esittämällä sille toistuvasti kysymyksiä."
          },
          {
            "answer": "Hae asiaankuuluvat asiakirjat ulkoisesta tietokannasta ja antaa ne kontekstina LLM:lle vastausta luotaessa."
          },
          {
            "answer": "Voit luoda useita vastauksia ja saada toisen tekoälyn luokittelemaan ne laadun perusteella."
          }
        ],
        "answer": "Hae asiaankuuluvat asiakirjat ulkoisesta tietokannasta ja antaa ne kontekstiksi LLM:lle vastausta luotaessa.",
        "explanation": "**RAG** ​​on tehokas tekniikka, joka tekee LLM:istä tarkempia ja tietävämpiä tietyistä, äskettäisistä tai yksityisistä tiedoista. Sen sijaan, että LLM kysyisi suoraan, järjestelmä hakee ensin asiaankuuluvat asiakirjat tietolähteestä (kuten vektoritietokannasta). Sitten se yhdistää alkuperäisen kysymyksen haettuun tietoon ja lähettää sen LLM:lle yhdessä tarjotussa vastauksessa. vähentää hallusinaatioita ja antaa sen vastata kysymyksiin datasta, jota se ei alun perin ollut koulutettu."
      },
      {
        "question": "Kuinka Dockeria käytetään yleisesti ML-mallien käyttöönotossa, käytäntö, joka on tuttu monille täyden pinon kehittäjille?",
        "answers": [
          {
            "answer": "Ensisijaisena työkaluna koneoppimismallien koulutuksessa."
          },
          {
            "answer": "Pakkaa malli, kaikki sen erityiset riippuvuudet (esim. Python-versio, kirjastot) ja API-palvelin kannettavaan säiliöön."
          },
          { "answer": "Tietokana malliennusteiden tallentamiseen." },
          {
            "answer": "Etupääkehyksenä mallin tulosteiden visualisointiin."
          }
        ],
        "answer": "Jos haluat pakata mallin, kaikki sen erityiset riippuvuudet (esim. Python-versio, kirjastot) ja API-palvelimen kannettavaan säiliöön.",
        "explanation": "Docker ratkaisee klassisen 'se toimii koneellani' -ongelman, joka on erityisen yleistä ML:ssä monimutkaisten riippuvuuksien vuoksi. Luomalla **Docker-säilön** pakkaat koulutetun mallitiedoston, tietyn Python-version, kaikki tarvittavat kirjastot (kuten TensorFlow, Pandas, Flask) ja API-koodisi voidaan sitten ottaa käyttöön yhtenäiseen yksikköön, joka on eristetty ja siirrettävä. kehittäjän kannettava tietokone, välityspalvelin tai tuotantopilviympäristö, mikä varmistaa, että malli toimii täsmälleen samalla tavalla kaikkialla."
      },
      {
        "question": "Olet kouluttanut mallin Scikit-learnillä ja toisen PyTorchilla. Mitä yleisiä alkuperäisiä tiedostomuotoja käyttäisit niiden tallentamiseen myöhempää käyttöä varten?",
        "answers": [
          { "answer": "`.json` Scikit-learnille ja `.yaml` PyTorchille" },
          { "answer": "`.txt` molemmille" },
          {
            "answer": "`.pkl` (pickle) Scikit-learnille ja `.pt` tai `.pth` PyTorchille"
          },
          { "answer": "`.sql` Scikit-learnille ja `.csv` PyTorchille" }
        ],
        "answer": "`.pkl` (pickle) Scikit-learnille ja `.pt` tai `.pth` PyTorchille",
        "explanation": "Eri kehyksillä on omat mallinsa sarjoittamista varten. **Scikit-learn** -mallit tallennetaan usein Pythonin `pickle`-kirjastolla (`.pkl`-tiedostoina) tai `joblib` tehokkuuden vuoksi. **PyTorch**-mallit tallennetaan tyypillisesti käyttämällä `torch.,thsave-tai``. tallentaa mallin tilasanakirjaan (sen opitut painot ja poikkeamat)."
      },
      {
        "question": "Mikä on ensisijainen hyöty PyTorchilla tai TensorFlow'lla opetetun mallin muuntamisesta ONNX (Open Neural Network Exchange) -muotoon?",
        "answers": [
          { "answer": "Se vähentää merkittävästi mallin muistin käyttöä." },
          {
            "answer": "Se tarjoaa puitteet agnostisen, yhteentoimivan muodon malleille, mikä mahdollistaa niiden käytön eri alustoilla ja laitteistoilla."
          },
          {
            "answer": "Se salaa mallin immateriaalioikeuksien suojaamiseksi."
          },
          { "answer": "Se dokumentoi automaattisesti mallin arkkitehtuurin." }
        ],
        "answer": "Se tarjoaa puitteet agnostisen, yhteentoimivan muodon malleille, mikä mahdollistaa niiden käytön eri alustoilla ja laitteistoilla.",
        "explanation": "**ONNX** toimii universaalina kääntäjänä ML-malleille. Muuntamalla mallinne ONNX-muotoon irrotat sen alkuperäisestä harjoituskehyksestä (kuten PyTorch). Näin voit suorittaa johtopäätöksiä käyttämällä korkean suorituskyvyn ONNX Runtimea eri alustoilla (esim. C#- tai Java-ympäristössä ilman alkuperäistä selainympäristöä, Pyhon- tai Java-ympäristöä mobiililaitteissa."
      },
      {
        "question": "Mitä 'tiedon merkintä' tai 'merkintä' prosessi yleensä sisältää valvotussa tietokonenäkötehtävässä, kuten kohteen havaitsemisessa?",
        "answers": [
          { "answer": "Kirjoita kuvaus siitä, mitä kukin kuva sisältää." },
          {
            "answer": "Rajausruutujen piirtäminen manuaalisesti kuvien objektien ympärille ja luokkatunnisteiden määrittäminen niille."
          },
          { "answer": "Kuvien lajittelu kansioihin niiden tiedostokoon perusteella." },
          {
            "answer": "Skriptin suorittaminen, joka tunnistaa objektit automaattisesti."
          }
        ],
        "answer": "Rajausruutujen piirtäminen manuaalisesti kuvien objektien ympärille ja luokkatunnisteiden määrittäminen niille.",
        "explanation": "Tietojen merkitseminen on prosessi, jossa luodaan 'perustatot' valvotulle oppimiselle. Kohteiden havaitsemiseksi tämä tarkoittaa, että ihmisten on käytettävä merkintätyökalua (kuten Label Studio tai Roboflow) piirtämään manuaalisesti laatikot jokaisen kiinnostavan kohteen ympärille tuhansissa kuvissa ja määrittämään tunniste (esim. 'auto', 'jalankulkija'). Tätä mallia käytetään tunnistettujen tietojen etsimiseen.",
      },
      {
        "question": "Mikä on SHAP:n tai LIME:n kaltaisen kirjaston käytön päätavoite käytetyn mallin yhteydessä?",
        "answers": [
          { "answer": "API:n käytettävyyden ja latenssin tarkkaileminen." },
          { "answer": "Mallin pakkaaminen nopeampaa päättelyä varten." },
          {
            "answer": "Tarjoaa selitettävyyttä näyttämällä mitkä ominaisuudet vaikuttivat eniten tiettyyn ennusteeseen."
          },
          { "answer": "Värittää mallin hyperparametrit automaattisesti." }
        ],
        "answer": "Tarjoaa selitettävyyttä osoittamalla, mitkä ominaisuudet vaikuttivat eniten tiettyyn ennusteeseen.",
        "explanation": "Nämä ovat **Explainable AI (XAI)** -työkaluja. Monet ML-mallit, erityisesti monimutkaiset neuroverkot, ovat 'mustia laatikoita'. Kirjastot, kuten SHAP (SHapley Additive ExPlanations) ja LIME (Local Interpretable Model-agnostic Explanations), auttavat sinua ymmärtämään *miksi* malli teki tietyn ennusteen. Ne voivat esimerkiksi osoittaa, että lainahakemus hylättiin ensisijaisesti 'pienien tulojen' ja 'suuren velan' vuoksi, mikä on ratkaisevan tärkeää läpinäkyvyyden, luottamuksen ja virheiden korjaamisen kannalta."
      },
      {
        "question": "Mikä on avainero mallin 'parametrin' ja 'hyperparametrin' välillä?",
        "answers": [
          {
            "answer": "Parametreja käytetään luokitteluun, kun taas hyperparametreja käytetään regressioon."
          },
          {
            "answer": "Parametrit opitaan tiedoista harjoituksen aikana, kun taas kehittäjä asettaa hyperparametrit ennen harjoituksen alkamista."
          },
          {
            "answer": "Parametrit ovat aina kokonaislukuja, kun taas hyperparametrit ovat aina liukulukuja."
          },
          {
            "answer": "Ei eroa, termejä käytetään vaihtokelpoisesti."
          }
        ],
        "answer": "Parametrit opitaan tiedoista harjoituksen aikana, kun taas kehittäjä asettaa hyperparametrit ennen harjoituksen alkamista.",
        "explanation": "Tämä on perustavanlaatuinen ero. **Parametrit** ovat mallin sisäisiä muuttujia, jotka opitaan automaattisesti tiedoistasi (esim. painot ja poikkeamat hermoverkossa). **Hyperparametrit** ovat oppimisprosessin ulkoisia määritysasetuksia, jotka sinun, kehittäjän, on asetettava (esim. oppimisprosessin satunnaisluku, metsän puun kerrosten lukumäärä). Parhaiden hyperparametrien löytämistä kutsutaan hyperparametrien virittämiseksi."
      },
      {
        "question": "Mikä on tärkein syy siihen, että siirtooppimista (esim. käyttämällä esikoulutettua ResNet-mallia kuvien luokitteluun) käytetään niin laajasti käytännössä?",
        "answers": [
          { "answer": "Se on ainoa tapa kouluttaa malleja GPU:lla." },
          {
            "answer": "Se hyödyntää tietoa mallista, joka on jo koulutettu valtavaan tietojoukkoon, mikä vaatii paljon vähemmän dataa ja koulutusaikaa uuteen tehtävään."
          },
          {
            "answer": "Se luo pienempiä malleja, jotka ovat nopeampia reaaliaikaisten päätelmien tekemiseen."
          },
          { "answer": "Se takaa 100 % tarkkuuden kaikissa uusissa tehtävissä." }
        ],
        "answer": "Se hyödyntää tietoa mallista, joka on jo koulutettu valtavaan tietojoukkoon, mikä vaatii paljon vähemmän dataa ja koulutusaikaa uuteen tehtävään.",
        "explanation": "**Siirto-oppiminen** on uskomattoman käytännöllistä. Sen sijaan, että aloittaisit tyhjästä, otat mallin, joka on jo koulutettu valtavaan yleiseen tietojoukkoon (kuten ImageNet kuville). Tämä malli on jo oppinut tunnistamaan perusominaisuudet, kuten reunat, pintakuviot ja muodot. Voit sitten hienosäätää tätä mallia, koska tämä vaatii huomattavasti vähemmän resursseja ja saavuttaa paljon pienempiä, tarkkoja tietojoukkoja. eivät opi perusasiat uudelleen."
      },
      {
        "question": "Kuinka täyspinon kehittäjänä yleensä suojaisit käyttöön otetun ML-mallisi API-päätepisteen luvattoman julkisen käytön estämiseksi?",
        "answers": [
          {
            "answer": "Piilottamalla palvelin yksityiseen verkkoon, jossa ei ole Internet-yhteyttä."
          },
          {
            "answer": "Malli turvaa itsensä automaattisesti lohkoketjulla."
          },
          {
            "answer": "Käyttämällä tavallisia verkkoturvakäytäntöjä, kuten API-avaimia, OAuth- tai JWT-tunnuksia pyynnön otsikoissa."
          },
          { "answer": "Vaihtelemalla päätepisteen URL-osoitetta tunnin välein." }
        ],
        "answer": "Käyttämällä tavallisia verkkoturvakäytäntöjä, kuten API-avaimia, OAuth- tai JWT-tunnuksia pyynnön otsikoissa.",
        "explanation": "ML-mallin sovellusliittymän suojaaminen ei eroa minkään muun tausta-API:n turvaamisesta. Käytät samoja taistelutestattuja verkkoturvaperiaatteita. Yleisin tapa on vaatia **API-avaimen** tai siirtotietunnisteen (kuten **JWT**) sisällyttämistä pyynnön "Authorization"-otsikkoon. Sisällytä tämän jälkeen tämän keskimmäisen avainohjelmiston vahvistus. API-palvelin (esim. tai merkki ennen kuin pyynnön sallitaan edetä malliin johtopäätösten tekemiseksi."
      },
      {
        "question": "Mitä on tietokonenäössä 'datan augmentation'?",
        "answers": [
          {
            "answer": "Ostetaan suurempi tietojoukko kolmannen osapuolen toimittajalta."
          },
          {
            "answer": "Keinotekoinen harjoitustietojoukon koon kasvattaminen luomalla muokattuja kopioita olemassa olevista kuvista (esim. kiertämällä, rajaamalla, kääntämällä)."
          },
          { "answer": "Metatietotunnisteiden lisääminen jokaiseen kuvatiedostoon." },
          { "answer": "Kuvien skaalaaminen korkeampaan resoluutioon." }
        ],
        "answer": "Keinotekoinen harjoitustietojoukon koon kasvattaminen luomalla muokattuja kopioita olemassa olevista kuvista (esim. kiertämällä, rajaamalla, kääntämällä).",
        "explanation": "**Tietojen lisääminen** on tekniikka, jota käytetään lisäämään harjoitustietojoukon monimuotoisuutta ja kokoa ilman, että uutta dataa tarvitsee kerätä. Käyttämällä satunnaisia ​​mutta realistisia muunnoksia, kuten pyörityksiä, käännöksiä, zoomauksia ja värien siirtoja, olemassa oleviin harjoituskuviin opetat mallin olemaan vankempi ja muuttumaton näille muutoksille. Tämä auttaa mallia yleistämään kuvia paremmin ja yhdistämään tehokkaammin uuteen, ylisopivaan tekniikkaan."
      },
      {
        "question": "Mikä on keskeinen hyöty päästä päähän -pilvialustan, kuten AWS SageMakerin, Google AI Platformin tai Azure Machine Learningin, käyttämisestä?",
        "answers": [
          {
            "answer": "Ne tarjoavat valmiiksi koulutettuja malleja, jotka ovat taatusti 100 % tarkkoja mihin tahansa tehtävään."
          },
          { "answer": "Ne ovat täysin ilmaisia ​​eivätkä vaadi asennusta." },
          {
            "answer": "Ne integroivat työkaluja koko ML-elinkaarille tietojen merkitsemisestä ja muistikirjan isännöinnistä koulutukseen, käyttöönottoon ja valvontaan."
          },
          {
            "answer": "Niiden avulla voit ajaa ML-malleja ilman koodia."
          }
        ],
        "answer": "Ne integroivat työkaluja koko ML-elinkaarille, tietojen merkitsemisestä ja muistikirjan isännöinnistä koulutukseen, käyttöönottoon ja valvontaan.",
        "explanation": "Päästä päähän -päähän ML-alustat, kuten **AWS SageMaker**, tarjoavat yhtenäisen, hallitun ympäristön koko koneoppimisen työnkulkuun. Kehittäjälle tämä tarkoittaa, että sinun ei tarvitse manuaalisesti yhdistää erillisiä palveluita tietojen tallennusta, muistikirjaesiintymiä, koulutustöitä, mallirekisterejä, API-päätepisteitä ja valvontaa varten. Nämä alustat helpottavat kokeilua, tehostavat tuotantoprosessia. skaalautuva ja valvottu ML-sovellus."
      },
      {
        "question": "Olet muuntanut luettelon tuotekuvauksista vektoriupotuksiksi. Kuinka voisit ottaa käyttöön 'samankaltaiset tuotteet' -ominaisuuden?",
        "answers": [
          {
            "answer": "Suorittamalla kokotekstihaun vastaaville avainsanoille tuotekuvauksissa."
          },
          {
            "answer": "Laskemalla kosinin samankaltaisuus tai euklidinen etäisyys käyttäjän nykyisen tulovektorin ja kaikkien muiden tulovektoreiden välillä."
          },
          {
            "answer": "Lajittelemalla tuotteet aakkosjärjestykseen kuvauksen mukaan."
          },
          {
            "answer": "Opettelemalla erillinen luokitusmalli ennustamaan samankaltaisuutta."
          }
        ],
        "answer": "Laskemalla kosinin samankaltaisuus tai euklidinen etäisyys käyttäjän nykyisen tulovektorin ja kaikkien muiden tulovektorien välillä.",
        "explanation": "Tämä on upotusten ydinsovellus. Koska upotukset edustavat merkitystä vektoriavaruuden pisteinä, 'semanttinen samankaltaisuus' tarkoittaa 'läheisyyttä' kyseisessä tilassa. Samankaltaisten tuotteiden löytämiseksi ottaisit tuotteen vektorin, jota käyttäjä tällä hetkellä katselee, ja lasketaan sen etäisyys kaikkiin muihin tuotevektoriin. **Kosinikulman samankaltaisuus** on tämän kahden välisen samankaltaisuuden mittakaava. vektoreita, arvioiden tehokkaasti niiden suuntaa, eikä vain niiden suuruutta. Tuotteet, joilla on korkeimmat samankaltaisuuspisteet (tai pienin etäisyys), ovat semanttisesti samankaltaisimmat."
      }
    ]
  },
  {
    "name": "Maantiede (Perustiedot)",
    "image": "https://images.unsplash.com/photo-1542044896-0b1512535934",
    "questions": [
      {
        "kysymys": "Mikä on maailman pisin joki, joka virtaa Koillis-Afrikan läpi?",
        "answers": [
          { "answer": "Amazonjoki" },
          { "answer": "Niilijoki" },
          { "answer": "Jangtse-joki" },
          { "answer": "Mississippi-joki" }
        ],
        "answer": "Niilijoki",
        "explanation": "Niilijokea pidetään perinteisesti maailman pisimpana joena, ja se ulottuu noin 6 650 kilometriä (4 132 mailia) sen lähteistä Keski-Afrikassa Välimerelle. Vaikka Amazonjoki Etelä-Amerikassa on suurin virtaaman määrä, Niili on pituudeltaan suurin."
      },
      {
        "kysymys": "Mikä on maan suurin ja syvin valtameri?",
        "answers": [
          { "answer": "Atlantin valtameri" },
          { "answer": "Intian valtameri" },
          { "answer": "Jäämeri" },
          { "answer": "Tyynimeri" }
        ],
        "answer": "Tyynimeri",
        "explanation": "Tyynimeri on suurin maailman viidestä valtamerestä, ja se peittää noin kolmanneksen maan pinnasta. Se sisältää myös maan syvin tunnetun pisteen, Mariana-haudon, mikä tekee siitä myös syvin valtameren."
      },
      {
        "kysymys": "Mikä on sen kuvitteellisen leveysasteen nimi, joka jakaa maapallon pohjoiseen ja eteläiseen pallonpuoliskoon?",
        "answers": [
          { "answer": "Päämeridiaani" },
          { "answer": "Päiväntasaaja" },
          { "answer": "The Tropic of Cancer" },
          { "answer": "Kansainvälinen päivämääräviiva" }
        ],
        "answer": "Päiväntasaaja",
        "explanation": "Ekvaattori on kuvitteellinen viiva maan pinnalla yhtä kaukana pohjoisnavasta ja etelänavasta. Se jakaa Maan pohjoiseen pallonpuoliskoon ja eteläiseen pallonpuoliskoon. Se on 0° leveysasteen viiva ja se on leveysasteen mittauksen lähtöpiste."
      },
      {
        "question": "Mount Everest, maailman korkein vuorenhuippu, kuuluu mihin vuorijonoon?",
        "answers": [
          { "answer": "Andet" },
          { "answer": "Kalliovuoret" },
          { "answer": "Alpit" },
          { "answer": "Himalaja" }
        ],
        "answer": "Himalaja",
        "explanation": "Himalaja on laaja vuorijono Aasiassa, joka erottaa Intian niemimaan tasangot Tiibetin tasangosta. Tällä vuoristolla sijaitsevat planeetan korkeimmat huiput, mukaan lukien korkein Mount Everest, joka sijaitsee Nepalin ja Kiinan rajalla."
      },
      {
        "kysymys": "Mikä on maailman suurin kuuma aavikko, joka kattaa suurimman osan Pohjois-Afrikasta?",
        "answers": [
          { "answer": "Gobi autiomaa" },
          { "answer": "Arabian autiomaa" },
          { "answer": "Saharan autiomaa" },
          { "answer": "Kalaharin autiomaa" }
        ],
        "answer": "Saharan autiomaa",
        "explanation": "Sahara on maailman suurin kuuma aavikko ja kokonaisuutena kolmanneksi suurin aavikko Etelämantereen ja arktisen kylmän napa-aavikon jälkeen. Se kattaa valtavan osan Pohjois-Afrikasta, ulottuen Atlantin valtamerestä Punaiseen mereen."
      },
      {
        "question": "Mikä on Kanadan pääkaupunki?",
        "answers": [
          { "answer": "Toronto" },
          { "answer": "Vancouver" },
          { "answer": "Montreal" },
          { "answer": "Ottawa" }
        ],
        "answer": "Ottawa",
        "explanation": "Vaikka Toronto on Kanadan suurin kaupunki ja merkittävä taloudellinen keskus, pääkaupunki on Ottawa. Se sijaitsee Ontarion maakunnassa, Quebecin rajalla."
      },
      {
        "kysymys": "Minkä ilmiön ensisijainen syy on Maan pyöriminen akselinsa ympäri?",
        "answers": [
          { "answer": "vuodenajat" },
          { "answer": "Päivä ja yö" },
          { "answer": "Kuun vaiheet" },
          { "answer": "Vuorovesi" }
        ],
        "answer": "Päivä ja yö",
        "explanation": "Maa pyörii akselinsa ympäri kerran 24 tunnissa. Tämä pyöriminen aiheuttaa päivän ja yön kierron. Maan aurinkoon päin oleva puoli kokee päivänvaloa, kun taas Auringosta poispäin oleva puoli kokee yön. Vuodenajat johtuvat Maan akselin kallistumisesta sen pyöriessä Auringon ympäri."
      },
      {
        "question": "Mikä on 0° pituuspiirin nimi, joka kulkee Greenwichin, Englannin, kautta ja toimii pohjana maailman aikavyöhykkeille?",
        "answers": [
          { "answer": "Päiväntasaaja" },
          { "answer": "Kaurisen trooppinen" },
          { "answer": "Päämeridiaani" },
          { "answer": "Napapiiri" }
        ],
        "answer": "Päämeridiaani",
        "explanation": "Päämeridiaani on 0° pituusasteen viiva, lähtöpiste mitataan pituusasteita idästä ja lännestä Maan ympäri. Vuonna 1884 sovittiin kansainvälisesti kulkemisesta Lontoon Greenwichin kuninkaallisen observatorion läpi. Se on myös koordinoidun maailmanajan (UTC) perusta."
      },
      {
        "question": "Mikä näistä maista on myös maanosa?",
        "answers": [
          { "answer": "Intia" },
          { "answer": "Brasilia" },
          { "answer": "Australia" },
          { "answer": "Grönlanti" }
        ],
        "answer": "Australia",
        "explanation": "Australia on ainutlaatuinen siinä mielessä, että se on ainoa maa maailmassa, joka kattaa koko mantereen. Se on kokonaispinta-alaltaan maailman kuudenneksi suurin maa ja pienin maanosa. Grönlanti on maailman suurin saari, mutta se on osa Pohjois-Amerikan mannerta."
      },
      {
        "kysymys": "Millä prosessilla ilmassa oleva vesihöyry muuttuu nestemäiseksi vedeksi muodostaen pilviä?",
        "answers": [
          { "answer": "Haihtuminen" },
          { "answer": "Sademäärä" },
          { "answer": "Condensation" },
          { "answer": "Transpiraatio" }
        ],
        "answer": "tiivistymistä",
        "explanation": "Kondensaatio on prosessi, jossa ilmakehän vesihöyry (kaasu) jäähtyy ja muuttuu takaisin nestemäiseksi vedeksi muodostaen pilviä. Haihtuminen on prosessi, jossa nestemäinen vesi muuttuu vesihöyryksi. Sade on vettä, joka vapautuu pilviä sateen, lumen, räntäsateen tai rakeiden muodossa. Haihtuminen on prosessi, jossa kasvien lehdistä vapautuu vesihöyryä."
      },
      {
        "kysymys": "Mikä seitsemästä mantereesta on pinta-alaltaan ja väestöltään suurin?",
        "answers": [
          { "answer": "Afrikka" },
          { "answer": "Pohjois-Amerikka" },
          { "answer": "Aasia" },
          { "answer": "Eurooppa" }
        ],
        "answer": "Aasia",
        "explanation": "Aasia on maailman suurin ja väkirikkain maanosa, joka kattaa noin 30 % maapallon kokonaispinta-alasta. Siellä asuu yli puolet maailman väestöstä, ja tärkeimmät väestökeskukset sijaitsevat Kiinassa ja Intiassa."
      },
      {
        "kysymys": "Mikä on Tyynenmeren laajan hevosenkengän muotoisen alueen nimi, joka tunnetaan suuresta määrästä maanjäristyksiä ja aktiivisia tulivuoria?",
        "answers": [
          { "answer": "Mariaanihauta" },
          { "answer": "Tulirengas" },
          { "answer": "The Mid-Atlantic Ridge" },
          { "answer": "Suuri valliriutta" }
        ],
        "answer": "Tulenrengas",
        "explanation": "Tulirengas on Tyynellämerellä kulkeva polku, jolle ovat ominaisia ​​aktiiviset tulivuoret ja toistuvat maanjäristykset. Suurin osa Maan tulivuorista ja maanjäristyksistä tapahtuu tällä vyöhykkeellä, mikä johtuu levytektoniikasta, erityisesti litosfäärilevyjen liikkeestä ja törmäyksistä."
      },
      {
        "question": "Mikä on maailman suurin saari?",
        "answers": [
          { "answer": "Madagaskar" },
          { "answer": "Borneo" },
          { "answer": "Iso-Britannia" },
          { "answer": "Grönlanti" }
        ],
        "answer": "Grönlanti",
        "explanation": "Grönlanti on maailman suurin saari, joka sijaitsee arktisen ja Atlantin valtameren välissä. Australia on suurempi, mutta se on luokiteltu mannermaiseksi maa-alueeksi saaren sijaan."
      },
      {
        "question": "Mikä on ensisijainen ero sään ja ilmaston välillä?",
        "answers": [
          {
            "answer": "Sää mitataan satelliiteilla, kun taas ilmasto mitataan maa-asemilla."
          },
          {
            "answer": "Sää tarkoittaa lyhyen aikavälin ilmakehän olosuhteita, kun taas ilmasto on pitkän aikavälin sään keskiarvo."
          },
          {
            "answer": "Sää sisältää vain lämpötilan ja sateet, kun taas ilmasto sisältää tuulen ja kosteuden."
          },
          { "answer": "Ei eroa, termit ovat keskenään vaihdettavissa." }
        ],
        "answer": "Säällä tarkoitetaan lyhytaikaisia ​​ilmakehän olosuhteita, kun taas ilmasto on sään pitkän aikavälin keskiarvo.",
        "explanation": "Sää kuvaa ilmakehän olosuhteita lyhyellä aikavälillä (esim. minuuteista päiviin), mukaan lukien lämpötilan, kosteuden, sademäärän ja tuulen kaltaiset tekijät. Ilmasto puolestaan ​​on sääolosuhteiden keskiarvo tietyllä alueella pitkän ajanjakson, tyypillisesti 30 vuoden tai pidemmän ajanjakson aikana."
      },
      {
        "kysymys": "Millä nimellä kutsutaan maan ulointa kiinteää kerrosta?",
        "answers": [
          { "answer": "Ydin" },
          { "answer": "The Mantle" },
          { "answer": "The Crust" },
          { "answer": "Litosfääri" }
        ],
        "answer": "Kuori",
        "explanation": "Maa koostuu useista kerroksista. Kuori on erittäin ohut, uloin kiinteä kerros, jossa asumme. Kuoren alla on vaippa ja keskellä on ydin (jaettu ulko- ja sisäytimeen). Litosfääri on maan jäykkä ulkoosa, joka koostuu kuoresta ja ylemmästä vaipasta."
      },
      {
        "question": "Mikä on Australian pääkaupunki?",
        "answers": [
          { "answer": "Sydney" },
          { "answer": "Melbourne" },
          { "answer": "Canberra" },
          { "answer": "Perth" }
        ],
        "answer": "Canberra",
        "explanation": "Vaikka Sydney ja Melbourne ovat suurempia ja tunnetumpia kaupunkeja, Canberra valittiin Australian pääkaupungiksi vuonna 1908 kompromissiksi kahden kilpailijan välillä. Se on suunniteltu kaupunki ja Australian liittohallituksen paikka."
      },
      {
        "kysymys": "Mikä on kapea maakaistale, joka yhdistää kaksi suurempaa maa-aluetta ja jonka molemmin puolin vesi rajaa?",
        "answers": [
          { "answer": "Niemimaa" },
          { "answer": "saaristo" },
          { "answer": "Kannaus" },
          { "answer": "salmi" }
        ],
        "answer": "Kannaus",
        "explanation": " Kannaks on kapea maakaistale, joka yhdistää kaksi suurempaa maamassaa. Kuuluisa esimerkki on Panaman kannas, joka yhdistää Pohjois- ja Etelä-Amerikan. Niemi on melkein veden ympäröimä maapala, ja salmi on kapea vesiväylä, joka yhdistää kaksi suurempaa vesistöä."
      },
      {
        "kysymys": "Mikä maa ohitti äskettäin Kiinan ja nousi maailman väkirikkaimmaksi valtioksi?",
        "answers": [
          { "answer": "Yhdysvallat" },
          { "answer": "Indonesia" },
          { "answer": "Intia" },
          { "answer": "Nigeria" }
        ],
        "answer": "Intia",
        "explanation": "Vuodesta 2023 lähtien Intia ohitti Kiinan ja tuli maailman suurimmaksi väestöksi maaksi. Molemmissa maissa on yli 1,4 miljardia ihmistä."
      },
      {
        "question": "Mikä on pinta-alaltaan maailman suurin makean veden järvi?",
        "answers": [
          { "answer": "Baikaljärvi" },
          { "answer": "Victoriajärvi" },
          { "answer": "Lake Superior" },
          { "answer": "Kaspianmeri" }
        ],
        "answer": "Lake Superior",
        "explanation": "Lake Superior, joka sijaitsee Pohjois-Amerikassa ja jakaa Kanadan ja Yhdysvaltojen, on pinta-alaltaan maailman suurin makean veden järvi. Siperian Baikal-järvi on tilavuudeltaan maailman suurin makean veden järvi, joka sisältää enemmän vettä kuin kaikki Pohjois-Amerikan suuret järvet yhteensä."
      },
      {
        "question": "Miden kahden pisteen välillä kulkevat maapallon pituuspiirit?",
        "answers": [
          { "answer": "Päiväntasaaja ja syövän trooppinen alue" },
          { "answer": "Itä- ja länsinapa" },
          { "answer": "Päämeridiaani ja kansainvälinen päivämääräviiva" },
          { "answer": "Pohjoinen napa ja etelänava" }
        ],
        "answer": "Pohjoinen napa ja etelänapa",
        "explanation": "Pituusasteviivat, joita kutsutaan myös meridiaaniksi, ovat kuvitteellisia viivoja, jotka kulkevat pystysuorassa ympäri maapalloa pohjoisnavalta etelänavalle. Niitä käytetään mittaamaan etäisyyttä päämeridianista itään ja länteen (0° pituusaste)."
      }
    ]
  },
  {
    "name": "Taloustiede (Perustiedot)",
    "image": "https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3",
    "questions": [
      {
        "kysymys": "Mikä on se perustavanlaatuinen taloudellinen ongelma, joka syntyy, koska ihmisillä on rajattomat toiveet, mutta resurssit ovat rajalliset?",
        "answers": [
          { "answer": "Inflaatio" },
          { "answer": "Mahdollisuus hinta" },
          { "answer": "Nukkuus" },
          { "answer": "Monopoli" }
        ],
        "answer": "Puukkuus",
        "explanation": "Nukkuus on taloustieteen ydinkäsite. Se viittaa perusongelmaan, joka syntyy siitä, että ihmisten tarpeet tavaroita ja palveluja kohtaan ovat rajattomat, kun taas näiden tarpeiden tyydyttämiseen käytettävissä olevat resurssit ovat rajalliset. Tämä edellyttää ihmisten ja yhteiskuntien tekevän valintoja resurssien tehokkaasta kohdistamisesta."
      },
      {
        "kysymys": "Kysynnän ja tarjonnan laissa, jos tuotteen kysyntä yhtäkkiä kasvaa tarjonnan pysyessä samana, mitä tuotteen hinnalle todennäköisesti tapahtuu?",
        "answers": [
          { "answer": "Hinta laskee." },
          { "answer": "Hinta pysyy samana." },
          { "answer": "Hinta nousee." },
          { "answer": "Hinnasta tulee arvaamaton." }
        ],
        "answer": "Hinta nousee.",
        "explanation": "Kysynnän ja tarjonnan laki kuvaa, kuinka resurssin saatavuuden (tarjonnan) ja resurssin halun (kysynnän) välinen vuorovaikutus vaikuttaa sen hintaan. Kun kysyntä kasvaa (enemmän ihmiset haluavat tuotteen), mutta tarjonta ei muutu, kilpailu rajoitetusta tuotteesta lisääntyy. Tämä lisääntynyt kilpailu yleensä nostaa hintaa."
      },
      {
        "question": "Mikä on termi seuraavaksi parhaan vaihtoehdon arvolle, josta sinun on luovuttava voidaksesi valita jotain muuta?",
        "answers": [
          { "answer": "Rajakustannus" },
          { "answer": "Sunk Cost" },
          { "answer": "Mahdollisuus hinta" },
          { "answer": "Suhteellinen etu" }
        ],
        "answer": "Vaihtoehtoinen hinta",
        "explanation": "Vaihtoehtokustannus on ratkaiseva käsite, joka edustaa mahdollisia hyötyjä, jotka jäävät käyttämättä, kun valitset yhden vaihtoehdon toiseen verrattuna. Jos sinulla on esimerkiksi 20 dollaria ja päätät ostaa kirjan elokuvissa käymisen sijaan, vaihtoehtokustannus on nautinto, jonka olisit saanut elokuvan katsomisesta."
      },
      {
        "question": "Mitä maan bruttokansantuote (BKT) mittaa?",
        "answers": [
          {
            "answer": "Kaikkien sen kansalaisten kokonaistulot, mukaan lukien ulkomailla olevat."
          },
          {
            "answer": "Kaikkien valmiiden tuotteiden ja palveluiden kokonaisarvo, joka on tuotettu maan rajojen sisällä tietyllä ajanjaksolla."
          },
          { "answer": "Viennin kokonaismäärä miinus tuonti." },
          { "answer": "Maan kunkin kansalaisen keskimääräinen varallisuus." }
        ],
        "answer": "Kaikkien valmiiden tuotteiden ja palvelujen kokonaisarvo, jotka on tuotettu maan rajojen sisällä tietyllä ajanjaksolla.",
        "explanation": "Bruttokansantuote (BKT) on yksi yleisimmistä indikaattoreista, joita käytetään kansantalouden kunnon seuraamiseen. Se edustaa kaikkien valmiiden tuotteiden ja palvelujen kokonaismarkkina-arvoa, jotka on tuotettu *maan maantieteellisten rajojen sisällä* tietyn ajanjakson aikana (yleensä vuosineljänneksen tai vuoden aikana)."
      },
      {
        "kysymys": "Mikä on taloudellinen termi tavaroiden ja palveluiden hintojen yleiselle nousulle, joka johtaa rahan ostovoiman laskuun?",
        "answers": [
          { "answer": "Taantuma" },
          { "answer": "Deflaatio" },
          { "answer": "Stagflaatio" },
          { "answer": "Inflaatio" }
        ],
        "answer": "Inflaatio",
        "explanation": "Inflaatio on nopeus, jolla tavaroiden ja palveluiden yleinen hintataso nousee, mikä tarkoittaa, että valuutan ostovoima laskee. Jos inflaatio on esimerkiksi 2 % vuodessa, niin tänään 100 dollaria maksava tavarakori maksaa 102 dollaria ensi vuonna. Keskuspankit pyrkivät usein pitämään inflaation alhaisena, stable."
      },
      {
        "kysymys": "Millaiselle markkinarakenteelle on ominaista se, että yksi myyjä myy ainutlaatuista tuotetta ilman läheisiä korvikkeita?",
        "answers": [
          { "answer": "Täydellinen kilpailu" },
          { "answer": "Oligopoli" },
          { "answer": "Monopolistinen kilpailu" },
          { "answer": "Monopoli" }
        ],
        "answer": "Monopoli",
        "explanation": "Monopoli on markkinarakenne, jossa yksi yritys tai ryhmä omistaa kaikki tai lähes kaikki tietyntyyppisen tuotteen tai palvelun markkinat. Koska kilpailua ei ole, monopolilla on merkittävä valta vaikuttaa tuotteensa hintaan. Tämä johtaa usein korkeampiin hintoihin kuin kilpailluilla markkinoilla."
      },
      {
        "kysymys": "Mitä seuraavista EI tyypillisesti pidetä yhtenä neljästä talouden päätuotannon tekijästä?",
        "answers": [
          { "answer": "Maa" },
          { "answer": "työvoima" },
          { "answer": "Iso" },
          { "answer": "Raha" }
        ],
        "answer": "Raha",
        "explanation": "Neljä tärkeintä tuotannontekijää ovat resurssit, joita käytetään tavaroiden ja palvelujen tuottamiseen. Ne ovat:\n1. **Maa:** Luonnonvarat.\n2. **Työ:** Ihmisten työpanos.\n3. **Pääoma:** Tuotannossa käytettävät ihmisen tekemät tavarat (esim. koneet, työkalut).\n4. **Yrittäjä, joka yhdistää rahaa, on yrittäjä.** Muut tekijät, jotka yhdistävät yrityksen: Olennaista näiden tekijöiden hankkimiseksi, sitä pidetään taloudellisena pääomana eikä itse suorana tuotantotekijänä."
      },
      {
        "question": "Mikä instituutio on tyypillisesti vastuussa maan rahapolitiikasta, kuten korkojen asettamisesta ja rahan tarjonnan hallinnasta?",
        "answers": [
          { "answer": "Valtiovarainministeriö tai valtiovarainministeriö" },
          {
            "answer": "Keskuspankki (esim. Yhdysvaltain keskuspankki)"
          },
          { "answer": "Pörssi" },
          { "answer": "Kansainvälinen valuuttarahasto (IMF)" }
        ],
        "answer": "Keskuspankki (esim. Yhdysvaltain keskuspankki)",
        "explanation": "Maan keskuspankki on instituutio, joka vastaa valuutan, rahan tarjonnan ja korkojen hallinnasta. Tätä kutsutaan rahapolitiikaksi. Korkoja säätämällä keskuspankki voi vaikuttaa inflaatioon ja työllisyyteen. Valtiovarainministeriö tai valtiovarainministeriö puolestaan ​​hoitaa tyypillisesti valtion budjetti- ja finanssipolitiikan."
      },
      {
        "kysymys": "Mitä ovat kaksi finanssipolitiikan ensisijaista työkalua, joilla hallitus voi vaikuttaa talouteensa?",
        "answers": [
          { "answer": "Korot ja rahan tarjonta" },
          { "answer": "Tuonti ja vienti" },
          { "answer": "Julkiset menot ja verotus" },
          { "answer": "Palkat ja hinnat" }
        ],
        "answer": "Julkiset menot ja verotus",
        "explanation": "Fiksaalipolitiikka viittaa julkisten menojen ja verotuksen käyttöön maan talouteen vaikuttamiseen. Hallitukset voivat lisätä menojaan ja/tai alentaa veroja edistääkseen talouskasvua (elvyttävä finanssipolitiikka), tai ne voivat vähentää menoja ja/tai korottaa veroja hidastaakseen ylikuumenevaa taloutta (ristiriitainen finanssipolitiikka)."
      },
      {
        "kysymys": "Jos maan viennin kokonaisarvo on suurempi kuin sen tuonnin kokonaisarvo, mitä maalla on?",
        "answers": [
          { "answer": "Kauppaalijäämä" },
          { "answer": "Kauppaylijäämä" },
          { "answer": "Tasapainoinen budjetti" },
          { "answer": "Valtionvelka" }
        ],
        "answer": "Kaupan ylijäämä",
        "explanation": "Maan kauppatase on sen viennin arvon ja tuonnin arvon välinen erotus.\n- Kun **Vienti > Tuonti**, maalla on **kauppaylijäämä**, mikä tarkoittaa, että se myy muille maille enemmän kuin ostaa niiltä.\n- Kun **Tuonti > Vienti**, maalla on **kauppaalijäämä**."**
      },
      {
        "kysymys": "Mitkä ovat taloustieteen neljä ensisijaista tuotannontekijää?",
        "answers": [
          { "answer": "Maa, työ, pääoma ja raha" },
          { "answer": "Vesi, ilma, tuli ja maa" },
          { "answer": "Maa, työ, pääoma ja yrittäjyys" },
          { "answer": "Teknologia, data, työvoima ja palvelut" }
        ],
        "answer": "Maa, työ, pääoma ja yrittäjyys",
        "explanation": "Tuotantotekijät ovat panoksia, joita käytetään tavaroiden ja palvelujen tuottamiseen. Ne ovat:\n1. **Maa:** Kaikki luonnonvarat, kuten maa, mineraalit, vesi ja metsät.\n2. **Työ:** Tuotannossa käytetty ihmisen fyysinen ja henkinen ponnistus.\n3. **Pääoma:** Ihmisten valmistamat tavarat, kuten rakennustavarat,\\muiden rakennustavaroiden ja -palvelut4. **Yrittäjyys:** Sen henkilön taito ja riskinottokyky, joka yhdistää kolme muuta tekijää tuottaakseen tavaroita ja palveluita."
      },
      {
        "kysymys": "Mikä taloudellinen termi kuvaa tilapäisen taloudellisen taantuman ajanjaksoa, jonka aikana kauppa ja teollinen toiminta vähenevät, mikä yleensä tunnistetaan BKT:n laskuna kahdella peräkkäisellä vuosineljänneksellä?",
        "answers": [
          { "answer": "Inflaatio" },
          { "answer": "Stagflaatio" },
          { "answer": "masennus" },
          { "answer": "Taantuma" }
        ],
        "answer": "Taantuma",
        "explanation": "Taantuma on merkittävä, laajalle levinnyt ja pitkittynyt taloudellisen toiminnan taantuma. Yleinen nyrkkisääntö on, että taantuma syntyy, kun maan bruttokansantuote (BKT) laskee kahtena peräkkäisenä vuosineljänneksenä. Se on normaali, vaikkakin tuskallinen osa suhdannesykliä. Lama on vakavampi ja pidempi taantuma."
      },
      {
        "kysymys": "Jos hallitus määrää tuontitavaroista veron, mikä tämän veron nimi on?",
        "answers": [
          { "answer": "Kiintiö" },
          { "answer": "Ebargo" },
          { "answer": "tariffi" ​​},
          { "answer": "Avustus" }
        ],
        "answer": "tariffi",
        "explanation": "Tuli on vero, jonka hallitus asettaa muista maista tuoduille tavaroille ja palveluille. Tullien ensisijainen tarkoitus on suojella kotimaista teollisuutta tekemällä tuontitavaroista kalliimpia, mikä kannustaa kuluttajia ostamaan kotimaassa tuotettuja tuotteita. Ne toimivat myös tulonlähteenä hallitukselle."
      },
      {
        "kysymys": "Millä termillä tarkoitetaan lisätyytyväisyyttä tai -hyötyä, jonka kuluttaja saa kuluttaen yhden tavaran tai palvelun yksikön enemmän?",
        "answers": [
          { "answer": "Total Utility" },
          { "answer": "Rajahyöty" },
          { "answer": "Mahdollisuus hinta" },
          { "answer": "Kuluttajaylijäämä" }
        ],
        "answer": "Rajahyöty",
        "explanation": "Rajahyötyisyys on lisätyytyväisyys, jonka kuluttaja saa siitä, että hänellä on yksi yksikkö lisää tavaraa tai palvelua. Taloustieteilijät käyttävät tätä käsitettä määrittämään, kuinka paljon tuotetta kuluttaja ostaa. Rajahyödyllisyyden laskun laki sanoo, että kun henkilö kuluttaa enemmän tuotetta, tyytyväisyys vähenee jokaisesta lisäyksiköstä."
      },
      {
        "kysymys": "Mille talousjärjestelmälle on ominaista tuotantovälineiden yksityinen omistus ja niiden käyttö voittoa tavoittelemalla?",
        "answers": [
          { "answer": "Sosialismi" },
          { "answer": "Kommunismi" },
          { "answer": "Kapitalismi" },
          { "answer": "Feodalismi" }
        ],
        "answer": "Kapitalismi",
        "explanation": "Kapitalismi, joka tunnetaan myös nimellä markkinatalous, on talousjärjestelmä, jossa yksityishenkilöt tai yritykset omistavat pääomahyödykkeitä. Tavaroiden ja palveluiden tuotanto perustuu tarjontaan ja kysyntään yleisillä markkinoilla eikä keskitetyn suunnittelun kautta. Kapitalismin perusperiaatteita ovat yksityinen omaisuus, pääoman kertyminen, palkkatyö ja kilpailulliset markkinat."
      },
      {
        "kysymys": "Mitä tapahtuu normaalin tavaran vaaditulle määrälle, kun sen hinta laskee kysynnän lain mukaan?",
        "answers": [
          { "answer": "Vaadittu määrä kasvaa." },
          { "answer": "Vaadittu määrä vähenee." },
          { "answer": "Vaadittu määrä pysyy samana." },
          { "answer": "Kysyntäkäyrä siirtyy vasemmalle." }
        ],
        "answer": "Vaadittu määrä kasvaa.",
        "explanation": "Kysynnän laki sanoo, että kaikkien muiden tekijöiden ollessa samat tavaran tai palvelun hinnan laskiessa kuluttajien vaatima määrä kasvaa. Toisaalta tavaran tai palvelun hinnan noustessa kysytty määrä vähenee. Ihmiset ovat yleensä valmiita ostamaan jotain enemmän, kun se on halvempaa."
      },
      {
        "kysymys": "Mikä taloudellinen käsite kuvaa tilannetta, jossa markkinat eivät yksinään pysty allokoimaan resursseja tehokkaasti, mikä johtaa taloudellisen arvon nettomenetykseen?",
        "answers": [
          { "answer": "Market Equilibrium" },
          { "answer": "Market Failure" },
          { "answer": "Täydellinen kilpailu" },
          { "answer": "Talouskasvu" }
        ],
        "answer": "Markkinavika",
        "explanation": "Markkinoiden epäonnistuminen on tilanne, jossa tavaroiden ja palvelujen allokointi vapailla markkinoilla ei ole tehokasta, mikä usein johtaa taloudellisen arvon nettomenetyksiin. Yleisiä markkinoiden epäonnistumisen syitä ovat ulkoisvaikutukset (taloudellisen toiminnan sivuvaikutukset, kuten saastuminen), julkiset hyödykkeet (jotka eivät ole poissuljettavissa ja kilpailemattomia) ja tiedon epäsymmetria."
      },
      {
        "kysymys": "Millä termillä tarkoitetaan yksilön tai väestön taitoja, tietoja ja kokemusta, kun tarkastellaan niiden arvoa tai kustannuksia organisaatiolle tai maalle?",
        "answers": [
          { "answer": "Sosiaalinen pääoma" },
          { "answer": "Fyysinen pääoma" },
          { "answer": "Financial Capital" },
          { "answer": "Ihmispääoma" }
        ],
        "answer": "Inhimillinen pääoma",
        "explanation": "Ihmispääoma on aineeton omaisuus tai laatu, jota ei ole listattu yrityksen taseeseen. Se voidaan luokitella työntekijän kokemuksen ja taitojen taloudelliseksi arvoksi. Tämä sisältää omaisuuden, kuten koulutuksen, koulutuksen, älykkyyden, taidot, terveyden ja muut työnantajien arvostamat asiat, kuten uskollisuuden ja täsmällisyyden. Se on talouskasvun ja tuottavuuden avaintekijä."
      },
      {
        "question": "Mikä on käyrän nimi, joka näyttää kahden tuotteen erilaiset yhdistelmät, jotka voidaan tuottaa käytettävissä olevilla resursseilla ja teknologialla?",
        "answers": [
          { "answer": "Kysyntäkäyrä" },
          { "answer": "Supply Curve" },
          { "answer": "välinpitämättömyyskäyrä" },
          { "answer": "Production Possibility Frontier (PPF)" }
        ],
        "answer": "Production Possibility Frontier (PPF)",
        "explanation": "Tuotantomahdollisuuksien raja (PPF), joka tunnetaan myös tuotantomahdollisuuksien käyränä, on kaavio, joka havainnollistaa kahden tuotteen mahdollisia määriä, jotka talous voi tuottaa tietyllä määrällä resursseja ja tekniikkaa. Käyrä näyttää kompromisseja yhden hyödykkeen ja toisen tuotannon välillä, ja sitä käytetään osoittamaan käsitteitä, kuten niukkuus, vaihtoehtokustannukset ja tehokkuus."
      },
      {
        "kysymys": "Mikä on inflaation vastakohta, jolle on ominaista tavaroiden ja palveluiden yleinen hintojen lasku?",
        "answers": [
          { "answer": "Taantuma" },
          { "answer": "Stagflaatio" },
          { "answer": "Deflaatio" },
          { "answer": "Dinflaatio" }
        ],
        "answer": "Deflaatio",
        "explanation": "Deflaatio on tavaroiden ja palveluiden hintatason yleinen lasku. Se tapahtuu, kun inflaatio laskee alle 0%. Vaikka hintojen lasku saattaa tuntua hyvältä kuluttajille, deflaatio voi olla erittäin haitallista taloudelle. Se kasvattaa velan reaaliarvoa ja voi johtaa kysynnän laskun, tuotannon laskun noidankehään, koska kuluttajahintojen ennakointi viivästyttää jopa työttömyyden nousua."
      }
    ]
  },
  {
    "name": "Psykologia (Perusteet)",
    "image": "https://images.unsplash.com/photo-1577896851231-70f144cf4f39",
    "questions": [
      {
        "kysymys": "Mikä Sigmund Freudin perustama psykologian koulukunta korostaa tiedostamattoman mielen roolia käyttäytymisen ja persoonallisuuden määrittelyssä?",
        "answers": [
          { "answer": "Behaviorismi" },
          { "answer": "Humanistinen psykologia" },
          { "answer": "Psykoanalyysi" },
          { "answer": "Kognitiivinen psykologia" }
        ],
        "answer": "Psykoanalyysi",
        "explanation": "Sigmund Freudin kehittämä psykoanalyysi on joukko psykologisia teorioita ja terapeuttisia tekniikoita. Psykoanalyysin ydinajatus on usko, että kaikilla ihmisillä on tiedostamattomia ajatuksia, tunteita, haluja ja muistoja. Freud uskoi, että nämä tiedostamattomat elementit voivat vaikuttaa tietoiseen käyttäytymiseen, ja hän kehitti tekniikoita, kuten unianalyysin ja vapaan assosiaatioiden tutkimisen."
      },
      {
        "kysymys": "Mikä on klassisessa ehdottelussa aiemmin neutraali ärsyke, joka liitettyään ehdolliseen ärsykkeeseen lopulta laukaisee ehdollisen vasteen?",
        "answers": [
          { "answer": "Ehdoton ärsyke (UCS)" },
          { "answer": "Ehdollinen ärsyke (CS)" },
          { "answer": "Ehdoton vastaus (UCR)" },
          { "answer": "Ehdollinen vastaus (CR)" }
        ],
        "answer": "Ehdollinen ärsyke (CS)",
        "explanation": "Klassisessa ehdottelussa (joka on tunnettu Ivan Pavlovin koirilla tehdyistä kokeista) ehdollinen ärsyke (CS) on alun perin neutraali ärsyke, joka ei saa aikaan erityistä vastetta. Kuitenkin sen jälkeen, kun se on toistuvasti yhdistetty ehdolliseen ärsykkeeseen (UCS) – joka luonnollisesti ja automaattisesti laukaisee ehdottoman stimuloidun vasteen (UCR). saada aikaan ehdollisen vasteen (CR), joka on samanlainen kuin UCR. Esimerkiksi Pavlovin koirat sylkivät (UCR) ruokaan (UCS)."
      },
      {
        "question": "Minkä tyyppinen oppiminen, joka liittyy B.F. Skinneriin, sisältää käyttäytymisen muuttamisen vahvistamisen (palkitsemisen) ja rangaistuksen avulla?",
        "answers": [
          { "answer": "Classical Conditioning" },
          { "answer": "Havainto-oppiminen" },
          { "answer": "Operant Conditioning" },
          { "answer": "Latentti oppiminen" }
        ],
        "answer": "Operant Conditioning",
        "explanation": "Operantti ehdollistaminen on oppimisen tyyppi, jossa käyttäytymistä ohjaavat sen seuraukset. B. F. Skinnerin suurelta osin kehittämät operantin ehdollistamisen keskeiset käsitteet ovat vahvistaminen ja rankaiseminen. Vahvistaminen (esim. palkkion antaminen) lisää todennäköisyyttä käyttäytymisen toistumisen todennäköisyyteen, kun taas rangaistus vähentää sen todennäköisyyttä. Esimerkiksi, jos he oppivat siivoamaan huoneen tai huoneen lisä (vahvistus) tästä."
      },
      {
        "kysymys": "Abraham Maslow'n tarpeiden hierarkian mukaan mitkä tarpeet muodostavat pyramidin pohjan ja jotka on ensin tyydytettävä ennen kuin voidaan vastata korkeamman tason tarpeisiin?",
        "answers": [
          { "answer": "Kunnituksen tarpeet (esim. kunnioitus, itsetunto)" },
          {
            "answer": "Itsetoteutustarpeet (esim. täyden potentiaalin saavuttaminen)"
          },
          {
            "answer": "Rakkauden ja kuuluvuuden tarpeet (esim. ystävyys, läheisyys)"
          },
          { "answer": "Fysiologiset tarpeet (esim. ilma, ruoka, vesi, suoja)" }
        ],
        "answer": "Fysiologiset tarpeet (esim. ilma, ruoka, vesi, suoja)",
        "explanation": "Maslow'n tarpeiden hierarkia on motivaatioteoria, joka ehdottaa, että ihmisen perustarpeen (motivaattorin) viisi toisistaan ​​riippuvaista tasoa on täytettävä tiukassa järjestyksessä alkaen alimmasta tasosta. Fysiologiset tarpeet ovat aivan pyramidin pohjalla ja sisältävät selviytymisen perustavanlaatuisimmat vaatimukset, kuten ilma, ruoka, vesi, asunto, yksilöllinen perustarpeet on ehdotettava, ennen kuin niihin voidaan lämmittää. tyydyttää korkeamman tason tarpeita, kuten turvallisuutta, rakkautta/kuuluvuutta, arvostusta ja lopuksi itsensä toteuttamista."
      },
      {
        "question": "Mikä on lyhytaikaisen muistijärjestelmän nimi, jonka avulla voimme tilapäisesti säilyttää ja käsitellä tietoja monimutkaisia ​​tehtäviä, kuten päättelyä ja oppimista varten?",
        "answers": [
          { "answer": "Sensorinen muisti" },
          { "answer": "Pitkäaikainen muisti" },
          { "answer": "Työmuisti" },
          { "answer": "Episodinen muisti" }
        ],
        "answer": "Työmuisti",
        "explanation": "Työmuisti on kognitiivinen järjestelmä, jonka kapasiteetti on rajoitettu ja joka on vastuussa tietojen tilapäisestä pitämisestä käytettävissä käsittelyä varten. Se on tärkeää päättelylle, päätöksenteolle ja käyttäytymisen ohjaamiselle. Ajattele sitä "henkisenä työtilana", jossa käsittelet aktiivisesti tietoa. Esimerkiksi kun ratkaiset päässäsi matemaattista ongelmaa tai yrität muistaa työmuistin puhelinnumeroa."
      },
      {
        "kysymys": "Mikä psykologian ala-alue keskittyy siihen, kuinka toisten todellinen, kuviteltu tai implisiittinen läsnäolo vaikuttaa ihmisten ajatuksiin, tunteisiin ja käyttäytymiseen?",
        "answers": [
          { "answer": "Kognitiivinen psykologia" },
          { "answer": "Kehityspsykologia" },
          { "answer": "Klininen psykologia" },
          { "answer": "Sosiaalinen psykologia" }
        ],
        "answer": "Sosiaalinen psykologia",
        "explanation": "Sosiaalipsykologia on tieteellinen tutkimus siitä, kuinka toisten ihmisten todellinen, kuviteltu tai oletettu läsnäolo vaikuttaa yksilöiden ajatuksiin, tunteisiin ja käyttäytymiseen. Se tutkii aiheita, kuten mukautumista, tottelevaisuutta, ennakkoluuloja, vetovoimaa, aggressiota, ryhmäkäyttäytymistä ja sosiaalista havaintoa. Sosiaalipsykologit pyrkivät ymmärtämään maailmaamme toimintaamme ja ymmärrystämme."
      },
      {
        "kysymys": "John B. Watsonin ja Rosalie Raynerin suorittama kuuluisa 'Little Albert' -kokeilu on klassinen esimerkki minkä tyyppisestä oppimisesta?",
        "answers": [
          { "answer": "Operant Conditioning" },
          { "answer": "Havainto-oppiminen" },
          { "answer": "Classical Conditioning" },
          { "answer": "Insight Learning" }
        ],
        "answer": "Classical Conditioning",
        "explanation": "'Pikku Albert' -koe osoitti, että emotionaaliset reaktiot, erityisesti pelko, voivat olla klassisesti ehdollisia ihmisissä. Aluksi Pikku Albert ei osoittanut pelkoa valkoista rottaa kohtaan (neutraali ärsyke). Kuitenkin yhdistämällä toistuvasti rotan esityksen kovaan, pelottavaan ääneen (ehdollinen ärsyke, joka herätti pelkoa), Albert alkoi lopulta pelosta (ehdollinen vaste) yksin (josta oli tullut ehdollinen ärsyke)."
      },
      {
        "kysymys": "Mikä on se psykologinen puolustusmekanismi, jossa yksilö syyttää omia kelpaamattomia ajatuksiaan, tunteitaan tai motiivejaan toiselle henkilölle?",
        "answers": [
          { "answer": "Tukahduttaminen" },
          { "answer": "Kieltäytyminen" },
          { "answer": "Projektio" },
          { "answer": "Sublimaatio" }
        ],
        "answer": "Projisointi",
        "explanation": "Projektio on Sigmund Freudin ehdottama puolustusmekanismi, jossa yksilö alitajuisesti omistaa omat ei-toivotut tai ei-hyväksyttävät ajatuksensa, tunteensa tai impulssinsa jollekin toiselle. Esimerkiksi vihainen henkilö voi syyttää muita vihastaan ​​heille. Tämä auttaa yksilöä välttämään omien epämiellyttävien tunteidensa käsittelyä ulkoistamalla ne."
      },
      {
        "kysymys": "Keskustelua geneettisen perinnön ja ympäristötekijöiden suhteellisista vaikutuksista ihmisen kehitykseen kutsutaan usein nimellä mitä?",
        "answers": [
          { "answer": "Mielen ja kehon ongelma" },
          { "answer": "Luonto vs. hoito" },
          { "answer": "Kognitiivinen dissonanssi" },
          { "answer": "Plaseboefekti" }
        ],
        "answer": "Luonto vs. hoito",
        "explanation": "Luonto vs. hoivata -keskustelu on yksi vanhimmista psykologian kysymyksistä. Se koskee sitä, missä määrin tietyt käyttäytymisen osa-alueet ovat tulosta joko perityistä (eli geneettisistä tai 'luonnollisista') tai hankituista (eli ympäristövaikutusten kautta opituista tai 'kasvatta') ominaispiirteistä. käyttäytymistä sen sijaan, että olisi yksin vastuussa."
      },
      {
        "kysymys": "Mikä ihmisen hermoston osa on vastuussa 'taistele tai pakene' -reaktiosta, joka valmistaa kehon intensiiviseen fyysiseen toimintaan?",
        "answers": [
          { "answer": "Parasympaattinen hermojärjestelmä" },
          { "answer": "Somaattinen hermosto" },
          { "answer": "Keskushermosto" },
          { "answer": "Sympaattinen hermosto" }
        ],
        "answer": "Sympaattinen hermojärjestelmä",
        "explanation": "Sympaattinen hermosto on autonomisen hermoston (joka ohjaa tahattomia kehon toimintoja) jako. Se on vastuussa 'taistele tai pakene' -reaktion aktivoimisesta. Kun ihminen havaitsee uhan, sympaattinen hermosto käynnistää sarjan fysiologisia muutoksia, kuten sykkeen nopeutumista, suunnitellun verenkierron, koko kehon verenkiertoa, joko valmistelemaan koko kehon tai pupillien virtausta. kohdata vaara tai paeta sitä."
      }
    ]
  },
  {
    "name": "Maailman historia (Perustiedot)",
    "image": "https://images.unsplash.com/photo-1569065389101-f855a0b2b4ca",
    "questions": [
      {
        "kysymys": "Mitä muinaista sivilisaatiota, joka sijaitsee Tigris- ja Eufrat-jokien välissä, kutsutaan usein 'sivilisaation kehdoksi' ja sen tunnustetaan kirjoittamisen (nuolenkirjoituksen) keksijäksi?",
        "answers": [
          { "answer": "Muinainen Egypti" },
          { "answer": "Muinainen Kreikka" },
          { "answer": "Mesopotamia" },
          { "answer": "Indus Valleyn sivilisaatio" }
        ],
        "answer": "Mesopotamia",
        "explanation": "Mesopotamia, joka tarkoittaa 'jokien välistä maata', oli muinainen alue, joka sijaitsee itäisellä Välimerellä ja vastasi nykyistä Irakia, Kuwaitia ja osia Syyriasta ja Turkista. Sitä kutsutaan usein sivilisaation kehtoksi, koska siellä syntyivät ensimmäisen kerran monimutkaiset kaupunkikeskukset. 3200 eaa."
      },
      {
        "kysymys": "Kuka oli ensimmäinen Rooman keisari, joka merkitsi Rooman tasavallan loppua ja Rooman valtakunnan alkua?",
        "answers": [
          { "answer": "Julius Caesar" },
          { "answer": "Augustus (Octavianus)" },
          { "answer": "Nero" },
          { "answer": "Konstantinus Suuri" }
        ],
        "answer": "Augustus (Octavianus)",
        "explanation": "Augustus, joka tunnettiin alun perin nimellä Octavianus, oli ensimmäinen Rooman keisari. Hän tuli valtaan sisällissotien jakson jälkeen, jotka johtivat Rooman tasavallan romahtamiseen. Vaikka Julius Caesarilla oli valtava valta ja se lopetti tasavallan, hän ei koskaan ollut virallisesti keisari; hänen salamurhansa edelsi valtakunnan muodollista perustamista (Augustus'247 jKr.) aloitti pitkän suhteellisen rauhan ajanjakson, joka tunnetaan nimellä Pax Romana."
      },
      {
        "kysymys": "Mille Länsi-Rooman valtakunnan kaatumisen jälkeiselle suurelle historialliselle ajanjaksolle on ominaista feodalismi, linnat ja ritarit Euroopassa?",
        "answers": [
          { "answer": "Renessanssi" },
          { "answer": "Valaistumisen aika" },
          { "answer": "Keskiaika (keskiaika)" },
          { "answer": "Teollinen vallankumous" }
        ],
        "answer": "Keskiaika (keskiaika)",
        "explanation": "Keskiaika eli keskiaika ulottuu Euroopan historiassa perinteisesti Länsi-Rooman valtakunnan kaatumisesta 500-luvulla jKr. renessanssin alkuun 1300- tai 1400-luvulla. Tälle aikakaudelle oli ominaista feodalismijärjestelmä (maanomistukseen ja -uskollisuuteen perustuva sosiaalinen ja poliittinen järjestelmä), kristittyjen linnan ja kirkon vahvuus ja uskollisuus."
      },
      {
        "kysymys": "Mitä italialaista kaupunkia pidetään usein renessanssin synnyinpaikkana, suuren kulttuurisen muutoksen ja taiteellisen kehityksen ajanjaksona Euroopassa?",
        "answers": [
          { "answer": "Rooma" },
          { "answer": "Venetsia" },
          { "answer": "Firenze" },
          { "answer": "Milano" }
        ],
        "answer": "Firenze",
        "explanation": "Firenze, Italia, pidetään laajalti renessanssin syntymäpaikkana. 1300-1500-luvuilla Firenze oli eloisa taiteen, arkkitehtuurin, kirjallisuuden ja filosofian keskus, jossa asuivat vaikutusvaltaiset henkilöt, kuten Leonardo da Vinci, Michelangelo, Botticelli ja Machiavellien kaltaiset Medichant-kulttuuriperheet. kukoistaa."
      },
      {
        "kysymys": "Minkä vankilan myrskyä 14. heinäkuuta 1789 pidetään keskeisenä tapahtumana Ranskan vallankumouksen alussa?",
        "answers": [
          { "answer": "The Tower of London" },
          { "answer": "Bastille" },
          { "answer": "Alcatraz" },
          { "answer": "Château d'If" }
        ],
        "answer": "Bastille",
        "explanation": "Pariisilaisen keskiaikaisen linnoituksen ja vankilan Bastillen hyökkäys 14. heinäkuuta 1789 oli symbolinen ja merkittävä tapahtuma Ranskan vallankumouksen alkuvaiheessa. Vaikka siinä oli tuolloin vain muutamia vankeja, Bastille edusti kuninkaallista auktoriteettia ja tyranniaa. Sen kaatuminen osoitti heinäkuun vallankumouksellisen väkijoukon käännekohtaa. 14. päivää vietetään nyt Bastille-päivänä, Ranskan kansallisena juhlapäivänä."
      },
      {
        "kysymys": "Kenen ansioksi luetaan liikkuva kirjasinpainokoneen keksiminen Euroopassa vuonna 1440, mikä mullisti tiedon leviämisen?",
        "answers": [
          { "answer": "Leonardo da Vinci" },
          { "answer": "Galileo Galilei" },
          { "answer": "Johannes Gutenberg" },
          { "answer": "Isaac Newton" }
        ],
        "answer": "Johannes Gutenberg",
        "explanation": "Johannes Gutenberg, saksalainen seppä, kultaseppä, kirjapaino ja kustantaja, tunnustetaan liikkuvalla kirjasinkoneella varustetun painokoneen keksimisestä Euroopassa noin vuonna 1440. Tämä keksintö oli merkittävä käännekohta historiassa, koska se mahdollisti kirjojen ja muiden tekstien massatuotannon, mikä teki tiedon paljon helpommin saataville ja vaikutti merkittävästi Renessanssiin, vallankaappaukseen, uudistukseen."
      },
      {
        "kysymys": "Minä vuonna hyväksyttiin Yhdysvaltojen itsenäisyysjulistus, jonka pääasiallisesti on kirjoittanut Thomas Jefferson?",
        "answers": [
          { "answer": "1765" },
          { "answer": "1776" },
          { "answer": "1783" },
          { "answer": "1789" }
        ],
        "answer": "1776",
        "explanation": "Yhdysvaltain itsenäisyysjulistus hyväksyttiin toisessa mannertenvälisessä kongressissa 4. heinäkuuta 1776. Tämä historiallinen asiakirja, jonka pääosin oli laatinut Thomas Jefferson, ilmoitti, että kolmetoista Amerikan siirtomaa pitivät itseään kolmetoista itsenäisenä suvereenina valtiona, jotka eivät enää ole Britannian vallan alaisia. ero Iso-Britanniasta."
      },
      {
        "kysymys": "Mikä globaali konflikti, joka kesti vuosina 1914-1918, tunnettiin myös 'suurena sodana'?",
        "answers": [
          { "answer": "Napoleonin sodat" },
          { "answer": "Kylmä sota" },
          { "answer": "I maailmansota" },
          { "answer": "Toinen maailmansota" }
        ],
        "answer": "Ensimmäinen maailmansota",
        "explanation": "Ensimmäinen maailmansota, joka tunnetaan myös nimellä Suuri sota, oli maailmanlaajuinen konflikti, joka sai alkunsa Euroopasta ja kesti 28. heinäkuuta 1914 11. marraskuuta 1918. Siihen osallistui suurin osa maailman suurvalloista, jotka kokoontuivat kahteen vastakkaiseen liittoutumaan: liittolaiset (perustuu kolmivaltaiseen valtakuntaan, Ranskaan ja Venäjään, Triplesoriin) Saksan, Itävalta-Unkarin ja Italian liitto)."
      },
      {
        "kysymys": "Yhdysvaltojen ja Neuvostoliiton ja niiden liittolaisten välinen geopoliittisen jännitteen aika, joka alkoi toisen maailmansodan jälkeen, tunnetaan nimellä mikä?",
        "answers": [
          { "answer": "The Roaring Twenties" },
          { "answer": "Suuri lama" },
          { "answer": "Kylmä sota" },
          { "answer": "Avaruuskilpailu" }
        ],
        "answer": "Kylmä sota",
        "explanation": "Kylmä sota oli geopoliittisten jännitteiden aikaa Neuvostoliiton ja Yhdysvaltojen sekä niiden liittolaisten, itäblokin ja länsiblokin välillä. Tämän ajanjakson katsotaan yleensä ulottuvan toisen maailmansodan lopusta vuonna 1945 Neuvostoliiton hajoamiseen vuonna 1991. Sitä kutsuttiin "kylmäksi", koska kahden suurvallan välistä suoraa taistelua ei ollut. sodat, kilpavarustelu (etenkin ydinase) ja ideologinen, poliittinen ja taloudellinen kilpailu."
      },
      {
        "kysymys": "Kuka oli kansalaisoikeusliikkeen pääjohtaja Yhdysvalloissa 1950- ja 1960-luvuilla, joka tunnettiin väkivallattoman protestin puolestapuhumisesta?",
        "answers": [
          { "answer": "Malcolm X" },
          { "answer": "Martin Luther King Jr." },
          { "answer": "Rosa Parks" },
          { "answer": "Thurgood Marshall" }
        ],
        "answer": "Martin Luther King Jr.",
        "explanation": "Dr. Martin Luther King Jr. oli yhdysvaltalainen baptistiministeri ja -aktivisti, josta tuli kansalaisoikeusliikkeen näkyvin tiedottaja ja johtaja vuodesta 1955 salamurhaansa vuonna 1968. Hänet tunnetaan parhaiten kansalaisoikeuksien edistämisestä väkivallattomuuden ja kansalaistottelemattomuuden avulla, jonka innoittamana hänen kristinuskon väkivallattomuus ja väkivallattomuus. Hänen johtajuutensa oli perustavanlaatuinen liikkeen menestykselle afrikkalaisten amerikkalaisten laillisen erottelun lopettamisessa Yhdysvaltojen eteläosissa ja muissa osissa."
      }
    ]
  },
  {
    "name": "Kemia (Perusasiat)",
    "image": "https://images.unsplash.com/photo-1554475901-4538953918c7",
    "questions": [
      {
        "question": "Mitkä ovat kolme perushiukkasta, jotka muodostavat atomin?",
        "answers": [
          { "answer": "Protonit, neutriinot, elektronit" },
          { "answer": "Protonit, neutronit, elektronit" },
          { "answer": "Positronit, neutronit, elektronit" },
          { "answer": "Fotonit, neutronit, kvarkit" }
        ],
        "answer": "Protonit, neutronit, elektronit",
        "explanation": "Atomit, aineen perusrakennuspalikoita, koostuvat kolmesta pääasiallisesta subatomisesta hiukkasesta:\n1. **Protonit:** Positiivisesti varautuneet hiukkaset, joita löytyy atomin ytimestä.\n2. **Neutronit:** Neutraaleja hiukkasia (ei varausta) löytyy myös ytimestä.\n3:** Negaktivisesti varautuneita hiukkasia. ydin elektronikuorissa tai pilvissä.\nProtonien määrä määrittää elementin atomiluvun ja sen identiteetin."
      },
      {
        "question": "Mitä elementin atominumero edustaa?",
        "answers": [
          { "answer": "Atomissa olevien neutronien lukumäärä." },
          { "answer": "Protonien ja neutronien kokonaismäärä atomissa." },
          { "answer": "Atomin uloimmassa kuoressa olevien elektronien lukumäärä." },
          { "answer": "Protonien lukumäärä atomin ytimessä." }
        ],
        "answer": "Protonien lukumäärä atomin ytimessä.",
        "explanation": "Kemiallisen alkuaineen atominumero (yleensä merkitty symbolilla Z) on protonien lukumäärä, joka löytyy kyseisen alkuaineen jokaisen atomin ytimestä. Yminumero yksilöi kemiallisen alkuaineen. Neutraalissa atomissa atomiluku on myös yhtä suuri kuin elektronien lukumäärä."
      },
      {
        "kysymys": "Minkätyyppinen kemiallinen sidos sisältää elektroniparien jakamisen atomien välillä?",
        "answers": [
          { "answer": "Ionic Bond" },
          { "answer": "Kovalenttinen sidos" },
          { "answer": "Metallic Bond" },
          { "answer": "Vesisidos" }
        ],
        "answer": "kovalenttinen sidos",
        "explanation": "Kovalenttinen sidos on kemiallinen sidos, joka sisältää elektroniparien jakamisen atomien välillä. Nämä jaetut elektroniparit tunnetaan jaetuina pareina tai sidospareina, ja atomien välisten houkuttelevien ja hylkivien voimien vakaa tasapaino, kun ne jakavat elektroneja, tunnetaan kovalenttisena sidoksena. Tämän tyyppistä atomia esiintyy esimerkiksi vedessä. molekyyli ($H_2O$), happi jakaa elektroneja kahden vetyatomin kanssa."
      },
      {
        "question": "Mikä on veden kemiallinen symboli?",
        "answers": [
          { "answer": "CO₂" },
          { "answer": "O₂" },
          { "answer": "H₂O" },
          { "answer": "NaCl" }
        ],
        "answer": "H₂O",
        "explanation": "Veden kemiallinen symboli on $H_2O$. Tämä osoittaa, että yksi vesimolekyyli koostuu kahdesta vetyatomista (H) ja yhdestä happiatomista (O). Vesi on elintärkeä aine kaikille tunnetuille elämänmuodoille."
      },
      {
        "kysymys": "Missä aineen tilassa hiukkaset ovat pakattu tiukasti yhteen kiinteässä järjestelyssä, usein kiteisessä hilassa, ja värähtelevät paikallaan?",
        "answers": [
          { "answer": "Nestemäinen" },
          { "answer": "Kaasu" },
          { "answer": "Plasma" },
          { "answer": "Kiinteä" }
        ],
        "answer": "Kiinteä",
        "explanation": "Kiinteässä tilassa hiukkaset (atomit, molekyylit tai ionit) pakautuvat tiiviisti yhteen ja pidetään kiinteissä asennoissa, usein säännöllisessä geometrisessa kuviossa, joka tunnetaan kiteisenä hilana. Vaikka ne eivät voi liikkua vapaasti toistensa ohi, kiinteässä tilassa olevat hiukkaset värähtelevät kiinteissä paikoissaan. Kiinteillä aineilla on tietty muoto ja tilavuus."
      },
      {
        "question": "Mitä kutsutaan kemiallisen reaktion alkaessa läsnä oleville aineille?",
        "answers": [
          { "answer": "Tuotteet" },
          { "answer": "Catalysts" },
          { "answer": "Reagenssit" },
          { "answer": "Liuottimet" }
        ],
        "answer": "Reagenssit",
        "explanation": "Kemiallisessa reaktiossa lähtöaineita kutsutaan reagensseiksi (tai reagensseiksi). Nämä ovat aineita, jotka muuttuvat kemiallisesti uusiksi aineiksi. Kemiallisen reaktion tuloksena muodostuneita uusia aineita kutsutaan tuotteiksi. Esimerkiksi reaktiossa $2H_2 + O_2 \\rightarrow 2H_2O$, vety ($H_2_2) ja vesi ovat reaktioaineet ($H_2_$) ja vesi. ($H_2O$) on tuote."
      },
      {
        "question": "Mitä pH-arvo 7 kertoo liuoksesta?",
        "answers": [
          { "answer": "Se on voimakkaasti hapan." },
          { "answer": "Se on vahvasti emäksinen (emäksinen)." },
          { "answer": "Se on neutraali." },
          { "answer": "Se on tiivistetty liuos." }
        ],
        "answer": "Se on neutraali.",
        "explanation": "PH-asteikko mittaa, kuinka hapan tai emäksinen (emäksinen) aine on. Asteikko vaihtelee tyypillisesti välillä 0-14.\n- pH **7 on neutraali**. Puhtaan veden pH on 7.\n- pH **alle 7** tarkoittaa happamuutta (esim. sitruunamehu, etikka).** emäksisyys on 7 tai emäksisyys. (esim. saippua, valkaisuaine)."
      },
      {
        "question": "Mikä seuraavista on esimerkki kemiallisesta yhdisteestä?",
        "answers": [
          { "answer": "Happi (O₂)" },
          { "answer": "Kulta (Au)" },
          { "answer": "Suola (NaCl)" },
          { "answer": "Ilma" }
        ],
        "answer": "Suola (NaCl)",
        "explanation": "Kemiallinen yhdiste on aine, joka muodostuu, kun kaksi tai useampi eri kemiallinen alkuaine on sitoutunut kemiallisesti yhteen. \n- **Suola (NaCl)** eli natriumkloridi on yhdiste, joka on valmistettu ionisesti sitoutuneista natrium- (Na)- ja kloori- (Cl)-atomeista.\n- **Happi (O₂)-mooli on sama alkuaine (O₂)**n. **Kulta (Au)** on alkuaine.\n- **Ilma** on sekoitus erilaisia ​​kaasuja (kuten typpeä, happea, argonia jne.)."
      },
      {
        "kysymys": "Mikä on elektronien ensisijainen rooli atomin uloimmassa kuoressa (valenssikuoressa)?",
        "answers": [
          { "answer": "Atomin massaluvun määrittäminen." },
          { "answer": "Osallistua kemialliseen sitoutumiseen muiden atomien kanssa." },
          {
            "answer": "Pidä protonit ja neutronit yhdessä ytimessä."
          },
          { "answer": "Kaiken saapuvan säteilyn absorboimiseksi." }
        ],
        "answer": "Osallistua kemialliseen sitoutumiseen muiden atomien kanssa.",
        "explanation": "Atomin uloimmassa kuoressa olevia elektroneja kutsutaan valenssielektroneiksi. Nämä elektronit ovat tärkeitä, koska ne ovat ensisijaisesti mukana kemiallisessa sidoksessa. Atomilla on taipumus saada, menettää tai jakaa valenssielektroneja saavuttaakseen vakaamman elektronikonfiguraation, joka yleensä muistuttaa jalokaasun elektronikonfiguraatiota. Valenssielektronien suuri määrä määrää sen kemiallisten ominaisuuksien ja muiden ominaisuuksien suhteen. atomeja."
      },
      {
        "question": "Mitä kutsutaan ainetta, joka liukenee liuottimeen muodostaen liuoksen?",
        "answers": [
          { "answer": "Saosta" },
          { "answer": "Keskeytys" },
          { "answer": "Solute" },
          { "answer": "Emulsio" }
        ],
        "answer": "Solute",
        "explanation": "Liuoksessa on tyypillisesti kaksi pääkomponenttia:\n- **Liuotin:** Aine, joka liukenee, yleensä suurina määrinä (esim. vesi suolavedessä).\n- **Liuos:** Aine, joka liukenee liuottimeen (esim. suola suolaveteen).\nKun liukeneva aine, jota kutsutaan homogeeniseksi seokseksi, liukenee seokseksi."
      }
    ]
  },
  {
    "name": "Fysiikka (Perusteet)",
    "image": "https://images.unsplash.com/photo-1532187640901-595769011974",
    "questions": [
      {
        "question": "Millä nimellä kutsutaan kohteen taipumusta vastustaa muutoksia liiketilassaan?",
        "answers": [
          { "answer": "Kiihtyvyys" },
          { "answer": "Nopeus" },
          { "answer": "Inertia" },
          { "answer": "Pakota" }
        ],
        "answer": "Inertia",
        "explanation": "Inertia on minkä tahansa fyysisen esineen vastus mihin tahansa muutoksiin sen liiketilassa; tämä sisältää muutokset sen nopeudessa, suunnassa tai lepotilassa. Se on aineen perusominaisuus. Jos esimerkiksi olet autossa, joka pysähtyy äkillisesti, kehosi jatkaa liikkumista eteenpäin hitauden vuoksi. Tämä kuvataan myös Newtonin ensimmäisessä liikkeessä."
      },
      {
        "kysymys": "Mikä Newtonin liikelaeista sanotaan usein seuraavasti: Jokaiselle toiminnalle on yhtäläinen ja vastakkainen reaktio?",
        "answers": [
          { "answer": "Newtonin ensimmäinen laki" },
          { "answer": "Newtonin toinen laki" },
          { "answer": "Newtonin kolmas laki" },
          { "answer": "Newtonin yleisen painovoiman laki" }
        ],
        "answer": "Newtonin kolmas laki",
        "explanation": "Newtonin kolmas liikelaki sanoo, että kun yksi kappale kohdistaa voiman toiseen kappaleeseen, toinen kappale kohdistaa samanaikaisesti voiman, joka on yhtä suuri ja vastakkainen ensimmäiseen kappaleeseen. Joten jokaiselle toiminnalle (voimalle) on yhtä suuri ja vastakkainen reaktio (voima). Esimerkiksi kun hyppäät, jalkasi kohdistavat voiman maahan yhtä suurella jalallasi ja päinvastainen voima. ilmaa."
      },
      {
        "question": "Mikä on voiman mittayksikkö kansainvälisessä yksikköjärjestelmässä (SI)?",
        "answers": [
          { "answer": "Joule (J)" },
          { "answer": "W (W)" },
          { "answer": "Newton (N)" },
          { "answer": "Pascal (Pa)" }
        ],
        "answer": "Newton (N)",
        "explanation": "Sivuvoiman SI-yksikkö on **Newton**, lyhennettynä **N**. Yksi Newton määritellään voimaksi, joka tarvitaan kiihdyttämään yhden kilogramman massa metrillä sekunnissa ($1 \\teksti{ N} = 1 \\teksti{ kg} \\cdot \\teksti\teksti\teksti${m/s}-^2 energian yksikkönä). Watti (W) on tehon yksikkö.\n- Pascal (Pa) on paineen yksikkö."
      },
      {
        "kysymys": "Millaista energiaa esineellä on liikkeensä vuoksi?",
        "answers": [
          { "answer": "Potentiaalinen energia" },
          { "answer": "Kinetic Energy" },
          { "answer": "Chemical Energy" },
          { "answer": "Lämpöenergia" }
        ],
        "answer": "Kineettinen energia",
        "explanation": "Kineettinen energia on energiaa, jonka esine omaa liikkeensä vuoksi. Jos esine liikkuu, sillä on kineettistä energiaa. Kineettisen energian määrä riippuu kohteen massasta ja nopeudesta. Kineettisen energian kaava on $KE = \\frac{1}{2}mv^2$, missä $m$ on massa (**spe$ed on nopeus) ja $v$ed on \nential isot). energiaa, joka johtuu usein sijainnista (esim. gravitaatiopotentiaalienergia) tai tilasta (esim. elastinen potentiaalienergia)."
      },
      {
        "question": "Mikä seuraavista on yleinen esimerkki vivusta?",
        "answers": [
          { "answer": "Pyörän pyörä" },
          { "answer": "ramppi" },
          { "answer": "Keinulauta" },
          { "answer": "Ruuvi" }
        ],
        "answer": "Keinu",
        "explanation": "Vipu on yksinkertainen kone, joka koostuu jäykästä tangosta, joka kiertyy kiinteän pisteen, jota kutsutaan tukipisteeksi, ympäri. Sitä käytetään kuormien nostamiseen tai siirtämiseen pienemmällä vaivalla.\n**Kiikkuva** on klassinen esimerkki ensimmäisen luokan vivusta, jossa tukipiste on voiman (yhden henkilön kohdistama voima) ja kuorman välillä.\n-c-taso on ruuvi. on kalteva taso, joka on kiedottu sylinterin ympärille.\n- Polkupyörän pyörä on pyörä ja akseli."
      },
      {
        "kysymys": "Millä prosessilla lämpö siirtyy suorassa kosketuksessa ainehiukkasten välillä?",
        "answers": [
          { "answer": "Konvektio" },
          { "answer": "Säteily" },
          { "answer": "Johto" },
          { "answer": "Haihtuminen" }
        ],
        "answer": "Johto",
        "explanation": "Johtuminen on lämpöenergian siirtoa suoran kosketuksen kautta hiukkasten välillä. Kun materiaalin yhtä osaa kuumennetaan, sen hiukkaset saavat energiaa ja värähtelevät voimakkaammin. Sitten nämä hiukkaset törmäävät lähellä oleviin hiukkasiin siirtäen osan energiastaan. Tämä prosessi jatkuu siirtäen lämpöä materiaalin läpi. Esimerkiksi kuumaa pannua koskettaessa lämpö johdetaan yleensä hyvään pannuun. Metallit johtavat lämpöä käteen."
      },
      {
        "question": "Mikä aallon ominaisuus määritellään kahden peräkkäisen saman vaiheen vastaavan pisteen, kuten kahden harjan tai kahden kourun väliseksi etäisyydeksi?",
        "answers": [
          { "answer": "Taajuus" },
          { "answer": "Amplitudi" },
          { "answer": "Aallonpituus" },
          { "answer": "Jakso" }
        ],
        "answer": "Aallonpituus",
        "explanation": "Aallon aallonpituus (esitetään usein kreikkalaisella kirjaimella lambda, $\\lambda$) on aallon spatiaalinen jakso - etäisyys, jonka yli aallon muoto toistuu. Se on etäisyys aallon saman vaiheen peräkkäisten vastaavien pisteiden välillä, kuten kahden vierekkäisen harjan (huippujen), aallonpoikien tai -suuntien (sama laakson) välinen etäisyys. **Amplitudi** on suurin siirtymä tai etäisyys, jonka värähtelevän kappaleen tai aallon piste siirtää sen tasapainoasennosta.\n- **Taajuus** on pisteen läpi kulkevien harjojen (tai kourujen) määrä aikayksikköä kohden.\n- **Jakso** on aika, joka kuluu yhdeltä aallon kokonaiskierrokselta pisteen ohittamiseen."
      },
      {
        "question": "Mitä tapahtuu, kun valkoinen valo kulkee prisman läpi?",
        "answers": [
          { "answer": "Se tulee kirkkaammaksi." },
          { "answer": "Se imeytyy täysin." },
          { "answer": "Se heijastuu takaisin valkoisena valona." },
          { "answer": "Se jakautuu komponenttiväreihinsä (spektri)." }
        ],
        "answer": "Se jakautuu komponenttiväreihinsä (spektri).",
        "explanation": "Kun valkoinen valo kulkee prisman läpi, siinä tapahtuu **dispersio**. Valkoinen valo on itse asiassa sekoitus valon eri värejä (sateenkaaren värit: punainen, oranssi, keltainen, vihreä, sininen, indigo, violetti). Jokaisella värillä on hieman erilainen aallonpituus. Koska prisman materiaalin taitekerroin vaihtelee hieman valon värin (aallonpituuden mukaan) mukaan. Violettia valoa taipuu eniten ja punaista valoa vähiten."
      },
      {
        "question": "Minkä tyyppistä sähkövarausta elektronit kuljettavat?",
        "answers": [
          { "answer": "Positiivinen lataus" },
          { "answer": "Negatiivinen varaus" },
          { "answer": "Neutraali varaus" },
          { "answer": "Ei maksua" }
        ],
        "answer": "Negatiivinen varaus",
        "explanation": "Elektronit ovat subatomisia hiukkasia, jotka kiertävät atomin ydintä. Niissä on perustavanlaatuinen **negatiivinen** sähkövaraus. Ytimessä olevilla protoneilla on positiivinen varaus, ja neutroneilla (myös ytimessä) ei ole varausta (ne ovat neutraaleja). Elektronien virtaus muodostaa sähkövirran monissa materiaaleissa."
      },
      {
        "kysymys": "Ohmin lain mukaan, jos nostat jännitettä yksinkertaisessa piirissä pitäen samalla vastus vakiona, mitä tapahtuu virralle?",
        "answers": [
          { "answer": "Virta laskee." },
          { "answer": "Virta pysyy samana." },
          { "answer": "Virta kasvaa." },
          { "answer": "Virrasta tulee nolla." }
        ],
        "answer": "Virta kasvaa.",
        "explanation": "Omin lain mukaan virta ($I$), joka kulkee johtimen läpi kahden pisteen välillä, on suoraan verrannollinen jännitteeseen ($V$) kahden pisteen välillä ja kääntäen verrannollinen niiden väliseen resistanssiin ($R$). Kaava on $V = IR$ tai $I = \\frac{V}{R}$, ja jännite pidetään vakiona ($nIf) on resistanssi $ ($nIf) kasvanut, niin $I = \\frac{V}{R}$ mukaan virran ($I$) on myös **lisättävä**, jotta yhteys säilyy. Jännite on kuin 'työntö', joka saa virran kulkemaan, joten enemmän työntöä (jännite) saa aikaan enemmän virtaa (virtaa), jos oppositio (resistanssi) ei muutu."
      }
    ]
  },
  {
    "name": "Biologia (Perusasiat)",
    "image": "https://images.unsplash.com/photo-1532187863486-abf9db50b6aa",
    "questions": [
      {
        "kysymys": "Mitä kutsutaan usein 'solun voimalaitokseksi', koska se tuottaa suurimman osan solun adenosiinitrifosfaatista (ATP), jota käytetään kemiallisen energian lähteenä?",
        "answers": [
          { "answer": "Ydin" },
          { "answer": "Ribosomi" },
          { "answer": "Mitokondrio" },
          { "answer": "Endoplasminen verkkokalvo" }
        ],
        "answer": "Mitokondrio",
        "explanation": "Mitokondriot (yksikkö: mitokondrio) ovat kalvoon sitoutuneita soluorganelleja, jotka tuottavat suurimman osan solun biokemiallisten reaktioiden käynnistämiseen tarvittavasta kemiallisesta energiasta. Tämä kemiallinen energia varastoituu pieneen molekyyliin, jota kutsutaan adenosiinitrifosfaatiksi (ATP). Tästä syystä mitokondrioita kutsutaan usein 'voimalaitoksiksi' solun kautta."
      },
      {
        "kysymys": "Millä prosessilla vihreät kasvit ja jotkut muut organismit käyttävät auringonvaloa elintarvikkeiden syntetisoimiseen klorofyllipigmentin avulla?",
        "answers": [
          { "answer": "Hengitys" },
          { "answer": "Photosynteesi" },
          { "answer": "Kermentointi" },
          { "answer": "Transpiraatio" }
        ],
        "answer": "Valosynteesi",
        "explanation": "Fotosynteesi on prosessi, jota kasvit, levät ja tietyt bakteerit käyttävät muuntaakseen valoenergiaa kemialliseksi energiaksi prosessissa, jossa käytetään auringonvaloa, vettä ja hiilidioksidia. Tärkeimmät ainesosat ovat auringonvalo (energianlähteenä), vesi (imeytyy juurien kautta), hiilidioksidi (ilmasta otettu) ja klorofylli (vihreä energiapigmentti, jota käytetään pääasiallisissa energiapigmenteissä). energia ja rakennusmateriaali) ja happi (vapautettu ilmakehään)."
      },
      {
        "kysymys": "Missä molekyylissä on kaikkien tunnettujen elävien organismien ja monien virusten kasvussa, kehityksessä, toiminnassa ja lisääntymisessä käytetyt geneettiset ohjeet?",
        "answers": [
          { "answer": "RNA (ribonukleiinihappo)" },
          { "answer": "ATP (adenosiinitrifosfaatti)" },
          { "answer": "Proteiini" },
          { "answer": "DNA (deoksiribonukleiinihappo)" }
        ],
        "answer": "DNA (deoksiribonukleiinihappo)",
        "explanation": "DNA eli deoksiribonukleiinihappo on ihmisten ja melkein kaikkien muiden organismien perinnöllinen materiaali. Se sisältää biologiset ohjeet, jotka tekevät jokaisesta lajista ainutlaatuisen. DNA koostuu kahdesta pitkästä säikeestä, jotka kiertyvät toistensa ympärille muodostaen kaksoiskierteen. Nämä ohjeet välitetään aikuisilta organismeilta niiden jälkeläisille lisääntymisen aikana."
      },
      {
        "kysymys": "Mikä on perinnöllisyyden perusyksikkö, joka siirtyy vanhemmilta jälkeläisille ja jonka katsotaan määrittävän jonkin jälkeläisen ominaisuuden?",
        "answers": [
          { "answer": "kromosomi" },
          { "answer": "Geeni" },
          { "answer": "Allele" },
          { "answer": "Gamete" }
        ],
        "answer": "Geeni",
        "explanation": "Geeni on perinnöllisyyden fyysinen ja toiminnallinen perusyksikkö. Geenit koostuvat DNA:sta ja toimivat ohjeina proteiinien muodostamiseen. Ihmisillä geenien koko vaihtelee muutamasta sadasta DNA-emäksestä yli 2 miljoonaan emäkseen. Jokaisella ihmisellä on kaksi kopiota jokaisesta geenistä, yksi jokaiselta vanhemmalta."
      },
      {
        "question": "Mikä näistä on oikea järjestys tyypillisessä ravintoketjussa?",
        "answers": [
          { "answer": "Kuluttaja → Tuottaja → Hajottaja" },
          { "answer": "Tuottaja → Hajottaja → Kuluttaja" },
          { "answer": "Hajottaja → Kuluttaja → Tuottaja" },
          { "answer": "Tuottaja → Kuluttaja → Hajottaja" }
        ],
        "answer": "Tuottaja → Kuluttaja → Hajottaja",
        "explanation": "Ruokaketju näyttää, kuinka energia siirtyy elävästä organismista toiseen ruokinnan kautta.\n1. **Tuottajat:** Nämä ovat tyypillisesti kasveja tai leviä, jotka tuottavat omaa ravintoa auringonvalon avulla (fotosynteesi). Ne muodostavat ravintoketjun perustan.\n2. **Kuluttajat:** Nämä ovat organismeja, jotka syövät muita organismeja (tuottaja. tai kaikkiruokaiset) syövät ensisijaisia ​​kuluttajia ja niin edelleen.\n3 **Hajottajat:** Nämä ovat organismeja, kuten bakteereita ja sieniä, jotka hajottavat kuolleita orgaanisia aineita (kuolleita kasveja ja eläimiä) ja palauttavat ravinteita maaperään, joita tuottajat voivat sitten käyttää ravinteiden kiertoon."
      },
      {
        "kysymys": "Mikä järjestelmä ihmiskehossa on ensisijaisesti vastuussa ruuan hajottamisesta pienemmiksi molekyyleiksi, jotka voidaan imeytyä ja käyttää energiaan ja ravintoaineisiin?",
        "answers": [
          { "answer": "Verenkiertojärjestelmä" },
          { "answer": "Hengitysjärjestelmä" },
          { "answer": "Ruoansulatusjärjestelmä" },
          { "answer": "Hermosto" }
        ],
        "answer": "Ruoansulatusjärjestelmä",
        "explanation": "Ruoansulatusjärjestelmä on ryhmä elimiä, jotka toimivat yhdessä muuntaakseen ruokaa energiaksi ja perusravintoaineiksi koko kehon ruokkimiseksi. Se sisältää suun, ruokatorven, mahalaukun, ohutsuolen, paksusuolen, peräsuolen ja peräaukon sekä apuelimet, kuten maksan, haima ja sappirakko. Ruoka hajotetaan pienemmiksi entsyymeiksi mekaanisesti (esim. pureskelemalla) ja kemiallisesti. komponentit, jotka voivat imeytyä verenkiertoon."
      },
      {
        "kysymys": "Mitä kaasua kasvit ensisijaisesti ottavat ilmakehästä fotosynteesiin?",
        "answers": [
          { "answer": "Happi" },
          { "answer": "Typpi" },
          { "answer": "Hiilidioksidi" },
          { "answer": "Vedy" }
        ],
        "answer": "Hiilidioksidi",
        "explanation": "Fotosynteesin aikana kasvit imevät hiilidioksidia ($CO_2$) ilmakehästä lehtiensä pienten huokosten kautta, joita kutsutaan stomataiksi. Tätä hiilidioksidia sekä veden (juuret imeytyvät) ja valoenergian (klorofyllin vangitsemaa) kanssa tuotetaan glukoosia (sokeria) ja happea. Sitten happi vapautuu takaisin ilmakehään."
      },
      {
        "kysymys": "Mikä kasvisolun osa on ensisijaisesti vastuussa fotosynteesistä?",
        "answers": [
          { "answer": "Mitokondriot" },
          { "answer": "Ydin" },
          { "answer": "Cell Wall" },
          { "answer": "Kloroplasti" }
        ],
        "answer": "Kloroplasti",
        "explanation": "Kloroplastit ovat kasvisoluissa ja eukaryoottisissa levissä olevia organelleja, jotka suorittavat fotosynteesiä. Ne vangitsevat valoenergiaa auringosta ja muuntaa sen kemialliseksi energiaksi, joka on varastoitunut molekyyleihin, kuten ATP ja NADPH, joita sitten käytetään orgaanisten molekyylien valmistamiseen hiilidioksidista prosessissa, jota kutsutaan Calvin-sykliksi. Klorofyllit sisältävät vihreää valoa."
      },
      {
        "kysymys": "Millä prosessilla ympäristöönsä paremmin sopeutuneilla eliöillä on taipumus selviytyä ja tuottaa enemmän jälkeläisiä, mikä johtaa lajien muutoksiin ajan myötä?",
        "answers": [
          { "answer": "Genetic Drift" },
          { "answer": "Mutaatio" },
          { "answer": "Luonnollinen valinta" },
          { "answer": "Keinotekoinen valinta" }
        ],
        "answer": "Luonnollinen valinta",
        "explanation": "Luonnollinen valinta on Charles Darwinin ehdottama evoluution ydinmekanismi. Se on prosessi, jossa ympäristöönsä paremmin sopeutuneilla eliöillä on taipumus selviytyä ja tuottaa enemmän jälkeläisiä. Niiden edulliset ominaisuudet siirtyvät sitten seuraavalle sukupolvelle. Pitkällä aikavälillä tämä voi johtaa merkittäviin muutoksiin lajin ominaisuuksissa ja uusien lajien syntymiseen."
      },
      {
        "question": "Mikä seuraavista kuvaa parhaiten ekosysteemiä?",
        "answers": [
          { "answer": "Kaikki tietyn alueen kasvit." },
          { "answer": "Kaikki eläimet tietyllä alueella." },
          {
            "answer": "Elävien organismien yhteisö (bioottinen), joka on vuorovaikutuksessa fyysisen ympäristönsä kanssa (abioottinen)."
          },
          { "answer": "Kaikkien biomien globaali summa." }
        ],
        "answer": "Elävien organismien yhteisö (bioottinen), joka on vuorovaikutuksessa fyysisen ympäristönsä kanssa (abioottinen).",
        "explanation": "Ekosysteemi sisältää kaikki tietyllä alueella elävät olennot (kasvit, eläimet, bakteerit, sienet jne. – bioottiset tekijät), jotka ovat vuorovaikutuksessa keskenään ja myös fyysisen ympäristönsä kanssa (auringonvalo, maaperä, vesi, ilma, lämpötila jne. – abioottiset tekijät). Ekosysteemit voivat vaihdella kooltaan suuresti, pienestä lammikosta tai laajaan metsään."
      }
    ]
  },
  {
    "name": "Math Problem-Solving Approaches",
    "image": "https://images.unsplash.com/photo-1509228468518-180dd4864904",
    "questions": [
      {
        "question": "Ongelma: Arvioi lauseke $5 + 3 \\ kertaa (10 - 4) \\div 2$. Mikä osa tästä lausekkeesta tulisi laskea ensin operaatiojärjestyksen (PEMDAS/BODMAS) mukaan?",
        "answers": [
          { "answer": "Lisäys $5 + 3$" },
          { "answer": "Kertokerroin $3 \\kertaa 10 $" },
          { "answer": "Sulkeissa oleva lauseke $(10 - 4)$" },
          { "answer": "Divisioona $4 \\div 2$" }
        ],
        "answer": "Sulkeissa oleva lauseke $(10 - 4)$",
        "explanation": "Ongelma: Arvioi $5 + 3 \\ kertaa (10 - 4) \\div 2$.\n\nLähestymistapa: Käytämme toimintojen järjestystä (PEMDAS/BODMAS):\n1. **P**arentheses (tai **B**rackets): Arvioi ensin lausekkeet * $1 = 6 lauseke * $(n) \n. tulee: $5 + 3 \\ kertaa 6 \\div 2$.\n\n2 **E**x-komponentit (tai **O**rders): Tässä lausekkeessa ei ole eksponenteja.\n\n3 **M**multifikaatio ja **D**ivision: Suorita nämä operaatiot vasemmalta oikealle.\n * Ensin $5:n kertominen: + 18 \\div 2$.\n * Seuraavaksi jako: $18 \\div 2 = 9$.\n * Lausekkeesta tulee: $5 + 9$.\n\n4 **A**lisäys ja **S**vähennys: Suorita nämä toiminnot vasemmalta oikealle.\n * Lisäys: $5 + 9 $:n \n lausekkeen arvo +5 = \n lausekkeen arvo + 9 $. \\ kertaa (10 - 4) \\div 2$ on 14 $."
      },
      {
        "question": "Ongelma: Yksinkertaista algebrallinen lauseke $4(x - 2) + 3x - 5$. Mikä on ensimmäinen askel tämän lausekkeen yksinkertaistamisessa?",
        "answers": [
          { "answer": "Yhdistä $3x$ ja $-5$." },
          { "answer": "Jaa $4$ sulkeisiin $(x - 2)$." },
          { "answer": "Vähennä $2$ $x$:sta." },
          { "answer": "Lisää $4x$ ja $3x$." }
        ],
        "answer": "Jaa $4$ sulkeisiin $(x - 2)$.",
        "explanation": "Ongelma: Yksinkertaista $4(x - 2) + 3x - 5$.\n\nLähestymistapa:\n1. **Jaa:** Ensimmäinen vaihe on poistaa sulkeet jakamalla $4$ jokaiselle termille $(x - 2)$ sisällä.\n * $4 \\$ kertaa x x = 4 (x \ 2 ) -8$\n * Lausekkeesta tulee: $4x - 8 + 3x - 5$.\n\n2 **Yhdistä samankaltaiset termit:** Tunnista termit, joissa on sama muuttujaosa ($x$-termit) ja vakiotermit.\n * Yhdistä $x$-termit: $4x + 3x = (4+3)x = 7x$.\n -termit = 7x$.\n. -13$.\n\n3.**Kirjoita yksinkertaistettu lauseke:** Yhdistä vaiheen 2 tulokset.\n * Lausekkeesta tulee: $7x - 13$.\n\nRatkaisu: Yksinkertaistettu muoto $4(x - 2) + 3x - 5$ on $7x - 13$."
      },
      {
        "question": "Ongelma: Etsi $35\\%$ $200$:sta. Mitä tarkoittaa prosenttiosuuden löytäminen luvusta laskennan kannalta?",
        "answers": [
          { "answer": "Jaa luku prosenteilla." },
          {
            "answer": "Kerro luku prosenttiarvolla suoraan (esim. $200 \\ kertaa 35 $)."
          },
          {
            "answer": "Muunna prosenttiluku desimaaliksi tai murtoluvuksi ja kerro sitten numerolla."
          },
          { "answer": "Vähennä prosenttiluku luvusta." }
        ],
        "answer": "Muunna prosenttiluku desimaaliksi tai murtoluvuksi ja kerro sitten numerolla.",
        "explanation": "Ongelma: Etsi $35\\%$ 200 $:sta.\n\nLähestymistapa: Sana 'of' prosenttitehtävissä tarkoittaa usein kertolaskua. Laskeaksesi luvun prosenttiosuuden, sinun on ensin muutettava prosenttiosuus desimaaliksi tai murtoluvuksi.\n\n1. **Muunna prosentti desimaaliksi:**fra\0} 0,35 $.\n\n2. **Kerto:** Kerro tämä desimaali prosenttiosuudella.\n * 0,35 $ \\ kertaa 200 $.\n\n3 ** Laske tulos:**\n * $ 0,35 \\ kertaa 200, \n ** 70 $:lla Prosentti murtoluvuksi:**\n * $35\\% = \\frac{35}{100}$. Tätä voidaan yksinkertaistaa (esim. jakamalla molemmat 5:llä: $\\frac{7}{20}$).\n\n2. **Kerto:**\n * $\\frac{35}{0}{0} \\ kertaa 200}{100} = 35 \\ kertaa 2 = 70 $.\n * Tai käyttämällä yksinkertaistettua murto-osaa: $\\frac{7}{20} \\ kertaa 200 = 7 \\ kertaa \\frak 200 dollaria on 70 dollaria."
      },
      {
        "kysymys": "Ongelma: Resepti vaatii 2 dollarin kupillisia jauhoja 12 dollarin pikkuleipien tekemiseen. Kuinka monta kupillista jauhoja tarvitaan 30 dollarin pikkuleipien tekemiseen, jos suhde pysyy samana? Mikä matemaattinen käsite soveltuu tähän suorimmin?",
        "answers": [
          { "answer": "Suora lisäys" },
          { "answer": "Neliöyhtälön ratkaiseminen" },
          { "answer": "Suhteet ja suhteet" },
          { "answer": "Lasketaan prosentuaalista muutosta" }
        ],
        "answer": "Suhteet ja suhteet",
        "explanation": "Ongelma: $2$ kupillista jauhoja $12$ kekseihin. Paljonko jauhoja $30$ kekseihin?\n\nLähestymistapa: Tämä ongelma voidaan ratkaista käyttämällä suhteita ja suhteita. Voimme määrittää suhteet tuntemattoman jauhomäärän löytämiseksi.\n\n1. **Aseta suhde:** Olkoon jauhojen suhde $ tuntematon määrälle \ keksejä on vakiox. 30 $ evästeet.\n * Tunnettu suhde on $\\frac{2 \\text{ cups}}{12 \\text{ cookies}}$.\n * Haluttu suhde on $\\frac{x \\text{ cups}}{30 \\text{ cookies}}$.\n\n2 **Muodosta vastaavat luvut: *}{\{2 = suhde:**. _ \\ kertaa 30 = 6 \\ kertaa x$, mikä antaa $30 = 6x $.\n * Jaa sitten $6$:lla: $x = \\frac{30}{6} = 5$.\n\n * Vaihtoehtoisesti $\\frac{1}{6} = \\frac{x}{30}$ jälkeen voit:"
      },
      {
        "question": "Ongelma: Laske kolmion ympärysmitta, jonka sivujen pituus on $5 \\text{ cm}$, $7 \\text{ cm}$ ja $10 \\text{ cm}$. Mikä on perustavanlaatuinen lähestymistapa minkä tahansa monikulmion kehän löytämiseen?",
        "answers": [
          { "answer": "Kerro kaikki sivujen pituudet." },
          { "answer": "Lisää sen kaikkien sivujen pituudet." },
          {
            "answer": "Ota sivujen pituuksien keskiarvo ja kerro se sivujen lukumäärällä."
          },
          { "answer": "Käytä monikulmion alueen kaavaa." }
        ],
        "answer": "Lisää sen kaikkien sivujen pituudet."
        "explanation": "Ongelma: Etsi sellaisen kolmion kehä, jonka sivut ovat $5 \\teksti{ cm}$, $7 \\teksti{ cm}$ ja $10 \\teksti{ cm}$.\n\nLähestymistapa: Minkä tahansa monikulmion (suljetun muodon, jossa on suorat sivut) ympärysmitta on kokonaisetäisyys sen ulkorajan ympärillä. Tämä löytyy\n sen sivujen pituudesta\n.1. **Tunnista sivujen pituudet:**\n * Sivu 1 = 5 $ \\teksti{ cm}$\n * Sivu 2 = 7 $ \\teksti{ cm}$\n * Sivu 3 = 10 $ \\teksti{ cm}$\n\n2 **Summaa sivujen pituudet:**\n * Kehä = Sivu $2 \i / 3 \ 2 + Side 3. cm} + 7 \\teksti{ cm} + 10 \\teksti{ cm}$\n * Kehä = 12 $ \\teksti{ cm} + 10 \\teksti{ cm}$\n * Kehä = 22 $ \\teksti{ cm}$.\n\nRatkaisu: Kolmion ympärysmitta on $22 \\text{ cm}$"
      },
      {
        "question": "Ongelma: Sinulle annetaan funktio $f(x) = 2x^2 - 3x + 1$. Miten arvioisit $f(2)$?",
        "answers": [
          { "answer": "Ratkaise yhtälö $2x^2 - 3x + 1 = 2$ kohteelle $x$." },
          {
            "answer": "Etsi johdannainen $f(x)$ ja korvaa sitten $x=2$."
          },
          {
            "answer": "Korvaa $x=2$ lausekkeeseen $f(x)$ ja yksinkertaista."
          },
          { "answer": "Etsi funktion $f(x)$ juuret." }
        ],
        "answer": "Korvaa $x=2$ lausekkeeseen $f(x)$ ja yksinkertaista.",
        "explanation": "Ongelma: Arvioi $f(2)$ funktiolle $f(x) = 2x^2 - 3x + 1$.\n\nLähestymistapa: Funktion $f(x)$ arvioiminen tietyllä arvolla (esim. $x=2$) tarkoittaa, että $x$ korvataan kyseisellä arvolla kaikkialla, missä sitten ari-lauseke esiintyy funktiossa $x$. toiminnot.\n\n1. **Korvaa arvo $x$:**\n * Korvaa $2$ lausekkeessa $2x^2 - 3x + 1 $.\n * $f(2) = 2(2)^2 - 3(2) + 1$.\n\n2 **Seuraa toimintoa MAS:D:n toiminto/BO:s. ensin: $(2)^2 = 4$.\n * Lauseke muuttuu: $f(2) = 2(4) - 3(2) + 1$.\n * Kertokertoimet seuraavaksi: $2(4) = 8$ ja $3(2) = 6$.\n * Lausekkeesta tulee: $f(2) = 8 - 6 + $ 1$, sitten = 8, sitten $ 1$.\n $2 + 1 = 3 $.\n * $f(2) = 3 $.\n\nRatkaisu: $f(2) = 3 $."
      },
      {
        "question": "Ongelma: Etsi funktion $f(x) = x^2 + 3x - 1$ raja $x$ lähestyessä arvoa $2$. Mikä on yleinen lähestymistapa polynomifunktioiden rajojen etsimiseen suoralla korvauksella?",
        "answers": [
          { "answer": "Kerroi polynomi- ja peruutustermit." },
{ "answer": "Käytä L'Hôpitalin sääntöä." },
          {
            "answer": "Jos funktio on polynomi, voit suoraan korvata arvon $x$ lähestymässä funktiossa, jos se ei johda määrittelemättömään muotoon."
          },
          { "answer": "Etsi funktion johdannainen kyseisestä pisteestä." }
        ],
        "answer": "Jos funktio on polynomi, voit suoraan korvata arvon $x$ lähestymässä funktiossa, mikäli se ei johda määrittelemättömään muotoon.",
        "explanation": "Ongelma: Etsi $\\lim_{x \\to 2} (x^2 + 3x - 1)$.\n\nLähetystapa: Polynomifunktioiden (ja monien muiden jatkuvien funktioiden) raja $x$ lähestyy tiettyä arvoa $a$ voidaan usein löytää suoralla korvauksella. Tämä tarkoittaa funktion $x$n identify$ korvaamista funktiolla $a. ja piste $x$ lähestyy:**\n * Funktio: $f(x) = x^2 + 3x - 1$.\n * Piste: $x$ lähestyy arvoa $2$.\n\n2 **Korvaa arvo funktioon:**\n * Korvaa $x$ arvolla $2$ kohdassa $f(x)$.\n * x \x\2 1) = (2)^2 + 3(2) - 1 $.\n\n3 **Laske tulos:**\n * $(2)^2 = 4 $.\n * $3(2) = 6 $.\n * Joten lausekkeesta tulee $4 + 6 - 1$.\n * $4 + 6 = 10 $. $\\lim_{x \\to 2} (x^2 + 3x - 1) = 9$.\n\nHuomautus: Suora substituutio toimii polynomeille, koska ne ovat jatkuvia kaikkialla Rationaalisissa funktioissa tai muissa tyypeissä saatat kohdata määrittämättömiä muotoja, kuten $\\frac{0}{0}$ tai $\\frac{\\infty} (joka vaatisi muuta tekniikkaa,}{\\infty}). L'Hôpitalin sääntö jne.)."
      },
      {
        "question": "Ongelma: Pussi sisältää $3 $ punaista marmoria ja $2 $ sinistä marmoria. Jos piirrät yhden marmorin satunnaisesti, mikä on todennäköisyys piirtää sininen marmori? Miten perustodennäköisyys lasketaan?",
        "answers": [
          {
            "answer": "Jakamalla sinisten marmorien lukumäärä punaisten marmorien lukumäärällä."
          },
          {
            "answer": "Jakamalla haluttujen tulosten määrä (siniset marmorit) mahdollisten tulosten kokonaismäärällä (pallojen kokonaismäärä)."
          },
          {
            "answer": "Vähentämällä sinisten marmorien lukumäärä marmorien kokonaismäärästä."
          },
          { "answer": "Se on aina $50\\%$, jos väriä on kaksi." }
        ],
        "answer": "Jakamalla haluttujen tulosten määrä (siniset marmorit) mahdollisten tulosten kokonaismäärällä (pallojen kokonaismäärä).",
        "explanation": "Ongelma: Selvitä todennäköisyys vetää sininen marmori pussista, jossa on $3 $ punaista ja $2 $ sinistä marmoria.\n\nLähestymistapa: Perustodennäköisyys lasketaan myönteisten tulosten määrän ja mahdollisten tulosten kokonaismäärän suhteena.\n$P(\\text{Event}) = \\\text{Event}) = \\\text{Event}) = \\\teksti Mahdollisten tulosten määrä}}$.\n\n1. **Tunnista suotuisten tulosten määrä:**\n * Haluamme piirtää sinisen marmorin.\n * Sinisten marmorien lukumäärä = $2.\n\n2 **Tunnista mahdollisten tulosten kokonaismäärä:**\n * Tämä on marmorien kokonaismäärä *nmarmorien\n kokonaismäärä. Marbles yhteensä = $3 + 2 = 5$.\n\n3. **Laske todennäköisyys:**\n * $P(\\teksti{Sininen}) = \\frac{\\teksti{Sinisien marmorien lukumäärä}}{\\teksti{Kumppujen kokonaismäärä}}$\n * $P(\\teksti) ={Blue \\frac{2}{5}$.\n\nRatkaisu: Sinisen marmorin piirtämisen todennäköisyys on $\\frac{2}{5}$. Tämä voidaan ilmaista myös desimaalilukuna ($0,4$) tai prosentteina ($40\\%$)."
      },
      {
        "question": "Ongelma: Yksinkertaista lauseke $\\sqrt{48}$. Mikä on yleinen lähestymistapa epätäydellisten neliöiden neliöjuurien yksinkertaistamiseen?",
        "answers": [
          { "answer": "Etsi lähin täydellinen neliö ja likimäärä." },
          { "answer": "Laukea ei voi yksinkertaistaa enempää." },
          {
            "answer": "Etsi radikaalin alta olevan luvun suurin täydellinen neliötekijä ja ota sen neliöjuuri pois."
          },
          { "answer": "Jaa luku kahdella." }
        ],
        "answer": "Etsi radikaalin alta luvun suurin täydellinen neliötekijä ja ota sen neliöjuuri pois.",
        "explanation": "Ongelma: Yksinkertaista $\\sqrt{48}$.\n\nLähestymistapa: Epätäydellisen neliön neliöjuuren yksinkertaistamiseksi etsimme suurinta täydellistä neliötä, joka on radikaalin (radikaanin) alla olevan luvun tekijä. Täydellinen neliö on luku, kuten $4 (2^2), 9 (3^2), ^ 2, 6, 2 jne.\n\n1. **Etsi radikaalin (48) tekijät:**\n * $48 = 1 \\ kertaa 48 $\n * $ 48 = 2 \\ kertaa 24 $\n * $ 48 = 3 \\ kertaa 16 $\n * $ 48 = 4 \\ kertaa \n 8 $ \ n = 8 $ \ n . **Tunnista täydelliset neliötekijät:** luettelosta täydelliset neliötekijät ovat $1, 4, 16 $.\n\n3 **Valitse suurin täydellinen neliötekijä:** Suurin täydellinen neliötekijä on $16.\n\n4 **Kirjoita radikaali käyttämällä tätä tekijää:**\n * $48 = 16 ominaisuus $\\sqrt{a \\times b} = \\sqrt{a} \\times \\sqrt{b}$:**\n * $\\sqrt{48} = \\sqrt{16 \\ kertaa 3} = \\sqrt{16} \\kertaa \\\ sqrt neliö:**\n * $\\sqrt{16} = 4 $.\n\n7. **Kirjoita yksinkertaistettu lauseke:**\n * $\\sqrt{48} = 4 \\ kertaa \\sqrt{3} = 4\\sqrt{3}$.\n\nRatkaisu: Yksinkertaistettu muoto on $4\}$qrt $4\\sqrt{3}$."
      }
    ]
  },
  {
    "name": "TypeScript (Perustiedot)",
    "image": "https://images.unsplash.com/photo-1592609931095-54a2168ae893",
    "questions": [
      {
        "question": "Mikä on ensisijainen suhde TypeScriptin ja JavaScriptin välillä?",
        "answers": [
          {
            "answer": "TypeScript on täysin eri kieli kuin JavaScript."
          },
          { "answer": "TypeScript on JavaScriptin pääjoukko." },
          {
            "answer": "TypeScript on kehys, jota käytetään JavaScript-koodin suorittamiseen."
          },
          { "answer": "TypeScript on JavaScriptin yksinkertaistettu osajoukko." }
        ],
        "answer": "TypeScript on JavaScriptin pääjoukko.",
        "explanation": "TypeScript on JavaScriptin tiukka syntaktinen superjoukko. Tämä tarkoittaa, että mikä tahansa kelvollinen JavaScript-koodi on myös kelvollista TypeScript-koodia. TypeScript lisää valinnaisen staattisen kirjoittamisen ja muita ominaisuuksia JavaScriptin päälle, jotka sitten käännetään tavalliseksi JavaScriptiksi toimimaan selaimissa tai muissa ympäristöissä."
      },
      {
        "question": "Kuinka määrität oikein muuttujan nimeltä 'username', jolla pitäisi olla 'string'-arvo TypeScriptissä?",
        "answers": [
          { "answer": "var käyttäjänimi = merkkijono;" },
          { "answer": "anna käyttäjänimi: 'merkkijono';" },
          { "answer": "anna käyttäjänimi: string = 'vieras';" },
          { "answer": "merkkijono käyttäjänimi = 'vieras';" }
        ],
        "answer": "anna käyttäjänimi: string = 'vieras';",
        "explanation": "TypeScriptissä määrität tietyntyyppisen muuttujan käyttämällä kaksoispistettä `:` ja tyypin nimeä. Esimerkiksi `let variableName: type;`. Jos haluat ilmoittaa merkkijonomuuttujan nimeltä `username` ja alustaa sen, kirjoitat `let username: string = 'guest';`."
      },
      {
        "question": "Mitä '|'-symboli edustaa tyyppimerkinnässä, kuten 'let id: string | numero;'?'",
        "answers": [
          {
            "answer": "Se on 'ja'-operaattori, mikä tarkoittaa, että muuttujan on oltava sekä merkkijono että numero."
          },
          { "answer": "Se osoittaa funktion palautustyypin." },
          {
            "answer": "Se on Union Type, mikä tarkoittaa, että muuttuja voi sisältää kumman tahansa tyypin arvon (merkkijono TAI numero)."
          },
          { "answer": "Se on syntaksivirhe eikä kelpaa TypeScript." }
        ],
        "answer": "Se on Union Type, mikä tarkoittaa, että muuttuja voi sisältää kumman tahansa tyypin arvon (merkkijono TAI numero).",
        "explanation": "Pystypalkkia `|` käytetään luomaan **Union Type**. Liittymätyyppi sallii muuttujan arvon, joka on yksi useista määritetyistä tyypeistä. Jos kyseessä on 'let id: string | number;', 'id'-muuttujalle voidaan määrittää joko 'string'- tai 'number'-arvo aiheuttamatta tyyppivirhettä."
      },
      {
        "question": "Mikä on avainero TypeScript-tuplen ja tavallisen taulukon välillä?",
        "answers": [
          {
            "answer": "Tuplessa on kiinteä määrä elementtejä tietyillä tyypeillä kullekin sijainnille, kun taas taulukossa voi olla mikä tahansa määrä yhden tyypin elementtejä."
          },
          {
            "answer": "Tuple voi sisältää vain numeroita, kun taas taulukko voi sisältää minkä tahansa tyypin."
          },
          {
            "answer": "Matriisi on muuttumaton (ei voi muuttaa), kun taas monikko on muuttumaton."
          },
          {
            "answer": "Ei ole eroa; 'tuple' on vain toinen nimi 'taulukolle'"
          }
        ],
        "answer": "Tupolla on kiinteä määrä elementtejä, joissa on tietyt tyypit kullekin sijainnille, kun taas taulukossa voi olla mikä tahansa määrä yhden tyypin elementtejä.",
        "explanation": "**tuple** on erityinen taulukko, jossa on kiinteä määrä elementtejä ja jossa kunkin elementin tyyppi on tiedossa. Esimerkiksi `let user: [number, string] = [1, 'Liisa'];` määrittää monikon, jossa on oltava täsmälleen kaksi elementtiä: ensimmäinen numero ja toinen merkkijono**, kuten mikä tahansa merkkijono, numero elementtejä, mutta niiden kaikkien on oltava samaa tyyppiä (tässä tapauksessa "merkkijono")."
      },
      {
        "question": "Mitä seurauksia on 'mikä tahansa'-tyypin käyttämisestä muuttujassa?",
        "answers": [
          {
            "answer": "Se tekee muuttujan 'vain luku', joten sitä ei voi muuttaa."
          },
          {
            "answer": "Se poistaa kaiken käännösajan tyyppitarkistuksen tälle muuttujalle."
          },
          {
            "answer": "Se pakottaa muuttujan olemaan joko 'null' tai 'undefined'."
          },
          { "answer": "Se sallii muuttujan sisältää vain numeerisia arvoja." }
        ],
        "answer": "Se poistaa kaiken käännösajan tyyppitarkistuksen tälle muuttujalle.",
        "explanation": "Tyyppi 'any' on tehokas tapa työskennellä olemassa olevan JavaScriptin kanssa, koska sen avulla voit poistaa muuttujan tyyppitarkistuksen käytöstä. Kun muuttuja on tyyppiä any", voit määrittää sille minkä tahansa arvon, kutsua mitä tahansa menetelmää siinä ja käyttää mitä tahansa sen ominaisuutta ilman, että TypeScript raportoi käännösaikavirheestä. Sitä tulisi käyttää säästeliäästi, koska se poistaa TypeScriptin."
      },
      {
        "question": "Mikä syntaksi määrittää oikein kertomisfunktion, joka ottaa kaksi "luku"-parametria ja jonka odotetaan palauttavan "luvun"?",
        "answers": [
          { "answer": "funktio kertoa(a, b) numero { return a * b; }" },
          {
            "answer": "funktio kertoa(a: numero, b: numero): numero { return a * b; }"
          },
          { "answer": "funktio kertoa(a, b) -> numero { return a * b; }" },
          {
            "answer": "funktio kerro: numero (a: numero, b: numero) { return a * b; }"
          }
        ],
        "answer": "funktio kertoa(a: numero, b: numero): numero { return a * b; }",
        "explanation": "TypeScriptissä kirjoitat funktion parametrit lisäämällä `: type` parametrin nimen perään. Määrität funktion palautustyypin lisäämällä parametriluettelon perään `: type. Funktiolle nimeltä `multiply`, joka ottaa kaksi numeroa `a` ja `b` ja palauttaa luvun, oikea syntaksi on `function {...b:}` numero: numero.
      },
      {
        "question": "Mihin TypeScript-luetteloa käytetään ensisijaisesti?",
        "answers": [
          { "answer": "Määrittääksesi joukon nimettyjä vakioita." },
          {
            "answer": "Luo silmukan, joka toistuu tietyn määrän kertoja."
          },
          { "answer": "Eri tietotyyppien tallentaminen yhteen muuttujaan." },
          { "answer": "Luokassa esiintymän luominen." }
        ],
        "answer": "Määrittääksesi joukon nimettyjä vakioita.",
        "explanation": "Enum" (luettelo) on ominaisuus, jonka avulla voit määrittää joukon toisiinsa liittyviä arvoja nimettyjen vakioiden joukoksi. Tämä tekee koodistasi luettavamman ja vähemmän altis virheille. Esimerkiksi sen sijaan, että käyttäisit raakoja numeroita, kuten 0, 1, 2 ohjeissa, voit määrittää `enum Suunta { Ylös, Alas`, Up` Oletusarvon mukaan { Ylös, Alas`, Up`. "Alas" olisi 1 ja niin edelleen."
      },
      {
        "question": "Mikä on "rajapinnan" tarkoitus TypeScriptissä?",
        "answers": [
          { "answer": "Matemaattisten laskutoimitusten suorittaminen." },
          { "answer": "Uuden objektin esiintymän luominen." },
          { "answer": "Määrittää kohteen rakenteen tai muodon." },
          { "answer": "Tallenna tietoja, joita ei voi muuttaa." }
        ],
        "answer": "Määrittää kohteen rakenteen tai muodon."
        "explanation": ""Liitäntä" on tehokas tapa määritellä "koodisopimus" tai objektin muoto. Se määrittää ominaisuuksien nimet ja niiden tyypit, jotka objektilla on oltava. Tämä auttaa varmistamaan, että objektit ovat tietyn rakenteen mukaisia, mikä tekee koodista kestävämmän ja helpommin ymmärrettävän. Esimerkiksi "käyttöliittymä User { id: number; name: string, joka objektilla on oltava ominaisuus }". numero ja ominaisuus "nimi", joka on merkkijono."
      },
      {
        "question": "Mikä on oikea tapa määrittää numerotaulukko TypeScriptissä?",
        "answers": [
          { "answer": "anna luettelo: numero[];" },
          { "answer": "anna luettelo: Taulukko[numero];" },
          { "answer": "anna luettelo: {numero};" },
          { "answer": "anna lista = numero[];" }
        ],
        "answer": "anna luettelo: numero[];",
        "explanation": "On kaksi yleistä tapaa ilmoittaa tietyn tyyppinen taulukko TypeScriptissä. Yleisin syntaksi on käyttää tyyppiä ja hakasulkeet: `let lista: numero[]`. Toinen tapa on käyttää yleistä taulukkotyyppisyntaksia: `let list: Array<number>`. Molemmat ovat oikein ja saavuttavat saman tuloksen."
      },
      {
        "question": "Mikä on "as"-avainsanan tarkoitus TypeScriptissä?",
        "answers": [
          { "answer": "Luo alias tai uusi nimi tyypille." },
          {
            "answer": "Suorittaa tyyppivahvistus, käskemällä kääntäjää käsittelemään arvoa eri tyyppinä."
          },
          { "answer": "Toisennimisen moduulin tuominen." },
          { "answer": "Vakiomuuttujan määrittäminen." }
        ],
        "answer": "Suorittaaksesi tyypin väitteen, käskemällä kääntäjää käsittelemään arvoa eri tyyppinä."
        "explanation": "Avainsanaa `as` käytetään **type-vahvistukseen** (kutsutaan joskus tyypin castingiksi). Tämä on tapa kertoa TypeScript-kääntäjälle, että sinä, kehittäjä, tiedät enemmän arvon tyypistä kuin kääntäjä. Jos sinulla on esimerkiksi muuttuja, jonka tyyppi on `tuntematon`, tiedät että tämä on `sert', kuten tämä arvo on: merkkijono). pituus. Se on tapa ohittaa kääntäjän päätelmä tyyppi."
      }
    ]
  },
  {
    "name": "TypeScript Generics",
    "image": "https://images.unsplash.com/photo-1592609931095-54a2168ae893",
    "questions": [
      {
        "question": "Mikä on ensisijainen tarkoitus käyttää geneerejä TypeScriptissä, esimerkiksi funktiossa, kuten `funktioiden identiteetti<T>(arg: T): T`?",
        "answers": [
          { "answer": "Jotta funktio toimisi vain objektien kanssa." },
          {
            "answer": "Luo uudelleenkäytettäviä komponentteja, jotka voivat toimia useiden eri tyyppien kanssa yhden yksittäisen osan sijaan."
          },
          { "answer": "Muuntaa argumentin automaattisesti merkkijonoksi." },
          { "answer": "Tee funktiosta asynkroninen." }
        ],
        "answer": "Luo uudelleenkäytettäviä komponentteja, jotka voivat toimia useiden eri tyyppien kanssa yksittäisen yhden sijaan."
        "explanation": "Yleiset ominaisuudet antavat meille mahdollisuuden luoda uudelleenkäytettäviä komponentteja, jotka voivat toimia useilla eri tyypeillä. Funktioidentiteetti<T>(arg: T): T":ssa "<T>" on tyyppimuuttuja. Se on tietyn tyypin paikkamerkki, jonka funktion kuluttaja tarjoaa. Tämä sallii funktion hyväksyä minkä tahansa tyypin ("T") erillisenä turva-argumenttina ja palauttamatta jokaisen mahdollisen turvatyypin kirjoittamisen arvoa. tyyppi."
      },
      {
        "question": "Kun otetaan huomioon yleinen funktio `function getFirstElement<T>(arr: T[]): T | undefined`, kuinka kutsuisit tätä funktiota oikein numerojoukon kanssa?",
        "answers": [
          { "answer": "getFirstElement(numero, [10, 20]);" },
          { "answer": "getFirstElement<numero>([10, 20]);" },
          { "answer": "getFirstElement([10, 20])<numero>;" },
          { "answer": "getFirstElement.number([10, 20]);" }
        ],
        "answer": "getFirstElement<numero>([10, 20]);",
        "explanation": "Voit kutsua yleistä funktiota kahdella tavalla. Ensimmäinen on antaa tyyppi eksplisiittisesti kulmasuluissa: `getFirstElement<number>([10, 20]);`. Tämä kertoo TypeScriptille tarkalleen, mikä `T`:n pitäisi olla. Toinen tapa on antaa TypeScriptin päätellä tyyppi välitettävistä argumenteista. Tässä tapauksessa myös `(getFir1r, `E); toimii, koska TypeScript näkee, että olet antanut numeron[], ja päättelee, että T:n on oltava numero.
      },
      {
        "question": "Mitä tarkoitusta on käyttää `extends`-avainsanaa yleisessä rajoituksessa, kuten funktiossa logLength<T extends { pituus: numero }>(arg: T)`?",
        "answers": [
          {
            "answer": "Se saa yleisen tyypin "T" perimään "length" -ominaisuuden."
          },
          { "answer": "Se varmistaa, että tyyppi `T` voi olla vain numero." },
          {
            "answer": "Se rajoittaa tyypin "T" olemaan vain tyyppejä, joilla on "length"-ominaisuus tyyppiä "number".
          },
          {
            "answer": "Se laajentaa funktion ominaisuuksia sisältämään `length` -ominaisuuden."
          }
        ],
        "answer": "Se rajoittaa tyypin "T" olemaan vain tyyppejä, joilla on "length"-ominaisuus tyyppiä "number".",
        "explanation": "Yleinen rajoitus rajoittaa tyyppejä, joita voidaan käyttää tyyppiargumenttina. Extends-avainsanaa käytetään tämän rajoituksen soveltamiseen. Kohdassa "T extends { pituus: numero }" kerromme TypeScriptille, että "T" voi olla mitä tahansa tyyppiä, kunhan sillä on ominaisuus nimeltä "length", joka on tyypiltään 'a.rgly sallii 'us. toiminto, koska olemme taaneet sen olemassaolon. Tämä toimii taulukoille, merkkijonoille ja mukautetuille objekteille, joilla on "length"-ominaisuus.
      },
      {
        "question": "Kuinka määrittelet yleisen käyttöliittymän nimeltä "Box", joka voi sisältää minkä tahansa tyyppisen arvon?",
        "answers": [
          { "answer": "liitäntälaatikko<T> { arvo: T; }" },
          { "answer": "liitäntälaatikko { arvo: <T>; }" },
          { "answer": "liitäntä<T> Box { arvo: T; }" },
          { "answer": "liitäntälaatikko { arvo: mikä tahansa; }" }
        ],
        "answer": "liitäntälaatikko<T> { arvo: T; }",
        "explanation": "Yleisten funktioiden tapaan voit luoda yleisiä liitäntöjä lisäämällä tyyppiparametrin `<T>` käyttöliittymän nimen perään. T-kirjainta voidaan sitten käyttää paikkamerkkinä liitännän rakenteessa oleville tyypeille. `rajapinta Box<T> { arvo: T; }` määrittää `laatikon`, joka voi sisältää minkä tahansa tyyppisen `käyttöliittymän, esim.\n. Käyttö:**\n```typescript\nlet numberBox: Box<number> = { arvo: 10 };\nlet stringBox: Box<string> = { arvo: 'hello' };\n```\nVaikka `liitäntä Box { arvo: mikä tahansa }` toimisi toiminnallisesti, mutta se menettää yleisen version.
      },
      {
        "question": "Miksi yleisen tyyppimuuttujan `<T>` käyttö on yleensä parempi kuin minkä tahansa tyypin käyttäminen uudelleenkäytettävien funktioiden luomiseen?",
        "answers": [
          { "answer": "Yleiset aineet ovat nopeampia suoritusaikana kuin "mikään". },
          {
            "answer": "Yleiset tuotteet säilyttävät tyyppitiedot ja tarjoavat tyyppiturvan, kun taas "any" jättää tyyppitarkistuksen pois."
          },
          { "answer": "Tyyppiä "mikä tahansa" ei voi käyttää funktioparametreissa." },
          {
            "answer": "Ei ole eroa; "<T>" on vain nykyaikaisempi syntaksi sanalle "mikä tahansa".
          }
        ],
        "answer": "Yleiset aineet säilyttävät tyyppitiedot ja tarjoavat tyyppiturvan, kun taas "any" jättää tyyppitarkistuksen pois käytöstä."
        "explanation": "Any:n käyttö poistaa kaiken tyyppisuojauksen muuttujan tai funktion parametrista. Jos funktio hyväksyy "any" ja palauttaa "mikä tahansa", TypeScript ei tiedä tulon ja lähdön välistä suhdetta. \nYleisen <T>:n käyttäminen sallii funktion hyväksyä minkä tahansa tyypin, mutta se **kaappaa**, jos funktio kirjoitat tiedot funktiolle. Tämä tarkoittaa, että `st. identiteetti<T>(arg: T): T, TypeScript tietää, että funktio palauttaa "numeron", se tietää, että se palauttaa "numeron".
      },
      {
        "question": "Kuinka määrittelet yleisen luokan "Wrapper", joka voi kääriä minkä tahansa tyypin arvon?",
        "answers": [
          { "answer": "class Wrapper { rakentaja(yksityinen arvo: <T>) {} }" },
          { "answer": "class Wrapper<T> { rakentaja(yksityinen arvo: T) {} }" },
          { "answer": "luokka<T> Wrapper { rakentaja(yksityinen arvo: T) {} }" },
          {
            "answer": "luokan kääre <T> { rakentaja(yksityinen arvo: T) {} }"
          }
        ],
        "answer": "class Wrapper<T> { rakentaja(yksityinen arvo: T) {} }",
        "explanation": "Yleinen luokka määritellään lisäämällä tyyppiparametri `<T>` luokan nimen perään. Tämä sallii luokan ominaisuuksien, menetelmien ja rakentajan käyttää tyyppiä `T`. \n\n**Esimerkki Käyttö:**\n```typescript\nclass Wrapper<T> {\n yksityinen arvo: T\n;\n tämä arvo.n)( }\n getValue(): T {\n return this.value;\n }\n}\n\n// Luo ilmentymä numerolle\nlet numberWrapper = new Wrapper<number>(123);\nconsole.log(numberWrapper.getValue() // Tulos: 123\n\n// Luo ilmentymä \n\n//Luo instanssi aferingille. Wrapper('Hello World');\nconsole.log(stringWrapper.getValue()); // Tulos: 'Hello World'\n```"
      },
      {
        "question": "Mitä yleinen apuohjelmatyyppi `Partial<T>` tekee?",
        "answers": [
          {
            "answer": "Se ottaa tyypin "T" ja tekee kaikista sen ominaisuuksista "vain luku".
          },
          {
            "answer": "Se ottaa tyypin `T` ja tekee kaikista sen ominaisuuksista valinnaisia ​​(`?`)."
          },
          { "answer": "Se "poimii" vain joitain ominaisuuksia tyypistä "T"." },
          { "answer": "Se ottaa vain funktion ominaisuudet tyypistä `T`." }
        ],
        "answer": "Se ottaa tyypin `T` ja tekee kaikista sen ominaisuuksista valinnaisia ​​(`?`).",
        "explanation": "`Osittainen<T>` on sisäänrakennettu yleinen apuohjelmatyyppi, joka rakentaa uuden tyypin olemassa olevasta tyypistä `T`, jossa kaikki ominaisuudet on asetettu valinnaisiksi. Tämä on hyödyllistä, kun haluat luoda objektin, joka edustaa osittaista päivitystä, jossa annat vain osan alkuperäisen objektin ominaisuuksista.\n\n**Esimerkki Käyttö:`script: \n`interface number: **\n`; nimi: merkkijono;\n sähköposti: merkkijono;\n}\n\nfunktio updateKäyttäjä(id: numero, päivitykset: Osittainen<Käyttäjä>) {\n // ... logiikka päivittää käyttäjä vain annetuilla kentillä\n}\n\n// Tämä on kelvollinen kutsu, koska Partial<User> tekee 'nimestä' ja 'sähköpostista' valinnaisia\n\nUusi nimi ''Uusi nimi ' });\n```"
      },
      {
        "question": "Ajattele funktion allekirjoitusta `function getProperty<T, K extends keyof T>(obj: T, key: K)`. Mitä `K extends keyof T` saavuttaa?",
        "answers": [
          { "answer": "Se varmistaa, että "K" on aina merkkijono "avain"." },
          {
            "answer": "Se varmistaa, että "avain"-parametrin on oltava yksi "obj"-parametrin todellisista avaimista."
          },
          {
            "answer": "Se muuntaa "obj"-parametrin avaimien joukoksi."
          },
          {
            "answer": "Se sallii "K":n olla mikä tahansa merkkijono tai numero, ja "T":llä on oltava tämän tyyppinen ominaisuus."
          }
        ],
        "answer": "Se varmistaa, että "avain"-parametrin on oltava yksi "obj"-parametrin todellisista avaimista.",
        "explanation": "Tämä on edistyksellinen, mutta hyvin yleinen yleinen malli. T-avain on operaattori, joka tuottaa tyypin "T" tunnettujen julkisten ominaisuusnimien (avainten) liiton. Rajoitus "K extends keyof T" tarkoittaa, että tyypin "K" (joka tulee olemaan "avain"-parametrin tyyppi) on oltava avain, joka todellakin on olemassa T-tyypissä. objektin ominaisuuden etsiminen dynaamisesti.\n\n**Käyttöesimerkki:**\n```typescript\nfunktio getProperty<T, K laajentaa avaimen T>(obj: T, avain: K): T[K] {\n return obj[avain];\n}\n\nanna käyttäjä = { nimi: 'Liisa\n", käyttäjätunnus =\0con}; getProperty(user, 'nimi'); // OK, 'nimi' on avain käyttäjänimelle Sijaintia ei voi määrittää parametrille 'name' |.\n```"
      },
      {
        "question": "Kuinka voit antaa oletustyypin yleiselle tyyppiparametrille?",
        "answers": [
          { "answer": "funktio luo<T oletusmerkkijono>() {}" },
          { "answer": "funktio create<T is string>() {}" },
          { "answer": "funktio Create<T = string>() {}" },
          { "answer": "funktio create<T || string>() {}" }
        ],
        "answer": "funktio create<T = string>() {}",
        "explanation": "Voit antaa oletusarvon yleiselle tyyppiparametrille käyttämällä `=`-operaattoria tyyppiparametrin nimen jälkeen. Tämä on hyödyllistä, kun haluat, että yleisellä komponentilla on oletuskäyttäytyminen, mutta annat sen ohittaa tarvittaessa.\n\n**Esimerkkikäyttö:**\n```typescript\ntype Säiliö<T = string> älä anna sitä a/ } = {n arvo, T / oletusmerkkijono\nlet stringContainer: Container = { arvo: 'oletus on merkkijono' };\n\n// Voimme silti tarjota eri tyypin ohittaaksemme oletusarvon\nlet numberContainer: Container<numero> = { arvo: 123 };\n```\nTämä tekee yleisen tyypin käytöstä joustavampia ja helpompia."
      },
      {
        "question": "Mikä on seuraavan yleisfunktion palautustyyppi, jos sitä kutsutaan merkkijonotaulukolla `['a', 'b', 'c']`? \n`function reverseAndWrap<T>(arr: T[]): { data: T[] }`",
        "answers": [
          { "answer": "{ data: string }" },
          { "answer": "merkkijono[]" },
          { "answer": "{ data: mikä tahansa[] }" },
          { "answer": "{ data: string[] }" }
        ],
        "answer": "{ data: string[] }",
        "explanation": "Tässä esimerkissä yleinen funktio `reverseAndWrap<T>` ottaa taulukon, jonka tyyppi on `T` (`T[]`) ja palauttaa objektin data-ominaisuuden kanssa, joka on myös tyyppiä `T` (`T[]`) oleva matriisi.\n1. **Funktion kutsuminen:** Kun kutsut funktiota, 'c'])', TypeScript näkee, että argumentti on merkkijono.\n2. **Tyyppipäätelmä:** Se päättelee, että yleisen tyypin 'T' on oltava 'merkkijono'.\n3. **Palautintyypin määrittäminen:** Funktion ilmoitettu palautustyyppi on '{ data: T'ring``st:n korvaaminen tyyppi on `{ data: string[] }`."
      }
    ]
  },
  {
    "name": "TypeScript Array Manipulation",
    "image": "https://images.unsplash.com/photo-1612838320302-4b3b3b3b3b3b",
    "questions": [
      {
        "question": "Mikä matriisimenetelmä lisää yhden tai useamman elementin taulukon loppuun ja palauttaa taulukon uuden pituuden, muuttaen alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "concat()" },
          { "answer": "push()" },
          { "answer": "slice()" },
          { "answer": "liitty()" }
        ],
        "answer": "push()",
        "explanation": "`push()`-menetelmä lisää yhden tai useamman elementin taulukon **päähän** ja **muuttaa** (muuttaa) alkuperäistä taulukkoa. Se palauttaa taulukon uuden `pituuden`.\n\n**Esimerkki (TypeScript):**\n```typescript\nanna hedelmät: string'Apple[]", = ['Apple[]", 'Banaani'];\nconsole.log('Alkuperäinen array:', hedelmät); // Tulos: ['Omena', 'Banaani']\n\nconst newLength = fruits.push('Orange', 'Mango');\n\nconsole.log",'Uusi pituus:' 4\nconsole.log('Mutated array:', hedelmät // Tulos: ['Omena', 'Banaani', 'Orange', 'Mango']\n```");
      },
      {
        "question": "Mikä matriisimenetelmä poistaa viimeisen elementin taulukosta ja palauttaa poistetun elementin, muuttaen alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "shift()" },
          { "answer": "slice(-1)" },
          { "answer": "pop()" },
          { "answer": "unshift()" }
        ],
        "answer": "pop()",
        "explanation": "`pop()`-menetelmä poistaa **last**-elementin taulukosta. Se **muuttaa** alkuperäisen taulukon ja palauttaa poistetun elementin. Jos taulukko on tyhjä, `pop()` palauttaa `määrittämättömän`.\n\n**Esimerkki (TypeScript):**\n``s [:0,0], =0,2 40];\nconsole.log('Alkuperäinen array:', numerot); // Output: [10, 20, 30, 40]\n\nconst lastElement = numbers.pop();\n\nconsole.log('Poistettu elementti:', lastElement\/\n:sutated); Tulos: [10, 20, 30]\n\nconst emptyArray: number[] = [];\nconst removedFromEmpty = emptyArray.pop();\nconsole.log('Poistettu tyhjästä:', poistettuFromEmpty // Tulos: undefined\n```");
      },
      {
        "question": "Mikä matriisimenetelmä poistaa ensimmäisen elementin taulukosta ja palauttaa poistetun elementin muuntaen alkuperäisen taulukon?",
        "answers": [
          { "answer": "pop()" },
          { "answer": "shift()" },
          { "answer": "slice(0, 1)" },
          { "answer": "liitos(0, 1)" }
        ],
        "answer": "vaihto()",
        "explanation": "`shift()`-menetelmä poistaa **ensimmäisen**-elementin taulukosta. Se **muuttaa** alkuperäistä taulukkoa ja palauttaa poistetun elementin. Jos taulukko on tyhjä, `shift()` palauttaa `määrittämättömän`.\n\n**Esimerkki (TypeScript):**\n``let coloring[\n]", [:"typescripting] 'Vihreä' 'Punainen'\nconsole.log('Mutated array:', värit); // Tulos: ['Green', 'Blue']\n\nconst emptyArray: string[] = [];\nconst poistettuFromEmpty = tyhjäArray.shift();\nconsole.moved from tyhjä määrittelemätön\n```"
      },
      {
        "question": "Mikä matriisimenetelmä lisää yhden tai useamman elementin taulukon alkuun ja palauttaa taulukon uuden pituuden, muuttaen alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "push()" },
          { "answer": "concat()" },
          { "answer": "unshift()" },
          { "answer": "liitos(0, 0, ...kohteet)" }
        ],
        "answer": "unshift()",
        "explanation": "Unshift()-menetelmä lisää yhden tai useamman elementin taulukon **alkuun**. Se **muuttaa** alkuperäisen taulukon ja palauttaa taulukon uuden "pituuden".\n\n**Esimerkki (TypeScript):**\n```typescript\nanna eläimet: string[\] = ['Dog[]", 'Kissa'];\nconsole.log('Alkuperäinen array:', eläimet); // Tulos: ['Koira', 'Kissa']\n\nconst newLength = animals.unshift('Bird', 'Fish');\n\nconsole.log,'Uusi pituus:','Uusi pituus:', 4\nconsole.log('Mutated array:', eläimet // Tulos: ['Linnu', 'Kala', 'Koira', 'Kissa']\n```"
      },
      {
        "question": "Mikä taulukkomenetelmä muuttaa taulukon sisältöä poistamalla tai korvaamalla olemassa olevia elementtejä ja/tai lisäämällä uusia elementtejä paikoilleen, palauttamalla taulukon, joka sisältää poistetut elementit?",
        "answers": [
          { "answer": "slice()" },
          { "answer": "concat()" },
          { "answer": "kartta()" },
          { "answer": "liitos()" }
        ],
        "answer": "liitos()",
        "explanation": "`Splice()`-menetelmä on tehokas tapa muuttaa taulukkoa poistamalla, korvaamalla tai lisäämällä elementtejä. Se **muuttaa** alkuperäisen taulukon. Se palauttaa taulukon, joka sisältää poistetut elementit. Jos mitään elementtejä ei poisteta, se palauttaa tyhjän taulukon.\n\n**Syntaksi:** `Count,Index.s. ...itemsToAdd)`\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nantakaa kuukaudet: string[] = ['Tammi', 'Maaliskuu', 'Huhtikuu', 'Kesäkuu'];\nconsole.log('Alkuperäinen array:', months), /"Jan \', /"Jan ', '); 'June']\n\n// Poista 1 elementti hakemistosta 1 ('Maaliskuu') ja lisää 'Feb'\nconst deletedItems = months.splice(1, 1, 'Feb') \nconsole.log('Poistetut kohteet:', deletedItems'Arkisto:]\n liitos (lisää & poista):', months); // Tulos: ['Tam', 'helmi', 'huhtikuu', 'kesäkuu']\n\n// Lisää 'Toukokuu' indeksiin 3 poistamatta mitään elementtejä\nmonths.splice(3, 0, 'n"splice.log after" 'splice'ray); (lisää vain):', kuukautta); // Tulos: ['Tam', 'helmikuu', 'huhtikuu', 'toukokuu', 'kesäkuu']\n\n// Poista 2 elementtiä indeksistä 0 alkaen\nconst removedAgain = months.splice(0, 2);\nconsole/Deleted:OutAput.log('/Deleted:OutAput.log); ['Tammi', 'Helmikuu']\nconsole.log('Lopullinen array:', kuukautta // Tulos: ['Huhtikuu', 'Toukokuu', 'kesäkuu']\n```"
      },
      {
        "question": "Mikä matriisimenetelmä palauttaa matalan kopion taulukon osasta uuteen matriisiobjektiin, joka on valittu "alusta" - "loppuun" (loppua ei sisälly), muuttamatta alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "liitos()" },
          { "answer": "split()" },
          { "answer": "slice()" },
          { "answer": "copyWithin()" }
        ],
        "answer": "slice()",
        "explanation": "Slice()-menetelmä palauttaa **uuden taulukon**, joka sisältää matalan kopion alkuperäisen taulukon osasta. Se **ei** mutatoi alkuperäistä taulukkoa.\n\n**Syntaksi:** `array.slice(startIndex, endIndex)`\n* `startIndex-indeksi ilmoittaa, jos se poimii sen. taulukon loppu.\n* `endIndex` (valinnainen): Indeksi, johon poimiminen lopetetaan (elementti `endIndex`:ssä **ei** sisälly, jos se jätetään pois, otteet taulukon loppuun asti.\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nanna numerot [1:0, []). 50];\nconsole.log('Alkuperäinen array:', numerot); // Tulos: [10, 20, 30, 40, 50]\n\nconst subArray1 = numbers.slice(1, 4 // Elementit indeksistä 1:een (mutta ei sisällä) hakemistoon 4,'Subray\n" // Tulos: [20, 30, 40]\n\nconst subArray2 = numbers.slice(2) // Elementit indeksistä 2 loppuun\nconsole.log('Sub-array 2:', subArray2 // Output: [30, 40, 50] /-slice.\n); elementit\nconsole.log('Alitaulukko 3:', alitaulukko3) // Lähtö: [40, 50]\n\nconsole.log('Alkuperäinen taulukko muuttumaton:', numerot // Tulos: [10, 20, 30, 40, 50]\n``");
      },
      {
        "question": "Mitä taulukkomenetelmää käytetään kahden tai useamman taulukon yhdistämiseen palauttaen uusi taulukko muuttamatta olemassa olevia taulukoita?",
        "answers": [
          { "answer": "push()" },
          { "answer": "liitty()" },
          { "answer": "concat()" },
          { "answer": "yhdistä()" }
        ],
        "answer": "concat()",
        "explanation": "Concat()-menetelmää käytetään kahden tai useamman taulukon yhdistämiseen. Se **ei** muuta olemassa olevia taulukoita, vaan palauttaa **uuden taulukon**, joka sisältää alkuperäisten taulukoiden elementit yhdistettyinä.\n\n**Esimerkki (TypeScript):**\n```typescript\nlet array1: number [], = [3]: numero [], = [3]: numero [], = 3 numero [4, 5];\nlet array3: number[] = [6, 7, 8];\n\nconsole.log('Matriisi 1:', array1);\nconsole.log('Matriisi 2:', array2);\n\nconst newArray = array1.concat(matriisi2, array3 10);\n\nconsole.log('Concatenated new array:', newArray // Tulostus: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconsole.log('Alkuperäinen taulukko 1 muuttamaton:', Output2: [ / , taulukko 1); 3]\nconsole.log('Alkuperäinen matriisi 2 muuttamaton:', array2); // Lähtö: [4, 5]\n```\nVoit välittää myös yksittäisiä arvoja `concat()`-funktiolle, ei vain taulukoita."
      },
      {
        "question": "Mikä taulukkomenetelmä luo ja palauttaa uuden merkkijonon yhdistämällä kaikki taulukon elementit pilkuilla tai määritetyllä erotinmerkkijonolla erotettuna?",
        "answers": [
          { "answer": "toString()" },
          { "answer": "concat()" },
          { "answer": "liitty()" },
          { "answer": "split()" }
        ],
        "answer": "liity()",
        "explanation": "Join()-menetelmä luo ja palauttaa **uuden merkkijonon** ketjuttamalla kaikki taulukon elementit. Se **ei** mutatoi alkuperäistä taulukkoa. Voit määrittää erotinmerkkijonon; jos se jätetään pois, oletusarvoisesti käytetään pilkkua (`,`).\n\n**Syntax.\ntorray)**n` (TypeScript):**\n```typescript\nlet elementit: (merkkijono | numero)[] = ['Tuli', 'Ilma', 'Vesi', 2024];\nconsole.log('Alkuperäinen array:', elementit);\n\nconst joinedString1 = elementit //joinfa(); (pilkku)\nconsole.log('Joined with comma:', joinedString1 // Output: 'Fire,Air,Water,2024'\n\nconst joinedString2 = elements.join(' - ' // Mukautettu erotin\nkonsoli.log:'Joining'); Tulos: 'Fire - Air - Water - 2024'\n\nconst joinedString3 = elements.join('') // Ei erotinta (katenoi suoraan)\nconsole.log('Liitetty ilman erotinta:', joinedString3); 'FireAirWater2024'\n\nconsole.log('Alkuperäinen taulukko muuttumaton:', elementit);\n```"
      },
      {
        "question": "Mikä matriisimenetelmä suorittaa määritetyn funktion kerran kullekin taulukon elementille luomatta uutta taulukkoa tai palauttamatta itse mitään merkityksellistä arvoa (se palauttaa "undefined")?",
        "answers": [
          { "answer": "kartta()" },
          { "answer": "forEach()" },
          { "answer": "suodatin()" },
          { "answer": "vähennä()" }
        ],
        "answer": "forEach()",
        "explanation": "ForEach()"-menetelmä suorittaa palautetun takaisinkutsutoiminnon kerran kullekin taulukon elementille nousevassa järjestyksessä. Se **ei** mutatoi taulukkoa, jossa sitä kutsutaan (vaikka takaisinkutsufunktio itse saattaa). ForEach() palauttaa aina "undefined" eikä ole ketjutettavissa tavalla "map()" tai "map()" ovat.\n\n**Syntaksi:** `array.forEach((elementti, indeksi, array) => { /* ... */ })`\n\n**Esimerkki (TypeScript):**\n```typescript\nlet names: string[] = ['Alice', 'Bob', 'Charlncon']", names);\n\nlet concatenatedNames = '';\nconst returnValue = names.forEach((nimi, indeksi) => {\n console.log(`Käsittelyssä ${name} indeksissä ${index}`);\n concatenatedNames += nimi + (indeksi < nimet.length", \ ' ); / ' / ? eksplisiittinen paluuarvo takaisinkutsusta, joka tarvitaan forEachin tarkoitukseen\n});\n\nconsole.log('Paluuarvo forEach:', returnValue) // Tulos: undefined\nconsole.log('Concatenated Names:', concatenatedNames // Output: 'Alice, Bob,'Charlieginal. unchanged:', names);\n```\n`forEach()` käytetään ensisijaisesti sen sivuvaikutuksiin (esim. kirjautuminen konsoliin, ulkoisten muuttujien muokkaaminen, DOM-manipulaatio)."
      },
      {
        "question": "Mikä matriisimenetelmä luo uuden taulukon, joka on täytetty tarjotun funktion kutsun tuloksilla jokaisessa kutsuvan taulukon elementissä mutaatiota alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "forEach()" },
          { "answer": "liitos()" },
          { "answer": "kartta()" },
          { "answer": "vähennä()" }
        ],
        "answer": "kartta()",
        "explanation": "`map()`-menetelmä luo **uuden taulukon** kutsumalla tarjotun funktion jokaiselle alkuperäisen taulukon elementille. Tämän funktion palautusarvo jokaiselle elementille tulee elementiksi uudessa taulukossa. Se **ei** mutatoi alkuperäistä taulukkoa.\n\n**Syntaksi:** `newArray = array. })`\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nanna numerot: numero[] = [1, 2, 3, 4, 5];\nconsole.log('Alkuperäinen array:', numerot);\n\nconst doubledNumbers: number[] = numbers.map =>(n\n return) # numbers.map(num => ({ arvo: num, isEven: num % 2 === 0 }));\nconsole.log('Mapped to objects:', numberObjects);\n// Tulos: \n// [ \n// { arvo: 1, isEven: false }, ... ]\n```\n`map()` on erittäin hyödyllinen tietojen muuntamiseksi muodosta toiseen."
      },
      {
        "question": "Mikä matriisimenetelmä luo uuden taulukon, jossa on kaikki elementit, jotka läpäisevät toimitetun takaisinkutsun suorittaman testin mutaatiota alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "etsi()" },
          { "answer": "jotkut()" },
          { "answer": "kartta()" },
          { "answer": "suodatin()" }
        ],
        "answer": "suodatin()",
        "explanation": "Filter()"-menetelmä luo **uuden taulukon**, joka sisältää kaikki alkuperäisen taulukon elementit, joille annettu takaisinkutsufunktio palauttaa arvon "true" (tai totuusarvon). Se **ei** muunna alkuperäistä taulukkoa.\n\n**Syntaksi:** `newArray = array.filter() = true, indeksi * / array/ return })`\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nanna numerot: numero[] = [10, 25, 8, 42, 15, 30];\nconsole.log('Alkuperäinen taulukko:', numerot);\n\nconst parillinen numero === 0; // Säilytä elementti, jos se on parillinen\n});\n\nconsole.log('Suodatettu (parillinen) array:', jopaNumbers); 30]\n\nkäyttöliittymä Tuote { nimi: merkkijono: numero }\nconst products: Product[] = [{nimi: 'A', hinta: 50}, {nimi: 'C', hinta: 75}];\nconst kallisTuotteet. 100);\nconsole.log('Kallistuotteet:', kalliit Tuotteet // Tulos: [{nimi: 'B', hinta: 150}]\n```"
      },
      {
        "question": "Mikä matriisimenetelmä suorittaa 'vähennys'-toiminnon taulukon jokaisessa elementissä, jolloin tuloksena on yksi tulosarvo (esim. summa, litistetty taulukko tai ryhmitelty objekti)?",
        "answers": [
          { "answer": "forEach()" },
          { "answer": "kartta()" },
          { "answer": "reduce()" },
          { "answer": "aggregate()" }
        ],
        "answer": "vähennä()",
        "explanation": "Reduce()-menetelmä käyttää 'reducer'-funktiota akkua ja taulukon jokaista elementtiä vastaan ​​(vasemmalta oikealle) pienentääkseen sen **yhdeksi lähtöarvoksi**. Se **ei** mutatoi alkuperäistä taulukkoa.\n\n**Syntaksi:** {array.reduce*, current /dex array)In,(> return newAccumulator */ }, originalValue)`\n* `akku`: arvo, joka on saatu takaisinkutsun edellisestä kutsusta, tai `initialValue`, jos se annetaan ensimmäiselle kutsulle.\n* `currentValue`: Nykyinen elementti, jota käsitellään taulukossa.\n* `initialValue to use-argumentti, jos ensimmäinen kutsu: ei ensimmäisenä takaisinkutsuna `initialValue` toimitetaan, taulukon ensimmäistä elementtiä käytetään alustavana akkuarvona, ja iterointi alkaa toisesta elementistä.\n\n**Esimerkki (TypeScript):**\n```typescript\nlet numbers: number[] = [1, 2, 3, 4, 5];\n:\n"Original numbers/", Lukujen summaus\nconst summa: numero = numerot.reduce((akku, nykyinen arvo) => {\n console.log(`Acc: ${acumulator}, Current: ${currentValue}`);\n return akku + nykyinen arvo;\n}, 0\/alkuarvo\n"sum."; Tulos: 15\n\n// Matriisitaulukon tasoitus\nanna arrayOfArrays: numero[][] = [[1, 2], [3, 4], [5]];\nconst litteä: numero[] = arrayOfArrays.reduce((acc, curr) => accr.con []);\nconsole.log('Listetty:', litteä) // Tulos: [1, 2, 3, 4, 5]\n\nconsole.log('Alkuperäinen taulukko muuttumaton:', numerot);\n```"
      },
      {
        "question": "Mikä matriisimenetelmä palauttaa annetun taulukon ensimmäisen elementin, joka täyttää tarjotun testausfunktion? Jos mitkään arvot eivät täytä testausfunktiota, palautetaan "undefined".",
        "answers": [
          { "answer": "suodatin()" },
          { "answer": "findIndex()" },
          { "answer": "etsi()" },
          { "answer": "jotkut()" }
        ],
        "answer": "etsi()",
        "explanation": "Find()"-menetelmä palauttaa **ensimmäisen elementin** taulukossa, joka täyttää tarjotun testaustoiminnon (takaisinkutsun). Jos mikään elementti ei täytä ehtoa, "find()" palauttaa "undefined". Se **ei** muunna alkuperäistä taulukkoa.\n\n**d elementy = array:**, `d elementy = array:** , ` /* palauttaa tosi, jos elementti vastaa arvoa */ })`\n\n**Esimerkki (TypeScript):**\n```typescript\ninterface User { id: number: ikä: numero }\nsalli käyttäjät: User[] = [\n { id: 1, name: 'Liisa', ikä: \n :" :" } Tulos: { id: 2, nimi: 'Bob', ikä: 25 }\n\nconst firstUserAge30 = users.find(user => user.age === 30);\nconsole.log('Ensimmäinen käyttäjä 30-vuotiaana:', firstUserAge30 /:/ Output: { . \ : 30 , \: : 1 , ice age30); }\n\nconst userEve = users.find(user => user.name === 'Eve');\nconsole.log('Found Eve:', userEve // ​​Tulos: undefined\n```");
      },
      {
        "question": "Mikä matriisimenetelmä palauttaa testin läpäisevän taulukon ensimmäisen elementin indeksin (toimitettuna funktiona)? Jos mikään elementti ei läpäise testiä, se palauttaa -1.",
        "answers": [
          { "answer": "indexOf()" },
          { "answer": "findIndex()" },
          { "answer": "etsi()" },
          { "answer": "lastIndexOf()" }
        ],
        "answer": "findIndex()",
        "explanation": "FindIndex()"-menetelmä palauttaa **ensimmäisen elementin** **indeksin** taulukossa, joka täyttää tarjotun testausfunktion (takaisinkutsun). Jos mikään elementti ei täytä ehtoa, `findIndex()` palauttaa arvon -1. Se **ei** muunna alkuperäistä taulukkoa. array.findIndex((elementti, indeksi, array) => { /* palauttaa true, jos elementti vastaa */ })`\n\n**Esimerkki (TypeScript):**\n```typescript\nlet numbers: number[] = [5, 12, 8, 130, 44];\n\nconst isSuuriNumber0 => elementti >con number;0; indexLargeNumber = numbers.findIndex(isLargeNumber);\nconsole.log('Ensimmäisen suuren luvun indeksi:', indexLargeNumber) // Tulos: 3 (koska 130 on indeksissä 3)\n\nconst isNegativeNumber = (elementti: numero) =>N indeksi = 0; numbers.findIndex(isNegativeNumber);\nconsole.log('Ensimmäisen negatiivisen luvun indeksi:', indexNegativeNumber // Tulos: -1 (ei negatiivisia lukuja)\n```"
      },
      {
        "question": "Mikä taulukkomenetelmä testaa, läpäiseekö vähintään yksi taulukon elementti tarjotun funktion suorittaman testin ja palauttaa loogisen arvon?",
        "answers": [
          { "answer": "jokainen()" },
          { "answer": "sisältää()" },
          { "answer": "jotkut()" },
          { "answer": "etsi()" }
        ],
        "answer": "jotkut()",
        "explanation": "Some()"-menetelmä testaa, läpäiseekö **ainakin yksi taulukon elementti** toimitetun takaisinkutsun suorittaman testin. Se palauttaa arvon "true", jos takaisinkutsufunktio palauttaa totuudenmukaisen arvon mille tahansa taulukon elementille; muussa tapauksessa se palauttaa "false". Se **ei** mutatoi alkuperäistä taulukkoa heti, kun se löytää sen. Se lopettaa sen elementti.\n\n**Syntaksi:** `booleanResult = array.some((elementti, indeksi, array) => { /* palauttaa tosi tai epätosi */ })`\n\n**Esimerkki (TypeScript):**\n```typescript\nsalpaa numerot: numero[] = [1, 3, 5, \numberst]; numbers.some(num => num % 2 === 0);\nconsole.log('On vähintään yksi parillinen luku:', hasParillinen luku); hasNegativeNumber); // Tulos: false\n```"
      },
      {
        "question": "Mikä taulukkomenetelmä testaa, läpäisevätkö kaikki taulukon elementit tarjotun funktion suorittaman testin ja palauttavat loogisen arvon?",
        "answers": [
          { "answer": "jotkut()" },
          { "answer": "jokainen()" },
          { "answer": "suodatin()" },
          { "answer": "assertAll()" }
        ],
        "answer": "jokainen()",
        "explanation": "Kaikki()"-menetelmä testaa, läpäisevätkö taulukon **kaikki elementit** toimitetun takaisinkutsun suorittaman testin. Se palauttaa "true", jos takaisinkutsufunktio palauttaa totuudenmukaisen arvon kaikille elementeille; muussa tapauksessa se palauttaa "false". Se **ei** mutatoi alkuperäistä taulukkoa. Se lopettaa takaisinkutsuelementin iteroinnin heti, kun se löytää virheellisen palautuksen. arvo.\n\n**Syntaksi:** `booleanResult = array.every((elementti, indeksi, array) => { /* palauttaa tosi tai epätosi */ })`\n\n**Esimerkki (TypeScript):**\n```typescript\nlet numbers1: number[] = [2, 4, 6, n. 1 = n 8]; => num % 2 === 0);\nconsole.log('Kaikki luvut luvuissa1 ovat parillisia:', allAreEven1 // Tulos: true\n\nlet numbers2: number[] = [2, 4, 7, 8];\nconst allAreEven2 = numerot2.ever(num) 0);\nconsole.log('Kaikki luvut numeroissa2 ovat parillisia:', allAreEven2 // Tulos: false (7:n takia)\n```");
      },
      {
        "question": "Mikä ES2019:ssä käyttöön otettu matriisimenetelmä luo uuden taulukon, jossa kaikki alitaulukon elementit on ketjutettu siihen rekursiivisesti tiettyyn syvyyteen asti?",
        "answers": [
          { "answer": "flatten()" },
          { "answer": "flat()" },
          { "answer": "concatAll()" },
          { "answer": "reduce(arr => arr.concat())" }
        ],
        "answer": "tasainen()",
        "explanation": ""flat()"-menetelmä luo **uuden taulukon**, johon kaikki alitaulukon elementit ketjutetaan rekursiivisesti tiettyyn syvyyteen asti. Se **ei** mutatoi alkuperäistä taulukkoa.\n\n**Syntaksi:** `newArray = array.flat(depth)`\n (* `syvyyden tulee määrittää syvyysrakenne): flattened on 1.\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nlet nestedArray: (numero | numero[])[] = [1, 2, [3, 4]];\nconst flat1 = nestedArray.flat( // Oletussyvyys on 1\nth1); Tulos: [1, 2, 3, 4]\n\nsalpaa syvänestetyt taulukko 2, 3, [4, 5], 6]\n\nconst flatInfinity = deeplyNestedArray.flat(Infinity) // Tasaa kaikki tasot\nconsole.log('Flat (depth Infinity):', flatInfinity // Tulos: [1, 2, 3, 4],` 5);
      },
      {
        "question": "Mikä matriisimenetelmä kartoittaa ensin kunkin elementin kuvausfunktiolla ja tasoittaa sitten tuloksen uudeksi taulukoksi? Se on identtinen "a.map(...args).flat()" kanssa, mutta usein tehokkaampi.",
        "answers": [
          { "answer": "mapAndFlat()" },
          { "answer": "reduceMap()" },
          { "answer": "flatMap()" },
          { "answer": "transform()" }
        ],
        "answer": "flatMap()",
        "explanation": ""flatMap()"-menetelmä kartoittaa ensin jokaisen elementin kuvausfunktiolla ja tasoittaa sitten tuloksen **uudeksi taulukoksi**. Se vastaa toiminnallisesti "array.map(callback).flat(1)", mutta "flatMap()" voi olla tehokkaampi, koska se ei luo toiminnosta flattening** ennen kuin se ei tee flattening-toimintoa. muuttaa alkuperäistä taulukkoa.\n\n**Syntaksi:** `newArray = array.flatMap((elementti, index, array) => { /* return element or arrayOfElements */ })`\n Takaisinkutsutoiminto voi palauttaa joko yhden elementin tai joukon elementtejä. Nämä palautetut taulukot litistetään sitten yhdellä tasolla:\n``script. fraasit: string[] = ['hei maailma', 'hyvästi kuu'];\n\n// Jaa jokainen lause sanoiksi ja litistä sitten sanat: string[] = lauseet.flatMap(fraasi => lause.split(' '));\nconsole.log('Words:"hello",); 'maailma', 'näkemiin', 'kuu']\n\n// Esimerkki: kartta ja ehdollisesti sisällyttää elementit\nsalpaa numerot: numero[] = [1, 2, 3, 4];\nconst processedNumbers: numero[] = numerot.flatMap(num => \n = num % ] : 1, n 0 % 2 ? // Jos parillinen, sisällytä numero ja num*10, jos pariton, sisällytä mitään\n);\nconsole.log('Käsitellyt numerot:', ProcesedNumbers // Tulos: [2, 20, 4, 40]\n```";
      },
      {
        "question": "Millä ES2022-taulukkomenetelmällä voit käyttää elementtiä negatiivisen indeksin avulla laskeakseen taulukon lopusta, kuten Python tai Ruby?",
        "answers": [
          { "answer": "getItem()" },
          { "answer": "at()" },
          { "answer": "viimeinen()" },
          { "answer": "nth()" }
        ],
        "answer": "at()",
        "explanation": "ES2022:ssa käyttöön otettu at()-menetelmä ottaa kokonaisluvun arvon ja palauttaa alkion kyseisellä indeksillä sallien positiiviset ja **negatiiviset kokonaisluvut**. Negatiiviset kokonaisluvut lasketaan takaisin taulukon viimeisestä kohteesta. Se **ei** muunna alkuperäistä taulukkoa.\n:**`Synta =x array.at(index)`\n\n**Esimerkki (TypeScript):**\n```konekirjoitus\nanna kohteet: string[] = ['a', 'b', 'c', 'd', 'e'];\n\nconsole.log('Elementti hakemistossa 2: Out:", items. 'c'\nconsole.log('Elementti hakemistossa -1 (viimeinen elementti):', items.at(-1)); // Lähtö: 'e'\nconsole.log('Elementti indeksissä -2 (toisesta viimeiseen):', items.at(-2) // Tulos: 'd'\n"s:n \n"s); items.at(10)); // Tulos: undefined\n\n// Vertaa hakasulkumerkinnällä:\n// console.log(items[-1]) // Tulos: undefined (hakasulkumerkintä ei tue negatiivisia indeksejä suoraan tällä tavalla)\n```\n`at()` tarjoaa helpomman tavan laskea elementtejä ilman taulukkoa. offset."
      },
      {
        "question": "Mikä ES2023-taulukkomenetelmä palauttaa uuden taulukon, jonka elementit ovat käänteisessä järjestyksessä mutaatiota alkuperäistä taulukkoa?",
        "answers": [
          { "answer": "reverseImmutable()" },
          { "answer": "käänteinen()" },
          { "answer": "toReversed()" },
          { "answer": "createReversed()" }
        ],
        "answer": "toReversed()",
        "explanation": "ES2023:ssa esitelty `toReversed()-menetelmä on `reverse()-menetelmän kopioiva (muuttumaton) vastine. Se palauttaa **uuden taulukon**, jonka elementit ovat käänteisessä järjestyksessä, jättäen alkuperäisen taulukon **muuttamattomaksi**.\n\n**Esimerkki (alkuperäinen kirjoitustapa):**\n:``st]skripti:**n\n:`st:** 2, 3, 4, 5];\nconsole.log('Alkuperäinen taulukko:', alkuperäinenMatriisi); 2, 1]\nconsole.log('Original array unchanged:', originalArray // Tulostus: [1, 2, 3, 4, 5]\n\n// Kontrasti mutaatioreverse() -metodin kanssa:\n// alkuperäinenArray.reverse(\n// console.log() [5, 4, 3, 2, 1]\n```\n`toReversed()` on hyödyllinen, kun tarvitset taulukon käänteisen version, mutta haluat säilyttää alkuperäisen taulukon."
      }
    ]
  },
  {
    "name": "TypeScript Array Methods with Promises",
    "image": "https://images.unsplash.com/photo-1612838320302-4b3b3b3b3b3b",
    "questions": [
      {
        "question": "Sinulla on joukko käyttäjätunnuksia: `[101, 102, 103]`. Sinulla on myös asynkroninen funktio `fetchUserName(id: number): Promise<string>`, joka palauttaa lupauksen ratkaisun käyttäjän nimeen. Kuinka voit luoda taulukon, jossa jokainen elementti on vastaava käyttäjätunnus?"
        "answers": [
          { "answer": "userIds.forEach(id => fetchUserName(id));" },
          { "answer": "userIds.map(id => fetchUserName(id));" },
          { "answer": "userIds.filter(id => fetchUserName(id));" },
          { "answer": "userIds.find(id => fetchUserName(id));" }
        ],
        "answer": "userIds.map(id => fetchUserName(id));",
        "explanation": "Map()-metodi on täydellinen tähän! \n\n* **Mitä `map() tekee:** Se luo **uuden taulukon** kutsumalla funktion jokaiselle alkuperäisen taulukon elementille. Tämän funktion palautusarvosta tulee elementti uudessa taulukossa.\n* **Tässä tapauksessa:** Funktio `id kutsutaan => foridtch``id. `fetchUserName(id)` palauttaa `Promise<merkkijono>`, `map()`-metodi kerää nämä lupaukset uuteen taulukkoon.\n\nJoten `userIds.map(id => fetchUserName(id))` johtaa taulukkoon, kuten `[Promise\Tomise<saatavastring>,].`Promise<getstring>,]. todellisia käyttäjänimiä** (lupausten ratkaistuja arvoja), käytät yleensä `Promise.all()` seuraavasti:\n```typescript\nasync-funktio getUserNames(userIds: number[]): Promise<merkkijono[]> {\n const userNamePromises = userIds.map(id => userIds.map(id => userIds.map(id => userIds.map(id => userIds). id 101, Promise for id 102, ...]\n\n const names = odota Promise.all(userNamePromises);\n // nimet ovat ['Nimi 101', 'Nimi 102', ...]\n palauttaa nimet;\n}\n````\n)' jokaiselle funktiolle ei vain suoriteta. uusi tulosjoukko.\n* `filter()` käytetään kohteiden valitsemiseen ehdon perusteella, ei niiden muuntamiseen.\n* `find()` palauttaa ensimmäisen kohteen, joka vastaa ehtoa."
      },
      {
        "question": "Jos käytät async/await-komentoa forEach-silmukassa kohteiden käsittelemiseen (esim. items.forEach(async item => { await asyncOperation(item); })'), mitä on tärkeää muistaa siitä, kuinka `forEach' käsittelee näitä asynkronisia toimintoja?"
        "answers": [
          {
            "answer": ""forEach" pysähtyy ja odottaa jokaisen "asyncOperation" -toiminnon valmistumista ennen seuraavan aloittamista."
          },
          {
            "answer": "forEach suorittaa kaikki "asyncOperation"-kutsut samanaikaisesti ja odottaa niiden kaikkien päättymistä ennen kuin "forEach"-silmukka itse päättyy."
          },
          {
            "answer": "forEach aloittaa kaikki asyncOperation-kutsut, mutta EI odota niiden valmistumista. ForEach-silmukka päättyy ennen kuin sen sisällä olevat async-toiminnot on välttämättä suoritettu."
          },
          {
            "answer": "Async/await-parametrin käyttäminen forEach:n sisällä ei ole sallittua TypeScriptissä ja aiheuttaa käännösvirheen."
          }
        ],
        "answer": "forEach aloittaa kaikki "asyncOperation"-kutsut, mutta EI odota niiden valmistumista. ForEach-silmukka päättyy ennen kuin sen sisällä olevat async-toiminnot on suoritettu.",
        "explanation": "Tämä on yleinen hämmennys aloittelijoille! 🤔\n\n* Itse `forEach`-metodi on **synkroninen**. Se toistuu taulukon läpi ja kutsuu kullekin kohteelle toimitetun takaisinkutsun toiminnon.\n* Jos takaisinsoittotoimintosi on `async` (esim. `sync itemiyn(>ccaperitemiyn(async itemiyn(>);) }`), `forEach` *kutsuu* tätä asynkronointifunktiota jokaiselle kohteelle, mutta se **ei odota**, että async-funktion palauttama Promise ratkeaa.\n* Tämä tarkoittaa, että `forEach' suorittaa yleensä loppuun hyvin nopeasti, kun kaikki asynkroniset toiminnot on käynnistetty, mutta nämä toiminnot jatkuvat \`r`ach:n taustalla**. 'Okei, aloita tämä tehtävä!' jokaiselle kohteelle ja siirtyy välittömästi seuraavaan odottamatta nykyisen tehtävän päättymistä.\n\n**Jos sinun on odotettava jokaisen asynkronointitoiminnon valmistumista peräkkäin, sinun tulee käyttää tavallista `for...of`-silmukkaa:**\n```typescript\nasync-funktio processAllItemsSequentially:<T:[],: => Lupa<void>) {\n console.log('Aloittaa peräkkäisen käsittelyn...');\n for (const item of items) {\n console.log(`Käsittelykohde: ${item}`);\n odota asyncOperation(item // Silmukka PYSÄYTYY tähän, kunnes tämä toiminto on suoritettu loppuun.logn:Fsinole); ${item}`);\n }\n console.log('Kaikki kohteet käsitelty peräkkäin.');\n}\n```\n\n**Jos haluat suorittaa ne samanaikaisesti ja odottaa kaikkien valmistumista, käytä `map` ja `Promise.all()` (kuten edellisen kysymyksen selityksessä näkyy).**"
      },
      {
        "question": "Sinulla on joukko tuotetunnuksia: `[1, 2, 3, 4]`. Haluat suodattaa tämän taulukon saadaksesi vain varastossa olevien tuotteiden tunnukset. Sinulla on asynkronointifunktio `isProductInStock(id: numero): Promise <boolean>`. Miksi et voi käyttää suoraan `productIdynsciwatter.fill isProductInStock(id))" saadaksesi oikean tuloksen?",
        "answers": [
          {
            "answer": "Koska "suodatinta" ei voi käyttää "async/await"-syntaksin kanssa ollenkaan."
          },
          {
            "answer": "Koska `filter` odottaa takaisinkutsun funktionsa palauttavan suoran `boolean`-arvon, mutta `async`-funktio palauttaa `Promise<looga>`."
          },
          {
            "answer": "Koska "isProductInStock" saattaa aiheuttaa virheen, ja "filter" ei käsittele lupausten hylkäämistä."
          },
          {
            "answer": "Koska `filter` muokkaa alkuperäistä taulukkoa, mikä ei ole turvallista asynkronisten toimintojen kanssa."
          }
        ],
        "answer": "Koska `filter` odottaa takaisinkutsun funktionsa palauttavan suoran `boolean`-arvon, mutta `async`-funktio palauttaa `Promise<looga>`.",
        "explanation": "Filter()-menetelmä toimii kutsumalla takaisinsoittofunktiota (kutsutaan usein predikaatiksi) jokaiselle taulukon elementille. \n* Jos takaisinkutsu palauttaa arvon "true" (synkronisesti), elementti sisällytetään uuteen suodatettuun taulukkoon.\n* Jos takaisinsoitto palauttaa "false", elementti on \ntakaisinsoitto\nsynkronisesti. funktion ** täytyy palauttaa synkroninen looginen arvo** (tosi tai epätosi).\n\nKun kirjoitat "async id => await isProductInStock(id)", tämä "async"-funktio *aina* palauttaa "Promise", vaikka `isProductInStock,``truse`s to(id). `async`-funktio itse kääriä sen `Promise<boolean>`.\n\nJavaScriptissa (ja TypeScriptissä) `Promise`-objekti, kun se arvioidaan loogisessa kontekstissa (kuten `filter` odottaa), katsotaan **'truthy'**. tuloksessa, koska jokainen puhelu palauttaa lupauksen ja jokainen lupaus on totta.\n\n**Kuinka suodatat oikein asynkronisella predikaatilla:**\nTarvitset monivaiheisen prosessin:\n1 **Map to Promises of Checks:** Käytä "kartta" kutsuaksesi async-predikaattia jokaiselle kohteelle, ja se on usein hyödyllinen kohteen boole ```typescript\n const stockCheckPromises = productIds.map(async (id) => {\n const isInStock = await isProductInStock(id);\n return { id: id, inStock: isInStock };\n });\n `````s**\n2 for all odottaa, että kaikki nämä lupaukset ratkeavat.\n ```typescript\n const stockStatusesWithIds = odota Promise.all(stockCheckPromises);\n // Esimerkki: [{id: 1, inStock: true}, {id: 2, inStock: false}, ...]\n* suodata nämä tulokset ja pura sitten alkuperäiset tuotteet.\n ```typescript\n const inStockProductsInfo = stockStatusesWithIds.filter(itemStatus => itemStatus.inStock);\n const inStockProductIds = inStockProductsInfo.map(info); 4]\n ```\nTämä on yleinen malli, kun käsitellään asynkronisia suodatusehtoja."
      },
      {
        "question": "Sinulla on joukko tehtäviä, joissa jokainen tehtävä on funktio, joka palauttaa lupauksen: `type Task = () => Lupaus<void>; const tehtävät: Task[] = [asyncTask1, asyncTask2, asyncTask3];`. Kuinka voit suorittaa nämä tehtävät peräkkäin), ennen kuin aloitat jokaista tehtävää käyttäen, ennen kuin aloitetaan?
        "answers": [
          { "answer": "tasks.forEach(async task => odota tehtävää());" },
          { "answer": "Promise.all(tasks.map(tehtävä => tehtävä()));" },
          {
            "answer": "tasks.reduce(async (promiseChain, currentTask) => { odota lupausketjua; return currentTask(); }, Promise.resolve());"
          },
          {
            "answer": "for (tehtävien jatkuva tehtävä) { task(); } // Tämä ei odota"
          }
        ],
        "answer": "tasks.reduce(async (promiseChain, currentTask) => { odota lupausketjua; return currentTask(); }, Promise.resolve());",
        "explanation": "Asynkronisten tehtävien suorittamiseksi peräkkäin taulukosta, `reduce()-menetelmä on tehokas työkalu. ⚙️\n\n* **Mitä `reduce()` tekee:** Se iteroituu taulukon yli ja 'pienentää' sen yhdeksi kertyneeksi arvoksi. Tässä tapauksessa ketjun alku, loppukertymäarvomme on*. **Kuinka se toimii peräkkäisille lupauksille:**\n * `Reduce`-menetelmällä on kaksi pääargumenttia: \n 1. Takaisinkutsutoiminto: `async (akku, currentTask) => { /* ... */ }`\n 2. Alkuarvo akulle: `Promise. `reduce` takaisinkutsun:\n * `akku` (jota kutsuimme selvyyden vuoksi promiseChainiksi): Tämä on *edellisen* vaiheen Promise (tai alkuperäisen `Promise.resolve()`).\n * `currentTask`: Tämä on nykyinen tehtäväfunktio `tasks **`awawa. ketjun edellinen tehtävä loppuun.\n * `return currentTask();`: Suoritamme sitten `currentTask()-funktion ja palautamme sen luoman Promisen. Tästä uudesta Promisesta tulee `promiseChain` (akku) seuraavaa iteraatiota varten.\n\n**Takaisinkutsufunktion on sallittava `reduce`sync:n käyttö. it.**\n\n**Täydellinen esimerkki:**\n```typescript\nasync-funktio runTasksSequentially(tehtävät: Array<() => Promise<mikä tahansa>>) {\n console.log('Tehtävien aloitus peräkkäin...');\n odota tehtävät.reduce(async (previousPromise)> edellinen {\async edellinen suoritettava tehtävä\n console.log('Suoritetaan seuraavaa tehtävää...');\n return nextTask(); => new Promise(resolve => setTimeout(() => {\n console.log(`Tehtävä ${id} päättyi ${ms}ms`);\n ratkaista(undefined);\n}, ms));\n\nconst myTasks: Array<() => Lupaus<kaikki>> = [\n ()" => viive, (1) viive(500, 'B'),\n () => viive(800, 'C'),\n];\n\n// suoritaTasksSequentially(myTasks);\n// Tulos näyttää A:n viimeistelyssä, sitten B:n ja sitten C:n.\n```\nTämä varmistaa, että tehtävä A päättyy ennen kuin tehtävä B alkaa ja Why ennen tehtävän B alkua, Wh vaihtoehdot eivät ole ihanteellisia tähän tiettyyn *peräkkäiseen* vaatimukseen:**\n* `tasks.forEach(async task => await task());`: Kuten aiemmin selitettiin, `forEach` ei odota `wait`-toimintoa takaisinkutsun sisällä. Se käynnistäisi kaikki tehtävät lähes samaan aikaan (samanaikaisesti).\n* `Task. tehtävät samanaikaisesti (rinnakkain) ja odottaa niiden kaikkien valmistumista.\n* `for (const task of task) { task( }`): Tämä myös käynnistää kaikki tehtävät, mutta ei käytä "wait"-komentoa, joten ne suoritetaan samanaikaisesti odottamatta valmistumista.
      },
      {
        "question": "Sinulla on joukko kohteita ja asynkroninen toiminto `checkCondition(item): Promise<boolean>`. Haluat löytää taulukosta **ensimmäisen kohteen**, joka täyttää asynkronisen ehdon. Mikä lähestymistapa on sopivin tähän ja varmistaa, että lopetat tarpeettomien kohteiden käsittelyn, kun vastaavuus löytyy?",
        "answers": [
          {
            "answer": "Käytä tuloksissa `items.map(async item => ({ item, matches: await checkCondition(item) }))`, sitten `Promise.all()`, sitten `find()`. Tämä on tehokasta."
          },
          {
            "answer": "Käytä "for...of" -silmukkaa ja "wait checkCondition(item)" sisällä. Jos ehto täyttyy, palauta kohde välittömästi. Tämä lopettaa tarpeettomien kohteiden käsittelyn."
          },
          {
            "answer": "Käytä `items.find(async item => await checkCondition(item))`. Tämä toimii suoraan ja on tehokasta."
          },
          {
            "answer": "Käytä `Promise.race(items.map(async item => { if (wait checkCondition(item)) return item; muuten heittäkää uusi Error('Ei vastaavuutta'); }))".
          }
        ],
        "answer": "Käytä "for...of" -silmukkaa ja "wait checkCondition(item)" sisällä. Jos ehto täyttyy, palauta kohde välittömästi. Tämä lopettaa tarpeettomien kohteiden käsittelyn.",
        "explanation": "Kun haluat löytää *ensimmäisen* kohteen, joka täyttää asynkronointiehdon, tehokkuus on avainasemassa – haluat lopettaa tarkistamisen heti, kun löydät osuman. 🕵️‍♀️\n\n**For...of-silmukka, jossa on `wait`, on sopivin ja yksinkertaisin lähestymistapa\nas``type script:**\n`ync. findFirstMatchingItem<T>(\n kohteet: T[], \n asyncPredicate: (item: T) => Promise<boolean>\n): Lupa<T | undefined> {\n for (const item of items) {\n // Odota, että nykyisen kohteen ehto tarkistetaan\n (odottaa n/yntem; Palaa heti ja lopeta silmukka.\n }\n }\n palauta määrittelemätön // Kaikki kohteet tarkistuksen jälkeen ei löytynyt. 'file2.txt', 'largeFile.dat', 'another.txt'];\n// const firstLargeFile = odota findFirstMatchingItem(files, isLargeFile);\n// Jos 'largeFile.dat' on ensimmäinen iso tiedosto,\``t't checked*.n'n. **Miksi se on hyvä:** Odottaa jokaista asyncPredicate-kutsua *peräkkäin* Heti kun yksi "asyncPredicate(item)"-parametri ratkaisee "true", funktio palauttaa välittömästi kyseisen "kohteen" ja lopettaa iteroinnin muun taulukon läpi, koska se ei ole tehokasta kohteet.\n\n**Miksi muut vaihtoehdot eivät ole niin ihanteellisia tälle tietylle 'etsi ensin ja lopeta' -skenaariolle:**\n* **Vaihtoehto A (kartta, Promise.all, sitten find):** Tämä lähestymistapa suorittaa "checkCondition"-komennon *kaikkiin* taulukon kohteihin (todennäköisesti samaan aikaan komennolla "Promise.all(map(...)") -tarkistetaan ensin taulukon ensimmäinen kohde vastaa, odotit silti, että kaikki muut asynkroniset tarkistukset valmistuvat.\n* **Vaihtoehto C (`items.find(async item => wait checkCondition(item))`):** Samanlainen kuin `filter`, `synkroninen `async`-funktio (kuten `async item => await checkCondition(item)`) palauttaa aina `Promise<boolean>`-arvon Boolean-kontekstissa mikä tahansa Promise-objekti on 'truthy'. Joten 'items.find(async...)' palauttaisi todennäköisesti vain ensimmäisen kohteen, riippumatta siitä, onko 'condition'. "tosi" tai "false".\n* **Vaihtoehto D ("Promise.race"):** "Promise.race" toteutuu heti, kun *joko* lupaus toteutuu (joko ratkaisee tai hylkää). aloittelijalle luettava kuin yksinkertainen "for...of" -silmukka tässä käyttötapauksessa.
      },
      {
        "question": "Mikä on samanaikaisessa ohjelmoinnissa "lukkosaattue" ja mitkä ovat sen ensisijaiset vaikutukset?",
        "answers": [
          {
            "answer": "Kuvio, jossa säikeet menevät tehokkaasti läpi keskenään, minimoiden kiistan."
          },
          {
            "answer": "Suorituskyvyn heikkenemisongelma, jossa useat säikeet ovat jonossa usein kilpailtua lukitusta varten, mikä johtaa liialliseen kontekstin vaihtamiseen ja suorittimen vajaakäyttöön."
          },
          {
            "answer": "Turvamekanismi, joka varmistaa, että lukot hankitaan ennalta määritetyssä, valtuutetussa järjestyksessä."
          },
          {
            "answer": "Virheenkorjaustekniikka järjestelmän sisällä tapahtuneiden lukkohankintojen ja -julkaisujen historian jäljittämiseen."
          }
        ],
        "answer": "Suorituskyvyn heikkenemisongelma, jossa useat säikeet joutuvat jonoon usein kilpailtua lukitusta varten, mikä johtaa liialliseen kontekstin vaihtamiseen ja suorittimen vajaakäyttöön."
        "explanation": "**Lukkosaattue** tapahtuu, kun lukosta käydään kovaa kiistaa, ja lukon hankinnan ajoituskäytäntö (usein FIFO) saa säikeet joutumaan jonoon. Kun säie vapauttaa lukon, tämä jonon seuraava säie saattaa saada sen välittömästi uudelleen, mikä saattaa lyhentää tilanteen ennen kuin se voi suorittaa uudelleen erittäin vaativan ajan. kuluttaa huomattavasti aikaa kontekstin vaihtamiseen sen sijaan, että tekisi hyödyllistä työtä. Järjestelmästä tulee vähemmän reagoiva, koska lukkoa pitävät säikeet tekevät niin usein lyhyissä kriittisissä osissa, ja saattueen hallinta (herätyssäikeet, kontekstin kytkimet) hallitsee Tämä on tunnettu suorituskykyongelma, etenkin vanhemmissa käyttöjärjestelmissä tai synkronointijärjestelmässä.
      },
      {
        "question": "Mikä seuraavista väittämistä kuvaa parhaiten Bloom-suodattimen käytön ensisijaista etua?",
        "answers": [
          {
            "answer": "Takaa väärien negatiivisten tulosten puuttumisen ja tarjoaa tarkan sarjan jäsentestauksen optimaalisella tilan monimutkaisuudella."
          },
          {
            "answer": "Mahdollistaa erittäin tilaa säästävän todennäköisyyspohjaisen joukon jäsenyystestauksen, sietää vääriä positiivisia tuloksia, mutta ei takaa vääriä negatiivisia."
          },
          {
            "answer": "Mahdollistaa elementtien tehokkaan haun suuresta tietojoukosta lajiteltuna."
          },
          {
            "answer": "Tarjoaa vahvan kryptografisen tiivistyksen turvalliseen tietojen tallentamiseen ja todentamiseen."
          }
        ],
        "answer": "Mahdollistaa erittäin tilaa säästävän todennäköisyyspohjaisen joukon jäsenyystestauksen, sietää vääriä positiivisia tuloksia, mutta ei takaa vääriä negatiivisia."
        "explanation": "**Bloom-suodatin** on todennäköisyyspohjainen tietorakenne, joka on erittäin tilatehokas sen testaamiseen, onko elementti joukon jäsen. \n\nPääominaisuudet:\n1. **Vääriä positiivisia vaikutuksia**: Se voi kertoa, että elementti *saattaa* olla joukossa (positiivinen tulos), mutta tämä voi olla positiivinen säätämällä väärän positiivisen koon todennäköisyys. suodatin ja hash-funktioiden määrä.\n2. **Ei vääriä negatiivisia**: Jos Bloom-suodatin sanoo, että elementti ei ole joukossa (negatiivinen tulos), se ei todellakaan ole joukossa.\n3 **Space Efficiency**: Ne käyttävät huomattavasti vähemmän muistia kuin muut datarakenteet, kuten todellisten hajautustaulukoiden tallentamiseen. ei tarvitse tallentaa.\n4. **Ei elementtien poistamista (standardi Bloom-suodatin)**: Normaalit Bloom-suodattimet eivät tue elementtien poistamista, koska bittien poistaminen voi johtaa vääriin negatiivisiin arvoihin muille elementeille.\n\nSe on ihanteellinen skenaarioihin, kuten tarkistamaan, onko käyttäjätunnus jo varattu (jos väärä positiivinen URL-osoite on hyväksytty ylimääräisen tietokannan tarkistamiseksi). uudelleenkäsittely (jälleen harvinainen väärä positiivinen voi tarkoittaa, että uudelleenindeksointi ei onnistu, mutta väärien negatiivisten tulosten puuttuminen tarkoittaa, että et vahingossa luule, ettet ole käynyt osoitteessa URL-osoitteessasi)."
      },
      {
        "kysymys": "CAP-lauseen mukaan hajautettu tietovarasto voi tarjota samanaikaisesti enintään kaksi, joista kolme takaa verkkoosion läsnäollessa?",
        "answers": [
          { "answer": "Atomuus, johdonmukaisuus, eristäminen" },
          { "answer": "Johdonmukaisuus, saatavuus, osion toleranssi" },
          { "answer": "Kestävyys, skaalautuvuus, suorituskyky" },
          { "answer": "Luottamuksellisuus, eheys, saatavuus" }
        ],
        "answer": "Johdonmukaisuus, saatavuus, osion toleranssi",
        "explanation": "**CAP-teoreema**, joka tunnetaan myös nimellä Brewerin teoreema, sanoo, että hajautetun tietovaraston on mahdotonta tarjota samanaikaisesti useampaa kuin kahta seuraavasta kolmesta takuusta:\n\n1. **Johdonmukaisuus (C)**: Jokainen luku vastaanottaa viimeisimmän kirjoituksen tai virheen. Johdonmukaisessa järjestelmässä, jos kaikki solmut lukevat samaan aikaan mistä tahansa muusta datasta. solmun tulee heijastaa tätä kirjoitusta.\n2. **Saatavuus (A)**: Jokainen pyyntö saa (ei-virhe) -vastauksen ilman takuuta siitä, että se sisältää viimeisimmän kirjoituksen. (eli verkko-osio Hajautetussa järjestelmässä verkkoosiot ovat tosiasia, joten osion sietokyky on yleensä pakollinen.\n\nKoska verkkoosiot (P) ovat yleensä väistämättömiä hajautetuissa järjestelmissä, teoreema tarkoittaa, että suunnittelijoiden on usein valittava vahvan johdonmukaisuuden (CP-järjestelmät, kuten perinteiset RDBCP-järjestelmät) tai korkean käytettävyyden välillä virhe tai aikakatkaisu joillekin pyynnöille johdonmukaisuuden varmistamiseksi, mikä uhraa saatavuuden AP-järjestelmä saattaa palauttaa vanhentuneet tiedot varmistaakseen saatavuuden, mikä uhraa vahvan johdonmukaisuuden.
      },
      {
        "question": "Mikä on 'kirjoitusesteen' ensisijainen tehtävä roskienkeräyksen (GC) yhteydessä?",
        "answers": [
          {
            "answer": "Muistin turvallisuuden lisääminen estämällä rajojen ulkopuoliset kirjoitukset taulukoihin ja puskureihin."
          },
          {
            "answer": "Loki kaikki muistin kirjoitustoiminnot virheenkorjausta ja tarkastusta varten."
          },
          {
            "answer": "Ilmoittaa roskankerääjälle osoittimen muutoksista, jotta se voi säilyttää invarianttejaan, erityisesti inkrementaalisissa, samanaikaisissa tai sukupolven GC:issä."
          },
          {
            "answer": "Laitteistomekanismi, joka suojaa vain luku -muistin segmenttejä ylikirjoitukselta."
          }
        ],
        "answer": "Ilmoittaa roskankerääjälle osoittimen muutoksista, jotta se voi säilyttää invarianttejaan, erityisesti inkrementaalisissa, samanaikaisissa tai sukupolven GC:issä."
        "explanation": "**Kirjoituseste** on pieni koodinpätkä, jonka kääntäjä tai tulkki lisää juuri ennen osoittimen (viittauksen) kirjoitusoperaatiota (esim. `obj.field = joku_toinen_obj`). Sen ensisijainen tarkoitus on ilmoittaa roskienkerääjälle (GC) tästä tietyntyyppisestä objektikaavion mutaatiosta. Tämä on erittäin tärkeää:\ener.**\n1. GC:t**: Nämä GC:t jakavat muistin sukupolviin (esimerkiksi nuoret ja vanhat, jos ne säilyvät riittävän pitkään), keräävät nuorta useammin, koska useimmat esineet kuolevat nuorena. koska koko vanhan sukupolven tällaisten osoittimien skannaus jokaisessa nuoressa kokoelmassa olisi tehotonta.\n2 **Inkrementaaliset/samanaikaiset GC:t**: Nämä GC:t suorittavat kokoelmatyötä pienin askelin tai samanaikaisesti sovellussäikeiden kanssa taukoaikojen lyhentämiseksi skannaamaton objekti, kirjoituseste varmistaa, että GC tulee tietoiseksi tästä uudesta viitteestä, joten kohdistettua objektia ei palauteta ennenaikaisesti.\n\nPohjimmiltaan kirjoitusesteet auttavat GC:tä ylläpitämään sisäisiä tietorakenteitaan (kuten "muistettuja joukkoja", jotka tallentavat alueiden tai sukupolvien välisiä osoittimia) oikein varmistaen, että kaikki objektit pysähtyvät ilman jatkuvaa skannausjaksoa.
      },
      {
        "question": "Mikä on ensisijainen ero siinä, kuinka "select()", "poll()" ja "epoll()" (tai "kqueue()") käsittelevät I/O-multipleksausta, erityisesti mitä tulee suorituskykyyn suurella määrällä tiedostokuvaajia?",
        "answers": [
          {
            "answer": "select()" ja "poll()" skaalautuvat lineaarisesti tiedostokuvausmäärien mukaan, kun taas "epoll()" tarjoaa O(1)-suorituskyvyn valmiuden tarkistamiseen riippumatta valvottujen kuvaajien lukumäärästä."
          },
          {
            "answer": "epoll()" käyttää takaisinsoittomekanismia, kun taas "select()" ja "poll()" edellyttävät aktiivista kyselyä jokaiselta tiedostokuvaajalta."
          },
          {
            "answer": "Select()" on rajoitettu FD_SETSIZE:llä, "poll()":lla ei ole kovaa rajoitusta, mutta suorituskyky heikkenee, ja "epoll()" sisältää koko kuvaajan kopioimisen ydintilaan jokaisessa kutsussa, samalla tavalla kuin "select()".
          },
          {
            "answer": ""select()" ja "poll()" edellyttävät ytimen iteroivan kaikkia valvottuja tiedostokuvauksia löytääkseen valmiit, kun taas "epoll()" ylläpitää luetteloa valmiista kuvailijoista ytimessä, jolloin käyttäjä voi hakea vain aktiiviset kuvaukset."
          }
        ],
        "answer": ""select()" ja "poll()" vaativat ytimen iteroimaan kaikki valvotut tiedostokuvaajat löytääkseen valmiit, kun taas "epoll()" ylläpitää luetteloa valmiista kuvailijoista ytimessä, jolloin käyttäjä voi hakea vain aktiiviset kuvaukset.",
        "explanation": "Ydinero on siinä, kuinka ne tunnistavat valmiit tiedostokuvaajat (FD:t) ja kuinka tämä skaalautuu:\n\n1. **`select()`**: \n * Se käyttää kiinteän kokoisia bitmaskeja (`fd_set`) edustamaan FD-joukkoa, jota seurataan. Tällä on kova raja, `FD_SET2n SIZE `4/10 `4 (tai kymmenestä 2n SIZE 10`2). kutsua, nämä bittimaskit välitetään käyttäjätilasta ydintilaan. Ydin muokkaa niitä valmiuden osoittamiseksi.\n * Ytimen täytyy iteroida kaikkien joukon FD:t (suurin numeroituun FD:hen asti) tarkistaakseen niiden tilan ja sitten iteroidaan yleensä myös maskien kautta löytääkseen valmiit FD:t.\n * Suorituskyky heikkenee vain FD-luvulla. valvottu.\n\n2. **`poll()`**: \n * Se parantaa `select()-toimintoa, koska sillä ei ole kiinteää rajaa, kuten `FD_SETSIZE`. Se vaatii `struct pollfd`-taulukon, jossa jokainen rakenne määrittää FD:n ja sen valvottavat tapahtumat.\n * Kuten `select()-kernel,` on koko pol-kernel. Ydin toistaa tämän taulukon tarkistaakseen kunkin FD:n tilan.\n * Suorituskyky heikkenee lineaarisesti (O(N)) valvottavien FD:iden määrällä.\n\n3 **`epoll()` (Linux-kohtainen; `kqueue()` on sen BSD/macOS-vastine)**:\n * Se käyttää kehittyneempää mekanismia (`epoll_create`).\n * FD:t lisätään (`epoll_ctl` ja `EPOLL_CTL_ADD`), muutetaan (`EPOLL_CTL_MOD`) tai poistetaan (`EPOLL_CTL_DEL`) tästä ilmentymästä. tulla valmiiksi (usein käyttämällä sisäistä valmiusluetteloa tai takaisinkutsun kaltaisia ​​mekanismeja, jotka laiteohjaimet laukaisevat, kun I/O on valmis).\n * `epoll_wait()` palauttaa vain valmiit FD:t.\n * Tärkein suorituskykyetu on, että `epoll_wait()`:n hinta on tyypillisesti verrannollinen *valmiiden* FD-laitteiden määrään (kutsutaan usein nimellä O(1) valmiuden tarkistamiseen tai O(M), jossa M on valmiiden FD:iden lukumäärä), kun on kyse tuhansista tai kymmenistä tuhansista yhteyksistä, joissa vain pieni osa on aktiivisia kulloinkin.\n\nSiksi `epoll()` (ja `kqueue()`) ovat huomattavasti tehokkaampia tällaisten verkkoyhteyksien suuren määrän käsittelyä varten. palvelimia."
      }
    ]
  },
  {
    "name": "TypeScript-ominaisuudet, osa 1",
    "image": "https://images.unsplash.com/photo-1612838320302-4b3b3b3b3b3b",
    "questions": [
      {
        "question": "Mikä on päätelmä-avainsanan ensisijainen tarkoitus, kun sitä käytetään ehdollisen tyypin sisällä TypeScriptissä?",
        "answers": [
          {
            "answer": "Yleisen parametrin tyypin päätteleminen sen käytöstä funktion rungossa."
          },
          {
            "answer": "Jos haluat ilmoittaa uuden tyyppimuuttujan, jonka tyyppi päätetään tarkistettavan tyypin rakenteen perusteella ehdollisen tyypin todellisessa haarassa."
          },
          {
            "answer": "Lähetä automaattisesti tyypin mihin tahansa, jos tyypin päättely epäonnistuu ehdollisen tyypin sisällä."
          },
          {
            "answer": "Pakottaa TypeScriptin päättelemään tietyn kirjaimellisen tyypin yleisen primitiivityypin sijaan."
          }
        ],
        "answer": "Jos haluat ilmoittaa uuden tyyppimuuttujan, jonka tyyppi päätetään tarkistettavan tyypin rakenteen perusteella ehdollisen tyypin todellisessa haarassa.",
        "explanation": "TypeScriptin päätelmä-avainsanaa käytetään ehdollisen tyypin extends-lauseessa ilmoittamaan tyyppimuuttuja, jonka TypeScript päättelee. Jos tarkistettava tyyppi ("T" lausekkeessa "T extends U ? X : Y") vastaa mallia, jossa "päätelmä R" käytetään, niin "R" -tyyppiä vastaava osa kaapautuu. kuvio.\n\n**Syntaksi:**\n`SomeType laajentaa päätelmän InferredType:n TrueType<InferredType> : FalseType;`\nTai yleisemmin strukturoidun tyypin sisällä:\n`SomeType laajentaa AnotherType<inferredPart> <>InferredPart FalseType;`\n\n**Esimerkki: Lupaustyypin purkaminen**\n```typescript\ntype UnwrapPromise<T> = T laajentaa Promise<päättele U> ? : T;\n\n// Käyttö:\ntype MyStringType = PuraPromise<Lupaus<merkkijono>Tnpe =My UnwrapPromise<number>; // MyNumberType on numero (ei lupaus, joten T palautetaan)\n\nfunction fetchData(): Promise<{ id: number; data: string }> {\n return Promise.resolve({ id: 1, data: 'Sample' });\n}\n, jonka tyyppi palautetaan. fetchData:\ntype FetchedDataType = UnwrapPromise<ReturnType<fetchData>>;\n// FetchedDataType on { id: number; täsmää "Jotain" ja "päättele U".\n- Jos se täsmää, "U" muuttuu "Somethingiksi", ja ehdollinen tyyppi ratkaisee "U".\n- Jos "T" ei ole "lupaus", ehto on epätosi ja tyyppi ratkaisee "T".\n\nTämän avulla voit poimia tyyppejä, kuten siinä käytettyjä tehokkaita ja joustavia osia Parametrit<T>, ReturnType<T>, InstanceType<T> ja mukautetut kompleksityyppimuunnokset.
      },
      {
        "question": "Kuinka voit määrittää TypeScriptissä kartoitetun tyypin, joka luo uuden objektityypin, jossa kaikki olemassa olevan tyypin `T` ominaisuudet tehdään valinnaisiksi ja niiden tyypit kääritään `Promiseen`?",
        "answers": [
          {
            "answer": "kirjoita AsyncOptional<T> = { [P avaimessa T]?: Lupaus<T[P]> };"
          },
          { "answer": "type AsyncOptional<T> = Osittainen<Lupaus<T>>;" },
          {
            "answer": "kirjoita AsyncOptional<T> = { [P avaimessa T]: Lupaus<T[P] | määrittelemätön> };"
          },
          {
            "answer": "kirjoita AsyncOptional<T> = Lupaus<{ [P in keyof T]?: T[P] }>;"
          }
        ],
        "answer": "kirjoita AsyncOptional<T> = { [P in keyof T]?: Lupaus<T[P]> };",
        "explanation": "Yhdistettyjen tyyppien avulla voit luoda uusia tyyppejä olemassa olevan tyypin ominaisuuksien perusteella. Syntaksi on `{[P in K]: X}`, jossa `K` on ominaisuusavaimien liitto ja `P` iteroituu niiden yli.\n\nMerkitään oikea vastaus: `type AsyncOptional <Tmise> = {] [P] };`\n\n1. **`[P avaimessa T]`**: Tämä toistaa kaikki syöttötyypin `T` ominaisuusavaimet (`P`). valinnainen.\n3. **`: Lupaus<T[P]>`**: Tämä määrittää kunkin ominaisuuden "P" tyypin uudessa tyypissä.\n * "T[P]" on ominaisuuden "P" alkuperäinen tyyppi tyypissä "T".\n * "Lupaus<T[P]>" käärii alkuperäisen ominaisuuden tyypin \n`Promise**. Käyttö:**\n```typescript\ninterface UserProfile {\n id: number;\n username: string;\n email: string;\n}\n\ntype AsyncOptionalUserProfile = AsyncOptional<UserProfile>;\n\n// AsyncOptional<UserProfile>;\n\n// AsyncOptional-tunnus:\n// olisi {//käyttäjätunnus:nle/? Lupaus<numero>;\n// käyttäjätunnus?: Lupaus<merkkijono>;\n// sähköposti?: Promise<merkkijono>;\n// }\n\nconst profileData: AsyncOptionalUserProfile = {\n käyttäjänimi: Promise.resolve('Alice'),\n // id\n ja email ovat valinnaisia**n\```}; virheellinen:**\n* `Osittainen<T>>;`: `Osittainen` tekee yleisen argumentin ominaisuuksista valinnaisen, ei objektin, jonka ominaisuudet tekisit valinnaiseksi tällä tavalla *arvo Promisen sisällä* mahdollisesti `undefined` (`Promise<Type | undefined>`), mutta se ei tee itse ominaisuudesta valinnaista uudessa objektityypissä.\n* `Promise<{ [P in keyof T]?: T[P] }>;`: Tämä kääriä *koko tuloksena olevan objektin* yhteen Promise-ominaisuuteen sen sijaan, että se kääriisi tyypin.
      },
      {
        "question": "Mikä on koristelutehtaan tarkoitus TypeScriptissä?",
        "answers": [
          {
            "answer": "Luo useita sisustuselementtejä eri kokoonpanoilla."
          },
          {
            "answer": "Toiminto, joka palauttaa itse koristelutoiminnon, jolloin sisustajalle voidaan määrittää parametrit, kun sitä käytetään."
          },
          {
            "answer": "Sisäänrakennettu TypeScript-ominaisuus, joka luo automaattisesti sisustajia luokkarakenteen perusteella."
          },
          {
            "answer": "Varmistaaksemme, että sisustajia käytetään vain kerran luokkaan tai menetelmään, toimien yksittäistehtaana."
          }
        ],
        "answer": "Toiminto, joka palauttaa itse koristelutoiminnon, jolloin sisustajalle voidaan määrittää parametrit, kun sitä käytetään."
        "explanation": "**Sisustimen tehdas** on funktio, joka palauttaa varsinaisen sisustajafunktion. Tätä mallia käytetään, kun haluat mukauttaa sisustajan käyttäytymistä välittämällä sille argumentteja, kun käytät koristelua.\n\nJos koristelijalauseke evaluoituu funktioksi, TypeScript käsittelee tätä funktiota sisustajana. Jos koristelulauseke on funktio. `@myDecoratorFactory(arg1, arg2)`), `myDecoratorFactory` on tehdas, ja sen on palautettava varsinainen koristelutoiminto.\n\n**Structure:**\n```typescript\nfunction decoratorFactory(configValue: string) {\n // Tämä on tehdasasetusfunktio, jota kutsutaan Factory:n kanssa. ${configValue}`);\n\n paluufunktio (kohde: mikä tahansa, propertyKey: merkkijono, kuvaaja: PropertyDescriptor) {\n // Tämä on varsinainen koristelutoiminto.\n // Se voi käyttää "configValue"-funktiota ulkoisesta laajuudesta.\n console.log(`Decorator for ${propertyKey:} /{confign} /{configKey:}) sisustuslogiikka ...\n };\n}\n\nluokka MyClass {\n @decoratorFactory('customSetting1') // Sisustimen käyttäminen tehtaalla\n method1() {}\n\n @decoratorFactory('toinen asetus')\n**\``suoritus() n Flow:**\n1. Kun `MyClass` on määritetty, havaitaan `@decoratorFactory('customSetting1")`. customSetting1' ja palauttaa sisäisen funktion (varsinaisen sisustajan).\n4. Tätä palautettua koristelutoimintoa käytetään sitten menetelmälle `method1`, jolloin kirjataan 'Metodin 1 koristelu, jota käytettiin konfiguraatiolla: customSetting1'.\n5. Sama prosessi tapahtuu menetelmälle `method2, jossa on `'toinen\en\en*nnn"**n. **Määritettävyys:** Mahdollistaa sisustajien parametrisoinnin, mikä tekee niistä entistä uudelleenkäytettävimpiä ja joustavampia.\n* **Luettavuus:** Voi tehdä sisustajan tarkoituksesta selkeämmän, jos määritykset välitetään erikseen.\n\n**Virheelliset vastaukset:**\n* Vaikka voit luoda erilaisia ​​kokoonpanoja, kyse on kokonaisten logiikkaparametrien, ei sisustajan parametrien luomisesta. OOP:ssa.\n* Se on käyttämäsi malli, ei automaattinen luontiominaisuus.\n* Se ei ole luonnostaan ​​yksittäinen tehdas sisustussuunnittelijan sovellukselle."
      },
      {
        "question": "Mitä eroa on "const enum":n ja tavallisen "enum" välillä TypeScriptissä käännetyn JavaScript-tulosteen suhteen?",
        "answers": [
          {
            "answer": "const enum -jäsenet käännetään aina merkkijonoliteraaaleiksi, kun taas tavalliset enum-jäsenet ovat numeroita."
          },
          {
            "answer": "Säännölliset "enum" luovat hakuobjektin JavaScriptissä, kun taas "const enum" -jäsenet on rivitetty käyttösivustoille, eivätkä ne luo ylimääräistä JavaScript-objektia, jos mahdollista."
          },
          {
            "answer": "Const enumissa voi olla vain merkkijonoarvoja, kun taas tavallisissa enumeissa voi olla numero- tai merkkijonoarvoja."
          },
          {
            "answer": "Käännetyssä lähdössä ei ole eroa; "const enum" on vain käännösajan tarkistus muuttumattomuuden varalta."
          }
        ],
        "answer": "Tavalliset "enum" luovat hakuobjektin JavaScriptissä, kun taas "const enum" -jäsenet on rivitetty käyttösivustoille, eivätkä ne luo ylimääräistä JavaScript-objektia, jos mahdollista.",
        "explanation": "**Tavalliset enum:t:**\nTypeScriptin standardi `enum' kääntää alas JavaScript-objektiksi, joka toimii käänteisenä kuvauksena (arvosta nimeen) ja eteenpäin suuntautuvana vastineena (nimestä arvoon).\n\n```typescript\n// TypeScript\nenum Suunta {\n Ylös,\n Alas,\n,\n,\n, di\n} Suunta.Ylös;\n```\nKäännetty JavaScript (käsitteellinen, voi vaihdella hieman):\n```javascript\nvar Suunta;\n(funktio (Suunta) {\n Suunta[Suunta['Ylös'] = 0] = 'Ylös';\n Suunta[Suunta'] = '] = '] = ' n ; Suunta[Suunta['Vasen'] = 2] = 'Vasen';\n Suunta['Oikea'] = 3] = 'Oikea';\n})(Suunta || (Suunta = {}));\n\nanna dir = Suunta `Direction`-objekti.\n\n**Const Enums:**\n`Const enum` on vain käännösajan rakennelma. Sen jäsenet ovat rivissä kaikkialla, missä niitä käytetään, jos sen jäsenet voidaan sisällyttää kokonaan. NotFound = 404,\n ServerError = 500,\n}\n\nlet status = HttpStatus.Ok;\nlet isError = status === HttpStatus.ServerError;\n```\nKäännetty JavaScript:\n```javascript\nlet status = HttpStatus.Ok 200\nlet isError = status === 500 // HttpStatus.ServerError on rivissä 500\n// 'HttpStatus'-objektia ei luoda\n```\n\n**Key Differences & Impplications:**\nScripts-ulostulo:**Javacon1 enum-arvot eivät yleensä ole, mikä johtaa mahdollisesti pienempiin nippukokoihin, jos arvot ovat rivissä.\n2. **Inlining:** "const enum" -arvot korvataan suoraan niiden käyttösivustoilla.\n3 **Ambient-kontekstit:** Et voi käyttää "const enum" -tiedostoja. Ne vaativat olemassa olevia JavaScript-tiedostoja. kääntäjä, jolla on pääsy alkuperäiseen enum-määritelmään sisäisiin arvoihin.\n4 **Computed Members:** `const enum` -jäsenillä voi olla vain vakiomuotoisia enum-lausekkeita (kirjaimella tai muilla `const enum` -jäsenillä, jotka voivat käyttää comnnnst-jäseniä. enum`?**\n* Kun haluat välttää ylimääräisen objektin ja funktion kääreen käytön lähettämässäsi JavaScriptissä.\n* Kun olet varma, että enum-arvoja käytetään yhteyksissä, joissa sisällyttäminen on turvallista ja toivottavaa (esim. ei erillisten käännösrajojen yli ilman jaettua lähdettä tai `--preserveConstEnnums**voi olla**r\n\nwerin**scor:n\snwerin**). Numeerisilla arvoilla voi oletuksena olla myös merkkijonoarvoja "const enum" -jäsenillä, ellei niitä ole määritelty sellaisiksi.\n* Const enum -lausekkeella voi olla myös merkkijonoarvoja.\n* Käännetyssä tuloksessa on merkittävä ero.
      },
      {
        "question": "Kuinka TypeScriptin moduulin lisäyksen avulla voit lisätä uuden ominaisuuden olemassa olevaan ulkoisen kirjastomoduulin viemään käyttöliittymään?",
        "answers": [
          {
            "answer": "Ilmoittamalla käyttöliittymä uudelleen uuden ominaisuuden kanssa globaalissa .ts-tiedostossa."
          },
          {
            "answer": "Käyttämällä "Object.defineProperty" tuodun kirjaston käyttöliittymässä ajon aikana."
          },
          {
            "answer": "Luomalla uuden `.d.ts`-tiedoston, käyttämällä `declare module 'kirjaston_nimi'` ja ilmoittamalla sitten uudelleen kyseisen moduulilohkon käyttöliittymä lisätyillä ominaisuuksilla."
          },
          {
            "answer": "Tuomalla käyttöliittymä, laajentamalla sitä uudella käyttöliittymällä ja käyttämällä uutta laajennettua käyttöliittymää koko sovelluksessa."
          }
        ],
        "answer": "Luomalla uusi `.d.ts`-tiedosto, käyttämällä `declare module 'kirjaston_nimi'` ja ilmoittamalla sitten uudelleen liitäntä kyseisessä moduulilohkossa lisätyillä ominaisuuksilla.",
        "explanation": "Moduulien lisäyksen avulla voit laajentaa olemassa olevia moduuleja ja niiden määrityksiä (kuten rajapintoja) muuttamatta niiden alkuperäistä lähdekoodia."
      },
      {
        "question": "Mikä on tärkein etu TypeScriptin tuntemattoman tyypin käyttämisestä "mihin tahansa" verrattuna, kun käsitellään epävarman tyyppisiä arvoja?",
        "answers": [
          {
            "answer": ""tuntematon" sallii implisiittisen muuntamisen mihin tahansa muuhun tyyppiin, kun taas "mikä tahansa" edellyttää nimenomaista suoratoistoa."
          },
          {
            "answer": ""tuntematon" on kaikkien muiden tyyppien alatyyppi, kun taas "mikä tahansa" on supertyyppi."
          },
          {
            "answer": ""tuntematon" pakottaa sinut suorittamaan nimenomaisia ​​tyyppitarkistuksia tai väitteitä ennen toimintojen suorittamista arvolle, mikä parantaa tyypin turvallisuutta, toisin kuin "mikä tahansa", joka sallii minkä tahansa toiminnon."
          },
          {
            "answer": ""tuntematon" ja "kaikki" ovat toiminnallisesti identtisiä, mutta "tuntematon" tarjoaa parempia JSDoc-kommentteja."
          }
        ],
        "answer": ""tuntematon" pakottaa sinut suorittamaan nimenomaisia ​​tyyppitarkistuksia tai väitteitä ennen toimintojen suorittamista arvolle, mikä parantaa tyypin turvallisuutta, toisin kuin "mikä tahansa", joka sallii minkä tahansa toiminnon."
        "explanation": "Sekä "any" ja "unknown" ovat TypeScriptin suosituimpia tyyppejä, mikä tarkoittaa, että minkä tahansa tyypin arvo voidaan määrittää tyypin "any" tai "unknown" muuttujalle.\n\n**`any' ('Escape Hatch'):**\n* Jos muuttujan tyyppi on 'any', voit kutsua sitä: käyttää sitä käytännöllisesti katsoen mitä tahansa toimintoa. tyyppi jne. ilman TypeScriptiä suorittamatta käännösaikatarkistuksia.\n* Tämä poistaa tehokkaasti kyseisen muuttujan tyyppitarkistuksen, mikä voi johtaa ajonaikaisiin virheisiin, jos arvoa koskevat oletukset ovat virheellisiä.\n```typescript\nlet valAny: any = 'hello';\nconsole.log(valCase(at)Upper; time\nvalAny.foo(); // OK käännöshetkellä (mutta todennäköinen ajonaikainen virhe)\nlet num: number = valAny // OK käännöshetkellä (mutta ajonaikainen virhe, jos valAny ei ole numeron kaltainen)\n```\n\n**`tuntematon` (Typpiturvallinen vastine):**\n* Jos muuttujalla on **present-toiminto, kirjoita se. se suoraan.\n* Käyttääksesi tuntematonta arvoa, **täytyy ensin kaventaa sen tyyppiä** käyttämällä:\n * Kirjoita vartijat (`typeof x === 'string'`, `x instanceof MyClass', mukautetun tyyppiset vartijat).\n * Kirjoita väitteet (`x merkkijonona`).\n * Ohjausvirta-analyysi perustuu johtavien tasa-arvotarkistusten tyyppiin.\n turvallisempaan koodiin.\n\n```typescript\nlet valUnknown: unknown = 'hello';\n\n// console.log(valUnknown.toUpperCase()); voidaan määrittää tyyppiin 'merkkijono'.\n\nif (typeof valUnknown === 'merkkijono') {\n console.log(valUnknown.toUpperCase()); console.log(val.getFullYear()); // OK\n } else if (typeof val === 'number') {\n console.log(val.toFixed(2)); arvoa, ennen kuin sitä voidaan käyttää mahdollisesti vaarallisilla tavoilla. Tämä estää tahattomat virheet, jotka `mikä tahansa` voi helposti sallia. "mikä tahansa" on määritettävissä mistä tahansa tyypistä ja mihin tahansa.\n* Ne ovat toiminnallisesti hyvin erilaisia ​​tyyppiturvallisuuden suhteen."
      },
      {
        "question": "Mikä TypeScript-apuohjelmatyyppi muodostaa tyypin, jolla on T-tyypin ominaisuusjoukko K?",
        "answers": [
          { "answer": "Jätä <T, K>" },
          { "answer": "Valitse<T, K>" },
          { "answer": "Ota <T, U>" },
          { "answer": "Tallenna<K, T>" }
        ],
        "answer": "Valitse <T, K>",
        "explanation": "Pick<T, K>" -apuohjelman tyyppi muodostaa uuden tyypin poimimalla joukon ominaisuuksia "K" (jonka on oltava "T":n avaimia) olemassa olevasta tyypistä "T".\n\n**Syntaksi:** `Valitse<Tyyppi, Avaimet>`\n* `Tyyppi, josta*: Valitse ominaisuudet. merkkijonoliteraalityyppien tai valittavien ominaisuuksien avaimia edustavien numeeristen literaalityyppien liitto. Näiden avainten on oltava kohdassa "Type" ("K extends key of T").\n\n**Esimerkki:**\n```typescript\ninterface User {\n id: number;\n name: string;\n email: string At\n is Ad;\n; Päivämäärä;\n}\n\n// Luo tyyppi, jossa on vain 'id' ja 'nimi' käyttäjästä\ntype UserSummary = Valitse<Käyttäjä, 'id' | 'nimi'>;\n\n// UserSummary vastaa:\n// {\n// id: number;\n// nimi: string;\n/summary : 1,\n nimi: 'Liisa',\n // sähköposti: 'alice@example.com' // Virhe: 'sähköpostia' ei ole tyypissä 'UserSummary'\n};\n```\n\n**Muut apuohjelmatyypit mainitut:**\n* **`Ota pois: <T, sitten kaikki ominaisuudet` tyypeistä** `K`:n poistaminen Se on 'Pick':n vastakohta siinä mielessä, mitkä avaimet säilytetään vai poistetaan.\n ``typescript\n type UserDetails = Ohita <User, 'isAdmin' | 'createdAt'>;\n // UserDetails-kentässä on 'id', 'name\n', '*``**. U>`**: muodostaa tyypin poimimalla 'T':sta kaikki liitännät, jotka voidaan määrittää 'U':lle.\n ```typescript\n-tyyppi StringOrNumber = merkkijono | T>`**: Muodostaa objektityypin, jonka ominaisuusavaimet ovat `T`, on tyypillisesti `merkkijono-/-lukusymboli.\n ``typescript\n-tyyppi PageInfo = 'kotisivu', 'PageVisits' |. vastaanottaja:\n // {\n // kotiin: numero;\n // noin: numero;\n // yhteystiedot: numero;\n // }\n ```"
      },
      {
        "question": "Mikä on avainominaisuus ja käyttötapaus "const"-väitteille TypeScriptissä (esim. "as const")?",
        "answers": [
          {
            "answer": "Ne varmistavat, että objektin ominaisuudet voidaan määrittää uudelleen ajon aikana, mutta niitä ei voida kirjoittaa uudelleen."
          },
          {
            "answer": "Ne laajentavat kirjaimelliset tyypit primitiivisiksi vastineiksi (esim. "hei" merkkijonolle) joustavuuden lisäämiseksi."
          },
          {
            "answer": "Ne antavat TypeScriptille signaalin päätelläkseen kohteen ominaisuuksien tai taulukon elementtien tarkimmat kirjaimelliset tyypit ja tehdä niistä "vain luku".
          },
          {
            "answer": "Niitä käytetään ensisijaisesti lähettämään "mitä tahansa" tyyppiä tiettyyn vakioarvoon suorituskyvyn parantamiseksi."
          }
        ],
        "answer": "Ne antavat TypeScriptille signaalin päätelläkseen kohteen ominaisuuksien tai taulukon elementtien tarkimmat kirjaimelliset tyypit ja tehdä niistä "vain luku".",
        "explanation": "`as const` on **const-väite** TypeScriptissä. Kun sitä käytetään objektiliteraaliin, taulukkoliteraaliin tai literaalityyppiin, se käskee TypeScriptiä päättelemään suppeimman ja tarkimman mahdollisen tyypin ja käsittelemään ominaisuuksia/elementtejä vain luku -muodossa.\n\n**Avainvaikutukset `as const1:lle.**\n\n`.** Ominaisuudet/Elementit:**\n * Objektin ominaisuuksille päätellään merkkijonokirjaintyypit yleisen merkkijonon sijaan, numeroliteraalityypit numeron sijasta jne.\n * Matriisielementeillä ne päätellään myös kirjaimella.\n\n2 **`readonly` Ominaisuudet:**\n * Objektin ominaisuuksista tulee vain .`n.**todella Tuples:**\n * Array-literaaleista tulee lukuisia monikoita, joissa on tietyt literaalityypit jokaiselle elementille.\n\n**Esimerkki ilman `as const`:**\n```typescript\nlet config = {\n-tila: 'kehitys',\n portti: 3000,\n portti: 3000,\n \n \u200b\u200b\n ominaisuudet\red", 'n}} kokoonpanon tyyppi:\n// {\n// merkkijono // laajennettu numeroon\n// ominaisuudet: merkkijono\n// }\nconfig.mode = 'production' // 0/8; OK\nconfig.features.push('cache'); // OK\n```\n\n**Esimerkki komennolla `as const`:**\n```typescript\nlet configConst = {\n-tila: 'kehitys',\n portti: 3000,\n ominaisuudet:'/;\n\n} Päätelty configConst-tyyppi:\n// {\n// vain luku -muoto: 'kehitys' // vain luettavissa oleva portti: 3000 // kirjallinen tyyppi, vain luku -ominaisuudet: vain luettavissa ['auth', 'kirjaus/kirjat']; " // Virhe: Ominaisuutta 'push' ei ole olemassa tyypille 'readonly ['auth', 'logging']'.\n```\n\n**Käyttötapaukset:**\n* **Tosivakioiden luominen:** Kun haluat määrittää objektin tai taulukon, jota ei pitäisi käsitellä muteerattuina Red-toiminnon tyypeinä ja joiden arvot tulee käsitellä g. koodit, määritysobjektit).\n* **Tyyppipäätelmän parantaminen:** Tarjoaa tarkempia tyyppejä funktioille tai muille koodisi osille, mikä mahdollistaa paremman tyyppitarkistuksen ja automaattisen täydennyksen.\n* **Sovellusliittymän suunnittelu:** Kun haluat määrittää API:n, joka odottaa erittäin tarkkoja kirjaimellisia arvoja.\n\n**Virheelliset vastaukset* ne tekevät ominaisuuksien uudelleen. Ne tekevät päinvastoin: ne rajaavat tyypit literaaleihin, eivät laajenna niitä.\n* Ne ovat käännösaikainen rakennelma tyyppipäätelmään ja muuttumattomuuteen, eivät ensisijaisesti "mitä tahansa" suoratoistoon tai suoratoistoon liittyvään suoritukseen."
      },
      {
        "question": "Kuinka TypeScriptin indeksoitu käyttöoikeustyyppi `T[K]` toimii, ja mitkä ovat sen yleisiä käyttötapauksia?",
        "answers": [
          {
            "answer": "Se käyttää dynaamisesti objektin "T" ominaisuutta "K" suorituksen aikana ja palauttaa sen arvon."
          },
          {
            "answer": "Se luo uuden tyypin, joka edustaa ominaisuuden "K" tyyppiä tyypin "T" sisällä. "K" voi olla merkkijonoliteraali, numeroliteraali tai näiden yhdistelmä, joka vastaa T:n avaimia."
          },
          {
            "answer": "Se on tapa iteroida T-tyypin näppäimiä, jotka ovat samanlaisia ​​kuin "for...in" -silmukassa, jossa "K" on nykyinen avain."
          },
          {
            "answer": "Se määrittää taulukon tyypin "T", jossa "K" määrittää taulukon kiinteän pituuden."
          }
        ],
        "answer": "Se luo uuden tyypin, joka edustaa ominaisuuden "K" tyyppiä tyypin "T" sisällä. "K" voi olla merkkijono literaali, numeroliteraali tai näiden yhdistelmä, joka vastaa T:n avaimia.",
        "explanation": "Indeksoidut käyttöoikeustyypit (tunnetaan myös hakutyypeinä) sallivat sinun etsiä tietyn ominaisuuden tyyppiä toisesta tyypistä.\n\n**Syntaksi:** `T[K]`\n* `T`: Tyyppi, jota tutkit (esim. käyttöliittymä, objektityypin alias tai luokkatyyppi).\n* Tämän avaimen tyyppi (tai avain: n) jonka haluat purkaa. * Merkkijonoliteraalityyppi (`'propertyName'`)\n * Numeroliteraalityyppi (taulukon/tuple-elementtityypeille tai numeerisille avaimille)\n * Merkkijono-/lukuliteraalityyppien liitto\n * Tyyppimuuttuja, joka laajentaa `keyof T`\n\n**Kuinka se toimii:**\n`T[K]` ominaisuuden nimen tyyppi määrittää tyypin sisällä `T`.\n\n**Esimerkkejä:**\n```typescript\ninterface User {\n id: number;\n name: string;\n address: {\n street: string;\n city: string;\n };\n roles: string[];\n}\n\ntype UserIdType = UserIdType = User [Nimi on\ntyyppi]; User['name'] // UserNameType on string\ntype UserAddressType on { street: string: string }\ntype UserCityType = User['osoite']['City'] [UserCityType on merkkijono]\n; // UserRoleElementType on merkkijono (elementtien tyyppi roolitaulukossa)\n\n// Avainliiton käyttäminen\ntype IdOrNameType = User['id' | 'nimi'] // IdOrNameType on numero | T[K] {\n return obj[key];\n}\n\nvakiokäyttäjä: Käyttäjä = {\n id: 1, nimi: 'Liisa', \n osoite: { katu: '123 Main St', kaupunki: 'Wonderland' },\n roolit: ['admin', 'str.editori'n] getProperty(user, 'name');\nconst userRoles: string[] = getProperty(user, 'roles');\n```\n\n**Yleiset käyttötapaukset:**\n1.**Ominaisuustyyppien purkaminen:** Tietyn ominaisuuden tyypin saaminen käytettäväksi muualla (esim. Crennotations**-funktion tyypit a)\n.** yleiset funktiot, jotka toimivat objektien ominaisuuksilla tyyppiturvallisella tavalla (kuten "getProperty"-esimerkki).\n3. **Käytetyt tyypit:** Käytetään usein yhdistetyissä tyypeissä viittaamaan muunnettavan ominaisuuden alkuperäiseen tyyppiin.\n ```typescript\n-tyyppi ReadonlyProps<T> = {\n vain luku [T\u003e\u003c\u200b\u200bpääsytunnus] s };\n ```\n\n**Virheelliset vastaukset:**\n* Se on käännösaikatyyppinen toiminto, ei ajonaikaisen arvon käyttö (vaikka ajonaikaisen pääsyn syntaksi `````\n\n* ei ole tarkoitettu iterointiin `keyof T` yhdistettynä siihen ei define tyyppejä kiinteäpituiset taulukot."
      },
      {
        "question": "Mitä TypeScriptissä `ei koskaan`-tyyppiä käytetään ensisijaisesti edustamaan?",
        "answers": [
          {
            "answer": "Tyyppi, joka voi sisältää minkä tahansa arvon, samanlainen kuin "mikä tahansa", mutta tarkemmalla tarkistuksella."
          },
          {
            "answer": "Arvon tyyppi, jota ei koskaan esiinny. Esimerkiksi funktion palautustyyppi, joka aiheuttaa aina virheen tai jolla on loputon silmukka."
          },
          {
            "answer": "Alias ​​`tyhjälle`, kun funktio ei palauta mitään."
          },
          {
            "answer": "Paikkamerkkityyppi yleisille parametreille, joita ei ole vielä päätetty."
          }
        ],
        "answer": "Arvon tyyppi, jota ei koskaan esiinny. Esimerkiksi funktion palautustyyppi, joka aiheuttaa aina virheen tai jolla on loputon silmukka.",
        "explanation": "Typectrict -tyyppinen" koskaan "-tyyppi edustaa arvojen tyyppiä, joita ** koskaan ** esiintyy. \ n \ n ** Avainominaisuudet ja käyttötapaukset: ** \ n \ n1. ** Toiminnot, jotka eivät koskaan palauta: ** \ n*funktio, joka aina heittää poikkeuksen. \ n*funktio, joka sisältää" tyyppisilmukan \ n toimisi. throwError(message: string): never {\n throw new Error(message);\n }\n\n function infiniteLoop(): never {\n while (true) {}\n }\n ```\n "ei koskaan" määrittäminen paluutyypiksi kertoo TypeScriptille, että normaali suorituspolku ei jatku tämän funktion tarkistuksen jälkeen\n2 Flow:**\n `ei koskaan` on erittäin hyödyllinen, jotta voidaan varmistaa, että kaikki mahdolliset tapaukset liitännäistyypissä tai `kytkin'-lauseessa käsitellään { laji: 'ympyrä': numero }\n\n funktio getArea(shape: Shape): numero {\n tapaus 'neliö': return shape.size * shape.size;\n case 'ympyrä': return Math.PI * muoto.säde', 2 lajia/säde'; tämä olisi tyyppiä 'never'\n const _exhaustiveCheck: never = shape;\n // Jos Shape-unioniin lisätään uusi muototyyppi ilman kytkintä päivittämättä,\n // '_exhaustiveCheck = muoto' aiheuttaa käännösaikavirheen, koska\n // käsittelemätöntä muototyyppiä ei voida määrittää \n'never-exhaustive;C. }\n }\n ```\n\n3. **Unionityyppien suodatus ehdollisissa tyypeissä:**\n Ehdollisissa tyypeissä kyseinen jäsen poistetaan liitosta, jos ehdollinen tyyppi on distributiivinen.\n ```typescript\n kirjoita NonFunctionKeys [K]:n [K]:n laajennus : K;\n [avain T];\n\n käyttöliittymä MyObject {\n nimi: merkkijono;\n ikä: numero;\n tervehdys: () => void;\n }\n // NonFunctionKeys<MyObject> on 'nimi' 'age'\n // Avain on suodatettu. ```\n\n4. **Alhainen tyyppi:**\n "ei koskaan" on TypeScriptin tyyppijärjestelmässä alin tyyppi. Tämä tarkoittaa, että "ei koskaan" on määritettävissä kaikille muille tyypeille, mutta mikään tyyppi (paitsi "ei koskaan") ei ole määritettävissä "ei koskaan".\n\n**Väärät vastaukset, mutta tyyppi voi olla tarkempi. `any' on se, joka sallii minkä tahansa arvon löysällä tarkistuksella.\n* `void' edustaa palautusarvon puuttumista (kuten funktio, joka palauttaa 'undefined' implisiittisesti tai eksplisiittisesti, 'ei koskaan' tarkoittaa funktiota *ei koskaan edes suorita* normaalia suorituspolkua.\n* Se ei ole paikkamerkki päätelmättömille genericsille.
      }
    ]
  },
  {
    "name": "TypeScript-ominaisuudet, osa 2",
    "image": "https://images.unsplash.com/photo-1612838320302-4b3b3b3b3b3b",
    "questions": [
      {
        "question": "Kuinka voit määrittää TypeScript-apuohjelman tyypin `OmitStrict<T, K laajentaa avaimen T>`, joka käyttäytyy kuten "Omit<T, K>", mutta varmistaa, että "K" on itse asiassa "T":n avain, joka epäonnistuu käännöshetkellä, jos ei-avainta tarjotaan?",
        "answers": [
          {
            "answer": "kirjoita OmitStrict<T, K laajentaa avaimen T> = Valitse<T, sulje pois<avain T, K>>;"
          },
          {
            "answer": "kirjoita OmitStrict<T, K> = K laajentaa avaimen T ? Ohita <T, K> : ei koskaan;"
          },
          {
            "answer": "kirjoita OmitStrict<T, K laajentaa merkkijonoa> = { [P in Exclude<avain T, K>]: T[P] };"
          },
          { "answer": "kirjoita OmitStrict<T, K laajentaa avaimen T> = Ohita <T, K>;" }
        ],
        "answer": "kirjoita OmitStrict<T, K laajentaa avaimen T> = Valitse<T, sulje pois<avain T, K>>;",
        "explanation": "Tavallinen `Omit<T, K>` apuohjelman tyyppi määritellään seuraavasti: `type Omit<T, K extends keyof any> = Pick<T, Exclude <keyof T, K>>;`. Huomaa `K laajentaa minkä tahansa avaimen (joka on `merkkijono | numero | symboli`). Tämä tarkoittaa, että jos annat avaimen T:lle, se ei todellakaan ole `O `K`. ei tee virhettä itse K:lle, mutta `Exclude<keyof T, K>` ei yksinkertaisesti sulje pois mitään, jos `K` ei ole T-avaimessa.\n\nPyyntö on tehdä K:stä tiukasti K:n avain. Rajoitus `K Extens keyof T` tekee tämän jo tyyppiparametritasolla, L-tyyppinen vastaus on oikea. Extens keyof T> = Valitse <T, Exclude <keyof T, K>>;`\n\n1 **`K laajentaa T:n avainta**: Tämä yleinen rajoitus varmistaa jo sen, että `K`:n on oltava `T`:ssä olevien avainten yhdistelmä. `'nonExistentKey' ei laajenna MyType-avainta.\n2 **`Poissulje <keyof T, K>`**: Tämä apuohjelmatyyppi laskee oikein joukon `T`-avaimia, jotka *ei ole* K-kirjaimessa.\n3. **`Valitse<T, K>>>-avain vain tästä. "T".\n\nTämä määritelmä itsessään on identtinen standardin "Omit" kanssa, mutta "K":n rajoitus tekee käyttösivustosta "tiukkoja". Kysymys koskee "OmitStrict":n määrittelyä siten, että ei-avaimen antaminen "K":lle on virhe. Rajoitus "K" laajentaa itse tiukkuuden parametria, kun T's on käytössä. *käytetty*.\n\n**Käyttöesimerkki:**\n```typescript\ninterface User {\n id: number;\n nimi: string;\n email: string;\n}\n\n// Omit (tai OmitStrict-määritelmämme) oikea käyttö\ntype UserWithoutEmail =\npoimi<n käyttäjä, poissulje'avain<n käyttäjä,/>; UserWithoutEmail = OmitStrict<Käyttäjä, 'sähköposti'>;\n\nconst user1: UserWithoutEmail = { id: 1, name: 'Alice' }; // OK\n\n// Jos yritämme käyttää OmitStrictiä ei-avaimen kanssa:\n// kirjoita InvalidOmit <User, 'nonExistentKey'>;\n// Tämä aiheuttaisi TypeScript-virheen: \n// Tyyppi ''nonExistentKey'' ei täytä rajoitusta "Käyttäjän avain".\n```\n\nAvain on, että `K laajentaa T:n avainta `OmitStricile:n yleisissä parametreissa, jolloin toteutus voi olla sama `Omit`.\n\n**Miksi muut vaihtoehdot ovat vähemmän suoria tai eivät lisää tarkkuutta oikein:**\n* `kirjoita OmitStrict<T, K> = K laajentaa T:n avainta Omit<T, K> : never;`: Tämä tekisi *tuloksen* `ei koskaan`, jos `K` ei ole itse avain, mutta se ei ole sama kuin `us'-sivustossa. rajoitus. Käyttäjä saa "ei koskaan" ja saattaa hämmentyä. Tavoitteena on, että "K" on rajoitettu.\n* "kirjoita OmitStrict, K laajentaa merkkijonoa". K>' toimisi edelleen, mutta 'K':n rajoitus on liian löysä.\n* 'type OmitStrict<T, K laajentaa avainta T> = Omit<T, K>;`: Tämä on pohjimmiltaan alias, mutta `OmitStrict' *itse* on se, mikä edellyttää, että *S-mittaus-toteutus on käytössä "Pick" ja "Exclude" ovat ydin, ja "K Extens Keyof T" -rajoitus on se, joka pakottaa annettuun "K" tiukkuuteen."
      },
      {
        "question": "Kuinka voit määrittää TypeScript-tyypin `PathValue<T, P extends string>`, joka hakee syvälle sisäkkäisen ominaisuuden tyypin `T`:ssä, joka on määritetty pisteellä erotetulla polkumerkkijonolla `P` (esim. `PathValue<User, 'address.city'>`)?",
        "answers": [
          {
            "answer": "tyyppi PathValue<T, P laajentaa merkkijonoa> = P laajentaa `${infer K}.${infer R}` ? (K laajentaa avaimen T ? PathValue<T[K], R> : ei koskaan) : (P laajentaa T:n avainta? T[P] : ei koskaan);"
          },
          {
            "answer": "kirjoita PathValue<T, P laajentaa merkkijonoa> = T[P]; // Toimii vain matalilla poluilla"
          },
          {
            "answer": "kirjoita PathValue<T, P laajentaa merkkijonoa> = P.split('.').reduce((obj, key) => obj[avain], T);"
          },
          {
            "answer": "tyyppi PathValue<T, P laajentaa merkkijonoa> = P laajentaa T:n avaimen? T[P] : (P laajentaa `${string}.${string}` ? tuntematon : ei koskaan);"
          }
        ],
        "answer": "type PathValue<T, P laajentaa merkkijonoa> = P laajentaa `${infer K}.${infer R}` ? (K laajentaa avaimen T ? PathValue<T[K], R> : ei koskaan) : (P laajentaa T:n avainta ? T[P] : ei koskaan);",
        "explanation": "Tämä on monimutkainen tyyppi, joka vaatii rekursiivisia ehdollisia tyyppejä ja mallin literaalityypin päättelyn."
      },
      {
        "question": "Mikä on Accessor Decorator TypeScriptissä ja mitä argumentteja se vastaanottaa?",
        "answers": [
          {
            "answer": "Aksessorin "get"- tai "set"-menetelmään sovellettu koristelu yksitellen vastaanottaen kohteen, ominaisuusavaimen ja ominaisuuden kuvaajan."
          },
          {
            "answer": "Aksessoriin (ominaisuus, jossa on "get" ja/tai "set" käytetty koristelu, joka vastaanottaa luokan rakentajan, ominaisuusavaimen ja indeksin, jos se on staattinen aksessori."
          },
          {
            "answer": "Koristelija, jota käytetään kerran aksessoriin (ominaisuus, jossa on "get" ja/tai "set" ja joka vastaanottaa kolme argumenttia: kohteen (luokan prototyyppi tai rakentaja), ominaisuusavain (aksesorin nimi) ja aksessorin ominaisuuskuvaaja."
          },
          {
            "answer": "Sisustustehdas, joka luo "get"- ja "set"-menetelmiä kiinteistölle."
          }
        ],
        "answer": "Sisustaja, jota käytetään kerran aksessoriin (ominaisuus, jossa on "get" ja/tai "set" ja joka vastaanottaa kolme argumenttia: kohteen (luokan prototyyppi tai rakentaja), ominaisuusavain (aksesorin nimi) ja aksessorin ominaisuuskuvaaja."
        "explanation": "**Accessor Decorator** ilmoitetaan juuri ennen aksessorin määritystä (ominaisuus, joka on määritelty `get` ja/tai `set`-menetelmillä).\n\n**Avainkohdat:**\n* Sitä sovelletaan aksessoriin kokonaisuudessaan, ei `get`- tai `set`-osaan yksitellen.\n* Se vastaanottaa **toisen argumentin ** **toisen argumentin. luokan konstruktorifunktio staattiselle jäsenelle tai luokan prototyyppi esiintymän jäsenelle.\n 2. **`propertyKey`**: Jäsenen nimi (accessorin nimi) merkkijonona tai symbolina.\n 3. **`descriptor`**: `PropertyDescriptor` jäsenelle. **Palauta arvo**: Aksessorin muotoilija voi halutessaan palauttaa PropertyDescriptor-arvon. {\n paluufunktio (kohde: mikä tahansa, propertyKey: merkkijono, kuvaaja: PropertyDescriptor) {\n console.log(`Accessor Decorator for: ${propertyKey}`);\n descriptor.enumerable = value;\n // Vaihtoehtoisesti palauta kuvaaja, jos haluat korvata sen kokonaan\n // luokka\n\nDescriptor; _x: numero = 0;\n yksityinen _y: numero = 0;\n\n @EnumerableAccessor(true)\n get x() {\n palauta tämä._x;\n }\n set x(newX: number) {\n this._x = newX;\n }\n\n @EnumerableAccessor(y) \n ei saa //(false) //(false) return this._y;\n }\n set y(newY: number) {\n this._y = newY;\n }\n}\n\n\nconst p = new Point();\np.x = 10;\np.y = 20;\n\nconsole.log('Iterointi pisteen ominaisuuksien yli:');\nfor {x, n-avain saattaa näkyä p:ssä jos enumerable on tosi\n // 'y':n ei pitäisi, jos enumerable on epätosi\n console.log(avain) \n}\n\n// Tarkista kuvaaja suoraan\nconst xDescriptor = Object.getOwnPropertyDescriptor(Point.prototype, 'x');\nconsole.denumerable:'x,/escriptor; Odotettu: true\n\nconst yDescriptor = Object.getOwnPropertyDescriptor(Point.prototype, 'y');\nconsole.log('y enumerable:', yDescriptor?.enumerable // Odotettu: false\n```\n\n**Virheellinen \n````\n\n**Virheellinen:*n Access:s's A** an the access. `get`/`set` yksitellen.\n* Argumentit ovat kohde, ominaisuusavain ja deskriptori, eivät staattisten aksessorien luokan rakentaja ja indeksi.\n* Se ei yleensä luo get- ja set-menetelmiä tyhjästä (se olisi enemmän kuin ominaisuuden sisustaja, joka muuntaa yksinkertaisen ominaisuuden.""
      },
      {
        "question": "Mikä on "export = "- ja "import = request()" -syntaksien tarkoitus TypeScriptissä, ja milloin sitä voidaan käyttää?",
        "answers": [
          {
            "answer": "Se on moderni ECMAScript-standardi moduulien vientiä ja tuontia varten, joka korvaa `vienti oletusarvon`."
          },
          {
            "answer": "Se on yhteensopiva perinteisten CommonJS/AMD-moduulien kanssa, jotka vievät yhden kokonaisuuden (esim. objektin, funktion tai luokan), varsinkin kun "esModuleInterop" on epätosi."
          },
          {
            "answer": "Se mahdollistaa tuonnin ja viennin uudelleennimeämisen moduulirajoilla paremman organisoinnin parantamiseksi."
          },
          {
            "answer": "Se on syntaksi uudelleenvientien luomiseen, samanlainen kuin `export * from './module';`."
          }
        ],
        "answer": "Se on yhteensopiva perinteisten CommonJS/AMD-moduulien kanssa, jotka vievät yhden kokonaisuuden (esim. objektin, funktion tai luokan), varsinkin kun "esModuleInterop" on epätosi.",
        "explanation": "Export = ` ja `import moduleName = request('module-path');` syntaksi TypeScriptissä on tarkoitettu ensisijaisesti yhteentoimivuuteen vanhempien moduulijärjestelmien kanssa, erityisesti **CommonJS** (kuten Node.js `module.exports = ...`) ja **AMD**-moduulit, jotka usein vievät yksittäisen, ensisijaisen \port \`ex -objektin tai funktion. Tehtävä):**\n* Moduuli voi käyttää parametria `export = ` määrittääkseen yksittäisen objektin, joka on moduulin arvo, kun muut moduulit tuovat sen yhteensopivalla syntaksilla.\n* Moduulilla voi olla korkeintaan yksi `export =` -käsky.\n* Sitä ei voi käyttää muiden ylimmän tason `vienti`-ilmoitusten kanssa (kuten jos olet samassa moduulissa export- tai export-luokkaan...) kohdistus CommonJS/AMD (joskin niputtajat saattavat käsitellä tätä eri tavalla).\n\n```typescript\n// my-module.ts\nclass MyClass {\n greet() { return 'Hei!' }\n}\nexport = MyClass //Muun luokka\\\`````, tämän modulin yksittäinen vienti; request('module-path');` (Import Assignment):**\n* Tätä syntaksia käytetään tuomaan moduuli, joka on viety komennolla `export = ` tai CommonJS/AMD-moduuli, joka asettaa `module.exports`.\n* `moduleName` sisältää yksittäisen viedyn entiteetin tiedostosta `\`'module-pathn\`/'module-pathn' kuluttaja.ts\nimport MyExportedClass = vaatia('./my-module');\n\nconst instance = new MyExportedClass();\nconsole.log(instance.greet()); täytyy käyttää JavaScript-kirjastoa, joka käyttää parametria `module.exports = ...` ja `esModuleInterop`-asetuksena on `false` (tai haluat olla selkeä).\n2. **CommonJS/AMD-yhteensopivuuden kirjoittamismoduulit:** Jos kirjoitat TypeScript-kirjastoa, jonka on oltava helposti kulutettavissa vanhemmissa ComD`port-projekteissasi, sinun/AM:n on ehkä oltava helppokäyttöinen. vienti.\n3. **Compiler Target `commonjs` tai `amd`:** Tämä syntaksi on osuvin, kun TypeScript-kääntäjän `target- tai `module`-asetukseksi on asetettu esimerkiksi `commonjs` tai `amd`.\n\n**Kääntäjällä `esModuleInterop:**Indu`n`nmodern` (oletusasetus):** on otettu käyttöön tiedostossa `tsconfig.json, TypeScript tarjoaa paremman yhteensopivuuden CommonJS-moduulien kanssa käyttämällä tavallista ES-moduulisyntaksia (`import MyDefaultExport from 'commonjs-module'). Tällaisissa tapauksissa `import = request()`:n suora käyttö tulee harvemmaksi kuluttaessa CommonJS-moduuleja, vaikka jotkin vanhemmat Scripta-skriptit saattavat silti olla käytössä. vienti.\n\n**Virheelliset vastaukset:**\n* Se ei ole nykyaikainen ECMAScript-standardi, ES-moduulit käyttävät `vientioletusarvoa` (`export const...`) ja `import... from...`.\n* Vaikka se sisältää moduulin rajoja, sen ensisijainen tarkoitus ei ole vain yksittäisen vienti-/-moduulin uudelleennimeäminen. Se eroaa "export * from "./module';", joka vie uudelleen kaikki nimetyt viennit tai toisen ES-moduulin oletusviennin."
      },
      {
        "question": "Mikä on heterogeeninen enum TypeScriptissä ja mikä on niiden käytön mahdollinen haittapuoli?",
        "answers": [
          {
            "answer": "Enum, jossa jäsenillä on erilaiset taustalla olevat numeeriset arvot, joka on vakio kaikille numeerisille enumeille."
          },
          {
            "answer": "Enum, joka sekoittaa merkkijonon kirjaimellisia jäseniä ja numeerisia jäseniä. Haittapuolena on, että ne voivat olla vähemmän ennustettavissa ja vaikeampi järkeillä sekatyyppien vuoksi."
          },
          {
            "answer": "Enum, johon pääsee vain merkkijononäppäimillä, ei numeroindekseillä. Huono puoli on käänteisen kartoituksen puute."
          },
          {
            "answer": "Enum, joka on ilmoitettu const-avainsanalla, joka saa sen jäsenet käyttäytymään eri tavalla suorituksen aikana."
          }
        ],
        "answer": "Enum, joka sekoittaa merkkijonon kirjaimellisia jäseniä ja numeerisia jäseniä. Haittapuolena on, että ne voivat olla vähemmän ennustettavia ja vaikeampi järkeillä sekatyyppien vuoksi."
        "explanation": "TypeScriptin **heterogeeninen luettelo** on luettelo, joka sisältää eri taustatyyppien jäseniä, erityisesti sekoittaen **merkkijonon kirjainarvoja** ja **numeerisia arvoja**.\n\n**Esimerkki:**\n```typescript\n_enum Tila {\n Odottaa, // Numero\n\n, oletusarvo on /cc/ESSss0 literal\n Failed = 1, // Numeerinen\n Uudelleen = 'RETRY_LATER' // Merkkijono kirjaimellinen\n}\n\nsalpaa nykyinen tila: Status.Pending // currentStatus on 0 (numero)\ncurrentStatus = Status.Success\ESS"SUCC; (merkkijono)\n```\n\nVaikka TypeScript sallii heterogeeniset enumit, niitä ei yleensä suositella** useista syistä:\n\n**Mahdolliset haittapuolet:**\n1 **Tyyppisekaannukset ja arvaamattomuus:** Jos jäsenet voivat olla joko numeroita tai merkkijonoja, näiden arvojen ymmärtäminen voi olla vaikeampaa molemmat tyypit, jotka voivat johtaa monimutkaisempiin logiikka- tai tyyppisuojauksiin.\n ```typescript\n function handleStatus(s: Status) {\n if (typeof s === 'number') {\n // Käsittele numeerista tilaa (Odottaa, Epäonnistui)\n console.log(`Numeerinen tila: ${s}``; Yritä uudelleen)\n console.log(`String status: ${s.toUpperCase()}`);\n }\n }\n ```\n2. **Reduced Type Safety:** Enumien ensisijainen etu on luoda joukko erillisiä, nimettyjä vakiotyyppejä, jos niitä ei käsitellä huolellisesti.** enum-jäsenet muuttuvat, sillä voi olla laajempi vaikutus niitä kuluttavaan koodikantaan.\n4 **JavaScript-ulostulo:** Heterogeenisille enumeille luotu JavaScript-objekti voi olla myös hieman monimutkaisempi tarkastaa, jos luotat sen ajonaikaiseen rakenteeseen, vaikka TypeScript käsittelee kirjoittamisen yleensä oikein.\n\n**Paras käytäntö on yleensä**. täysin merkkijonopohjainen Jos sinulla on käsitteellisesti erityyppisiä tiloja, harkitse erillisten enum- tai yhdistelmätyyppien käyttöä.\n\n```typescript\n// Suositeltava: Kaikki numeeriset tai kaikki merkkijonot\nenum NumericStatus { Odottaa, epäonnistunut }\nenum StringStatus { Success 'TRY'TRUCCESS = " }\n\n// Tai käyttämällä merkkijonoliitoksia (usein suositeltuina nyt)\ntype RequestState = 'onnistunut' | 'epäonnistui' | sekoitus numero- ja merkkijonotyyppejä.\n* Heterogeenisissa enumeissa voi silti olla käänteinen vastaavuus niiden numeeristen jäsenten osalta.
      },
      {
        "question": "Mitä vaikutus `noUncheckedIndexedAccess`-kääntäjävaihtoehdolla on tiedostossa `tsconfig.json`?",
        "answers": [
          {
            "answer": "Se estää taulukon elementtien tai objektien ominaisuuksien käyttämisen indeksiallekirjoituksen avulla, jos avain ei ole kirjaimellista tyyppiä."
          },
          {
            "answer": "Se lisää `| undefined` minkä tahansa ominaisuuden tyyppiin, jota käytetään indeksiallekirjoituksen kautta (esim. `obj[avain]` tai `arr[index]`), pakottaa `määrittämättömien` arvojen tarkistamiseen.
          },
          {
            "answer": "Se varmistaa, että kaikki taulukon indeksit tarkistetaan numeerisesti ajon aikana rajojen ylittävien virheiden estämiseksi."
          },
          {
            "answer": "Se estää indeksiallekirjoitusten (`[avain: merkkijono]: mikä tahansa`) käytön tyyppimäärittelyissä."
          }
        ],
        "answer": "Se lisää "| undefined" minkä tahansa ominaisuuden tyyppiin, jota käytetään indeksiallekirjoituksen kautta (esim. "obj[avain]" tai "arr[index]"), pakottaa tarkistamaan "undefined"-arvot.",
        "explanation": "NoUncheckedIndexedAccess-kääntäjä-vaihtoehto tiedostossa "tsconfig.json" (saatavilla TypeScript 4.1:stä lähtien) muuttaa tapaa, jolla TypeScript käsittelee pääsyä ominaisuuksiin indeksiallekirjoitusten (objekteille) ja elementtien pääsyn kautta taulukoille.\n\n**Ilman `noUnchecked-indeksoitua tai kun se on indeksoitu `false`):**\nKun käytät taulukon elementtiä tai objektin ominaisuutta indeksiallekirjoituksella, TypeScript olettaa pääsyn onnistuvan ja palauttaa ilmoitetun elementin/ominaisuustyypin arvon. Se ei automaattisesti ota huomioon, että avainta ei ehkä ole olemassa tai että indeksi saattaa olla rajojen ulkopuolella, mikä voi johtaa komentoon "undefined" ajon aikana. 'compilerOptions': { 'noUncheckedIndexedAccess': false (tai ei asetettu) } }\n\nconst arr: number[] = [10, 20];\nconst val1 = arr[0] // arvo1 on tyyppinumero\nconst val2 = arr[2]; runtime)\n\ninterface StringMap { [avain: merkkijono]: merkkijono }\nconst map: StringMap = { a: 'Liisa' };\nconst name1 = map.a; // nimi1 on tyyppi merkkijono\nconst name2 = map.b // name2 on tyyppimerkkijono (vaikkakin\n``s)\n`s; `noUncheckedIndexedAccess: true`:**\nKun tämä vaihtoehto on käytössä, mikä tahansa pääsy indeksiallekirjoituksen (esim. `object[stringKey]` tai `array[numberIndex]`) kautta johtaa tyyppiin, joka sisältää `| undefined`.\nTämä pakottaa sinut tarkastamaan nimenomaisesti määrittämättömän koodin suorittamalla ajoarvon ennen `untime-arvoa. indeksipääsy ei ehkä anna määritettyä arvoa.\n\n```typescript\n// tsconfig.json: { 'compilerOptions': { 'noUncheckedIndexedAccess': true, 'strictNullChecks': true } }\n\n\nconst =0 arr:0, [vakioarvo 0]; arr[0]; // val1 on tyyppinumero |. undefined\nconst a: 'Alice' };\nconst name1 = map.a // nimi1 on tyyppi merkkijono |. // nimi2 on tyyppi merkkijono |. OK\n}\n```\n\n**Edut:**\n* **Parannettu tyyppiturvallisuus:** havaitsee mahdolliset ajonaikaiset virheet, jos "undefined" käytetään ikään kuin se olisi määritetty arvo.\n* **Tarkempi kirjoittaminen:** Heijastaa indeksoidun käytön todellista luonnetta, mikä voi tuottaa 'undefined'-vaihtoehtoa parhaiten. myös käytössä.\n\n**Virheelliset vastaukset:**\n* Se ei estä pääsyä, se muokkaa tuloksena olevaa tyyppiä.\n* Se on käännösajan tyyppinen järjestelmäominaisuus, ei ajonaikainen tarkistus rajojen ulkopuolisten virheiden varalta.\n* Se ei estä indeksiallekirjoituksia määritelmissä, se vaikuttaa niiden kautta käytettyihin arvoihin.
      },
      {
        "question": "Kuinka voit kirjoittaa TypeScript-vahvistusfunktion `assertIsString`, joka väittää, että arvo on merkkijono, ja jos ei, se aiheuttaa virheen, samalla kun se kaventaa arvon tyyppiä kutsualueella?",
        "answers": [
          {
            "answer": "funktio assertIsString(arvo: tuntematon): väittää arvo on merkkijono {\n if (arvon tyyppi !== 'merkkijono') heittää uusi Error('Ei merkkijono!');\n}"
          },
          {
            "answer": "funktio assertIsString(arvo: tuntematon): boolean {\n if (typeof value !== 'merkkijono') heittää uusi Error('Ei merkkijono!');\n return true;\n}"
          },
          {
            "answer": "funktio assertIsString(arvo: tuntematon): merkkijono {\n if (arvon tyyppi !== 'merkkijono') throw new Error('Ei merkkijono!');\n palauttaa arvon;\n}"
          },
          {
            "answer": "funktio assertIsString(arvo: tuntematon): void {\n if (typeof value !== 'merkkijono') heittää uusi Error('Ei merkkijono!');\n // Tyyppiä ei kavenneta\n}"
          }
        ],
        "answer": "funktio assertIsString(arvo: tuntematon): väittää arvo on merkkijono {\n if (typeof value !== 'merkkijono') throw new Error('Ei merkkijono!');\n}",
        "explanation": "**Assertion Functions (`asserts condition`)**\n\nAssertion Functions ovat TypeScriptin ominaisuus (3.7 alkaen), jonka avulla voit ilmoittaa, että funktio antaa virheen, jos tietty ehto ei täyty. Vielä tärkeämpää on tyyppitarkistuksen kannalta, ne voivat myös antaa kääntäjälle signaalin, että jos funktiolla on kapea ominaisuus. Palauta nyt normaalisti ('i. ei.) kirjoita jäljellä oleva laajuus.\n\n**Syntaksi:**\nVäitefunktion palautustyyppi käyttää "asserts"-avainsanaa, jota seuraa ehto (usein tyyppipredikaatti, kuten "arvo on merkkijono" tai vain muuttujan nimi, jos vakuutat sen totuudenmukaisuuden "vahvistusehto".\n`funktio fnName(param:Tsyampe): Lisää ...Tyampe): }`\nTai yleisen ehdon vahvistamiseen:\n`function assert(ehto: mikä tahansa, viesti: merkkijono): asserts-ehto { ... }`\n\n**Oikea toteutus `assertIsString`:**\n```typescript\nfunction assertIsString(arvo: tuntematon, viesti: {\sseing-arvo ei ole string) if (typeof value !== 'merkkijono') {\n heittää uusi Virhe(viesti);\n }\n // Ei vaadi eksplisiittistä palautusarvoa käytettäessä 'assertia' tyypin predikaattivahvistuksessa\n}\n\nfunktio processValue(syöte: tuntematon) {\n // console.log/input(er.to); 'tuntematon'.\n\n assertIsString(input);\n\n // Tämän pisteen jälkeen TypeScript tietää, että 'input' PITÄÄ olla merkkijono\n // koska assertIsString olisi muuten aiheuttanut virheen.\n console.log(input.toUpperCase()) on nyt 'input' merkkijono.\n}\n\nprocessValue('hello');\n// processValue(123); // Tämä aiheuttaisi virheen assertIsStringin sisällä\n```\n\n**Kuinka se toimii tyypin Narrowing:**\nKun `assertIsString(input)` kutsutaan virheeksi:\n* on virhe. `processValue' pysähtyy.\n* Jos "input" *on* merkkijono, "assertIsString" päättyy normaalisti.\n* Koska "assertIsString" on ilmoitettu "asserts value is string", TypeScript ymmärtää, että jos funktio ei heittäydy, niin 'value' (jonka on syötettävä 'in'st-koodirenkaaseen) seuraa kutsua `assertIsString`.\n\n**Virheelliset vastaukset:**\n* Palauttaa `boolean`: Tämä tekisi siitä säännöllisen suojausfunktion, jota käytetään kuten `if (isString(value)) { ... }`, ei väitefunktio, joka heittää ja kaventaa onnistuneen palautuksen yhteydessä.\n* Palauttaa merkkijonon, tai on `s-funktio, joka palauttaa heittää, vaikka se on hyödyllinen, mutta se ei ole erityinen "asserts" -syntaksi ohjausvirtaan perustuvalle kaventavalle puhelulle.\n* Palauttaa "void" ilman "asserts": Tämä funktio heittäisi, mutta TypeScript ei saa mitään tietoa, joka kaventaa "arvo" kutsualueella."
      },
      {
        "question": "Kuinka voit kirjoittaa TypeScript-funktion `processTuple`, joka hyväksyy monikon, jolla on tietty rakenne (esim. merkkijono, sitten numero, sitten valinnainen boolean) käyttämällä rest-parametreja ja päättelee tyypit oikein?",
        "answers": [
          {
            "answer": "funktio processTuple(...args: [merkkijono, numero, boolean?]): void { const [nimi, ikä, aktiivinen] = args; /* ... */ }"
          },
          {
            "answer": "funktio processTuple(...args: (merkkijono | numero | boolean)[]): void { /* vähemmän tyyppiä turvallinen */ }"
          },
          {
            "answer": "funktio processTuple(args: [nimi: merkkijono, ikä: numero, aktiivinen?: boolean]): void { /* args on monikko suoraan */ }"
          },
          {
            "answer": "funktion prosessiTuple<T laajentaa [merkkijono, numero, boolean?]>(...args: T): void { const [nimi, ikä, aktiivinen] = args; /* ... */ }"
          }
        ],
        "answer": "funktio processTuple(...args: [merkkijono, numero, boolean?]): void { const [nimi, ikä, aktiivinen] = args; /* ... */ }",
        "explanation": "TypeScript mahdollistaa lopun parametrien (`...args`) vahvan kirjoittamisen monikkotyypeinä. Tämä on erittäin hyödyllistä, kun haluat funktion hyväksyvän kiinteän argumenttijonon tietyillä tyypeillä, mutta silti käyttää loput-parametrien syntaksia.\n\n**Oikea syntaksi kirjoitettaessa Rest-parametreja Tuple-muodossa:**\n``gs prosessin string number(... boolean?]): void {\n const [nimi, ikä, aktiivinen] = args // Destructuring on kätevä täällä boolean |. undefined\n } else {\n console.log('Aktiivinen tila ei toimitettu.');\n }\n}\n\n// Kelvolliset kutsut:\nprocessTuple('Alice', 30, true);\nprocessTuple('Bob', 25);\n\n/s/" Virhe: Odotettiin 2-3 argumenttia, mutta saatiin 1.\n// processTuple('Dave', 'neljäkymmentä'); // Virhe: tyyppiä 'string' olevaa argumenttia ei voi määrittää tyypin 'number' parametrille.\n```\n\n**Selitys:**\n* `string *,]`: `...args`: ilmoittaa `args'n lepoparametriksi, mikä tarkoittaa, että se kerää kaikki jäljellä olevat funktiolle välitetyt argumentit taulukkoon.\n * `[merkkijono, numero, boolean?]`: Tämä on **tuple-tyyppi**. Se määrittää, että `args':n on oltava taulukon kaltainen rakenne, jossa:\n * Ensimmäisen elementin (*`st`) on oltava 0]. (`args[1]`) on oltava `luku`.\n * Kolmas elementti (`args[2]`) on valinnainen (johtuen `?`) ja sen on oltava `boolean`, jos se on annettu.\n\n**Miksi tämä on tehokas:**\n* **Tyyppiturvallisuus:** Varmistaa oikean määrän ja tyyppisiä argumentteja.** Argumenttien oikea määrä ja tyypit. **Työkalut:** Tarjoaa erinomaisen automaattisen täydennyksen ja tyypin tarkistuksen IDE:issä.\n\n**Virheelliset vastaukset:**\n* `function processTuple(...args: (merkkijono | numero | boolean)[]): void { ... }`: Tämä kirjoittaa `args` taulukoksi, jossa *jokainen elementti* voi olla merkkijono, numero tai rajoitus on paljon vähemmän tyyppiturvallinen kuin monikko.\n* `funktio processTuple(args: [nimi: merkkijono, ikä: numero, aktiivinen?: boolean]): void { ... }`: Näin kirjoitat *yksi parametri*, jonka oletetaan olevan monikko. Kysymys pyytää käyttämään *rest-parametreja* (`... 30])`, `args` olisi `['Alice', 30]`, jos kutsuisit sitä nimellä `processTuple('Alice', 30)`, se olisi virhe, koska se odottaa yhtä monikkotyyppistä argumenttia.\n* `funktio processTuple<T laajentaa [merkkijono, numero, boolean T:n käyttö:]>(...:`) rajoittaa "T" monikkotyyppiin, se on tarpeeton yleisluontoinen kerros yksinkertaisesti kirjoittamalla loput parametrit suoraan "...args" -tiedostoon on selkeämpi ja idiomaattisempi tässä erityistapauksessa.
      },
      {
        "question": "Mitä TypeScript-apuohjelmatyyppi `Awaited<T>` tekee, ja missä tilanteessa se on hyödyllisin?",
        "answers": [
          {
            "answer": "Se poimii async-funktion palautustyypin, joka on samanlainen kuin ReturnType, mutta erityisesti async-funktioille."
          },
          {
            "answer": "Se purkaa rekursiivisesti "Promise"-tyypit. Esimerkiksi "Odotettu<Promise<Lupaus<merkkijono>>>" olisi "merkkijono". Se on hyödyllinen mallinnettaessa "wait"-lausekkeen tulosta mahdollisesti sisäkkäisistä lupauksista."
          },
          {
            "answer": "Se muuntaa synkronisen funktiotyypin asynkroniseksi käärimällä sen palautustyypin "Promise"-tekstiin."
          },
          {
            "answer": "Se tarkistaa, onko T-tyyppi lupaus, ja palauttaa arvon "true" tai "false".
          }
        ],
        "answer": "Se purkaa rekursiivisesti `Promise`-tyypit. Esimerkiksi `Odotettu<Promise<Promise<merkkijono>>>` olisi merkkijono. Se on hyödyllinen mallinnettaessa ` odota` tulosta mahdollisesti sisäkkäisistä lupauksista.",
        "explanation": "Odotettu<T>-apuohjelmatyyppi (joka on otettu käyttöön TypeScript 4.5:ssä) on suunniteltu mallintamaan 'wait'-avainsanan käyttäytymistä JavaScriptissä, erityisesti kun käsitellään lupauksia tai muita 'waitable'-tyyppejä (tyyppejä, joissa on `.then(onfulfilled, onrejected)**funktsionaalinen\nrejectality**Core\n). purkaa `Promise`-tyypit.\n* Jos `T` ei ole lupauksen kaltainen tyyppi, `Odotettu<T>` ratkaisee itsensä `T:ksi.\n\n**Esimerkkejä:**\n```typescript\ntype T0 = Odotettu<Lupaus<merkkijono>>  T0 on merkkijono\nlupausnumero<> = A; (rekursiivisesti purettu)\ntype T2 = Odotettu<merkkijono |. // T2 on merkkijono | (syy: mikä tahansa) => mikä tahansa: mikä tahansa;\n}\ntyyppi T4 = Odotettu <Silloin<Lupaus<numero>>> // T4 on numero\n```\n\n**Käyttötilanne:**\nSen ensisijainen käyttötapa on mallintaa tarkasti tyyppi, jonka saat, kun olet käyttänyt `a sync`-funktiota, arvo on `Async`, a*. `wait` keskeyttää suorituksen, kunnes lupaus ratkeaa, ja jatkaa sitten ratkaistulla arvolla (tai heittää hylkäyssyyn).\n* Jos arvo ei ole lupaus, `wait` palauttaa olennaisesti itse arvon.\n\n`Odotettu<T>` auttaa määrittelemään tyyppejä, jotka kuvastavat tätä purkamiskäyttäytymistä tai lupausketjut saattavat palauttaa itseään monimutkaisissa yhteyksissä. olla lupauksia.\n\nHarkitse yleistä funktiota, joka ottaa lupauksen ja käsittelee sen tuloksen:\n```typescript\nasync-funktion prosessiPromise<P extends Promise<any>>(\nprom: P\n): Lupaus<{ alkuperäinen: P awaitedValue: Odotettu<P> }> {\n const {awaitedValuen = awaitedValuen; };\n}\n\nasync function main() {\n const p1 = Promise.resolve(10) // Lupaus<numero>\n const res1 = odota prosessiaPromise(p1);\n // res1.awaitedValue on tyyppinumero (Odotettu<Promise<numero>>)\n\n const p2); Promise.resolve(Lupaus.resolve('hello')); // Lupaus<Lupaus<merkkijono>>\n const res2 = odota prosessiaPromise(p2);\n // res2.awaitedValue on merkkijono (Odotettu<Promise<Lupaus<merkkijono>>>)\n}\n`**Anwer:n** `ReturnType<T>` purkaa minkä tahansa funktion `Odotettu<ReturnType<F>>` -funktion, jota käytetään async-funktiolle `F`, mutta `Odotettu` itse tarkoittaa minkä tahansa Promise-tyyppisen tyypin purkamista, ei vain funktion palautustyyppejä.\n* Se purkaa Promises-tyypit synch-tyyppiin muunnos, ei Boolen tarkistus, kuten tyyppivartija tarjoaisi."
      },
      {
        "question": "Kuinka voit saavuttaa nimellisen kirjoittamisen TypeScriptissä tyypille, joka eroaa sen taustalla olevasta primitiivityypistä (esim. luodaan erillinen UserID-tyyppi, joka on merkkijono, mutta jota ei voida määrittää yleisestä merkkijonosta)?",
        "answers": [
          {
            "answer": "Käyttämällä tyyppialiasta: `type UserID = string;` Tämä tekee käyttäjätunnuksesta erillisen."
          },
          {
            "answer": "Käyttämällä enum: `enum UserID { ID = 'ID' }` ja käyttämällä `Käyttäjätunnus.ID` tyyppinä."
          },
          {
            "answer": "Käyttämällä risteystyyppejä, joissa on ainutlaatuinen tuotemerkkiominaisuus: `type UserID = string & { readonly __brand: 'UserID' };`"
          },
          { "answer": "Luomalla luokan `UserID laajentaa merkkijonoa {}`." }
        ],
        "answer": "Käyttämällä risteystyyppejä, joissa on ainutlaatuinen tuotemerkkiominaisuus: `type UserID = string & { readonly __brand: 'UserID' };`",
        "explanation": "TypeScriptillä on rakenteellinen tyyppijärjestelmä, mikä tarkoittaa, että tyypit ovat yhteensopivia, jos niiden rakenne täsmää. Tämä voi joskus olla liian lempeä, varsinkin kun halutaan varmistaa, että johonkin tarkoitukseen (esim. User ID:ksi) käytettyä "merkkijonoa" (tai "numeroa") ei käytetä vahingossa, kun "merkkijono" toiseen tarkoitukseen (esim. vaikka molemmat ovat vain tuotetunnus) merkkijonoja.\n\n**Nimellistä kirjoittamista** (saavutetaan nimellä) voidaan emuloida TypeScriptissä käyttämällä tekniikkaa nimeltä **brändäys** tai **tagging**.\n\nYleisin tapa on leikata primitiivinen tyyppi objektityypin kanssa, jolla on ainutlaatuinen, olematon ominaisuus ('brändi' tai \'tekniikka'Corrn'tunniste'). (Brändäys):**\n```typescript\n// 1. Määrittele tuotemerkin tyyppi\ntype UserID = string & { readonly __brand: 'UserID' };\ntype ProductID = string & { readonly __brand: 'ProductID' };\n\n// 2. Luo tarvittavat tuotemerkkiarvot\ntyyppi createUserID(id: string): Käyttäjätunnus {\npalautustunnus käyttäjätunnuksena;\n}\n\nfunktio createProductID(id: merkkijono): ProductID {\npalautustunnus tuotetunnuksena;\n}\n\n// 3. Käyttö\nconst userId1 = createUserID('user-123');\nst = cont createProductID('prod-456');\n\nfunction processUser(id: UserID) {\n console.log(`Käsittelevä käyttäjä: ${id}`);\n}\n\nfunction processProduct(id: ProductID) {\n console.log(`Processing product: ${id}\/us); processUser(productId1); // Virhe: Tyyppiä 'ProductID' ei voi määrittää käyttäjätunnukselle.\n // Tyypeillä on erilliset ilmoitukset yksityisestä ominaisuudesta '__brand'.\n\n// processUser('some-random-string' // Virhe: Tyyppi '/server'-tyyppi' on \n'string'; ei ole määritettävissä '{ readonly __brand: 'UserID' }'.\n\nole genericString: string = 'generic';\n// processUser(genericString) // Virhe\n\n// Käyttääksesi taustalla olevaa merkkijonoarvoa:\nconsting:n alimerkkijono; merkkijono\n```\n\n**Brändin selitys:**\n* `string & { readonly __brand: 'UserID' }`: Tämä tarkoittaa, että `Käyttäjätunnus' on jotain, joka on *sekä* merkkijono että objekti, jolla on (käsitteellinen) vain luku -ominaisuus `__brandalID`, jonka tyyppi on \inUnsering'. merkkijonolla ei ole __brand-ominaisuutta, sitä ei voi määrittää suoraan UserID:lle.\n* Ominaisuutta __brand ei ole ajon aikana. nimelliset tyypit.\n\n**Virheelliset vastaukset:**\n* `type UserID = string;`: Tämä on vain tyyppialias `Käyttäjätunnus`, joka on täysin vaihdettavissa `merkkijonon` kanssa, eikä siinä ole nimellistä eroa.\n* `enum UserID { ID = 'ID' }`: tämä luo yhden tyypin.` ID:n `UserID` (itse enum-tyyppi), joka on erillinen, mutta se ei ole merkkijono*, se on enum-jäsen. Jos halusit `UserID`:n olevan merkkijono, jolla on tietyt sallitut arvot, merkkijonoluettelot tai merkkijonoliitokset ovat parempia.\n* `class UserID laajentaa merkkijonotyyppiä, ei suositella luojan tyyppiä. tähän tarkoitukseen TypeScriptissä se esittelee prototyyppiketjuja ja objektikääreitä primitiivien ympärille, mikä voi olla hankalaa ja vaikuttaa suorituskykyyn.
      }
    ]
  },
  {
    "name": "AWS CI/CD GitLabilla ja AWS CDK:lla (Advanced)",
    "image": "https://images.unsplash.com/photo-1523961131990-5EA7c61b2107",
    "questions": [
      {
        "question": "Mikä on `cdk synth` -komennon ensisijainen tarkoitus GitLab CI/CD -liukuhihnassa, joka ottaa käyttöön AWS CDK -sovelluksen?",
        "answers": [
          { "answer": "Infrastruktuurin käyttöönotto suoraan AWS:ssä." },
          {
            "answer": "Syntetisoida CDK-sovellus CloudFormation-malliksi."
          },
          { "answer": "Projektiriippuvuuksien asentaminen." },
          { "answer": "Yksikkötestien suorittaminen CDK-rakenteille." }
        ],
        "answer": "Syntetisoida CDK-sovellus CloudFormation-malliksi."
        "explanation": "Komento `cdk synth` käsittelee CDK-koodisi ja tulostaa CloudFormation-mallin, joka voidaan sitten ottaa käyttöön. Se ei ota käyttöön resursseja itse."
      },
      {
        "question": "Mikä GitLabin CI/CD-komponentti on vastuussa vaiheiden, töiden ja komentosarjojen määrittämisestä, jotka muodostavat CI/CD-putken CDK-sovelluksen käyttöönottoa varten?",
        "answers": [
          { "answer": "GitLab Runner" },
          { "answer": "`.gitlab-ci.yml` tiedosto" },
          { "answer": "GitLab Web UI" },
          { "answer": "AWS CodePipeline" }
        ],
        "answer": "`.gitlab-ci.yml` tiedosto",
        "explanation": ".gitlab-ci.yml-tiedosto on ydinmääritystiedosto, jossa määrität CI/CD-putkilinjasi rakenteen ja suorituskulun GitLabissa."
      },
      {
        "question": "Kun otettaessa käyttöön käyttöliittymäpalvelua (esim. React-sovellusta) käyttämällä AWS CDK:ta GitLab CI/CD -putkessa, mitä AWS-palvelua käytetään yleisesti staattisen omaisuuden isännöimiseen?",
        "answers": [
          { "answer": "Amazon EC2" },
          { "answer": "AWS Lambda" },
          { "answer": "Amazon S3 (Simple Storage Service)" },
          { "answer": "Amazon RDS" }
        ],
        "answer": "Amazon S3 (yksinkertainen tallennuspalvelu)",
        "explanation": "Amazon S3 on erittäin skaalautuva ja kustannustehokas palvelu staattisen verkkosivuston sisällön tallentamiseen ja tarjoamiseen, mikä tekee siitä ihanteellisen käyttöliittymäsovelluksiin. Usein Amazon CloudFrontia käytetään yhdessä S3:n kanssa CDN-ominaisuuksia varten."
      },
      {
        "question": "Kuinka AWS-tunnistetietoja pitäisi ihanteellisesti hallita GitLab CI/CD-putkessa, jotta CDK voi ottaa käyttöön resursseja?",
        "answers": [
          {
            "answer": "Kovakoodaus AWS-käyttöavaimet suoraan `.gitlab-ci.yml`-tiedostoon."
          },
          {
            "answer": "AWS-käyttöavaimien tallentaminen GitLab CI/CD -muuttujiksi (naamioitu ja suojattu)."
          },
          {
            "answer": "IAM-käyttäjän tunnistetietojen siirtäminen Git-tietovarastoon."
          },
          {
            "answer": "Käytetään jaettua EC2-ilmentymän profiilia kaikille liukuhihnatöille."
          }
        ],
        "answer": "AWS-käyttöavaimien tallentaminen GitLab CI/CD -muuttujiksi (naamioitu ja suojattu).",
        "explanation": "GitLabin CI/CD-muuttujat ovat turvallinen tapa tallentaa arkaluontoisia tietoja, kuten AWS-tunnistetietoja. Ne voidaan peittää työlokeissa ja suojata rajoittamaan niiden altistumista tietyille haareille tai ympäristöille. IAM-roolien käyttäminen OIDC-liiton kanssa on vielä turvallisempi ja suositeltavampi tapa, jos mahdollista."
      },
      {
        "question": "Mikä näistä AWS-laskentapalveluista on yleinen kohde konttisovelluksille taustapalvelulle (esim. Node.js API), joka on otettu käyttöön AWS CDK:n kanssa GitLabin kautta?",
        "answers": [
          { "answer": "Amazon S3" },
          { "answer": "Amazon CloudFront" },
          {
            "answer": "Amazon Elastic Container Service (ECS) tai Amazon Elastic Kubernetes Service (EKS)"
          },
          { "answer": "AWS Snowball" }
        ],
        "answer": "Amazon Elastic Container Service (ECS) tai Amazon Elastic Kubernetes Service (EKS)",
        "explanation": "ECS ja EKS ovat AWS:n hallittuja säilön organisointipalveluita, jotka soveltuvat konttipohjaisten taustasovellusten käyttöönottoon, hallintaan ja skaalaukseen. AWS Lambda on toinen vaihtoehto palvelimettomille taustajärjestelmille."
      },
      {
        "question": "Mikä on cdk:n käyttöönoton rooli CDK-sovelluksen CI/CD-liukuhihnassa?",
        "answers": [
          { "answer": "Tarkistaa CDK-koodin syntaksivirheiden varalta." },
          {
            "answer": "Vertaa nykyistä pinoa käyttöön otettuun pinoon ja näyttää erot."
          },
          {
            "answer": "Syntetisoidun CloudFormation-mallin käyttöönotto AWS-tilillesi."
          },
          { "answer": "AWS-ympäristön käynnistäminen CDK:ta varten." }
        ],
        "answer": "Syntetisoidun CloudFormation-mallin käyttöönotto AWS-tilillesi.",
        "explanation": "Komento "cdk deploy" ottaa CloudFormation-mallin, jonka on luonut "cdk synth" (tai syntetisoi sen, jos sitä ei ole vielä tehty) ja huolehtii tai päivittää AWS-tilisi resurssit."
      },
      {
        "question": "Mikä on välimuisti-avainsanan tarkoitus .gitlab-ci.yml-työssä?",
        "answers": [
          { "answer": "Töiden artefaktien tallentamiseksi myöhempiä vaiheita varten." },
          {
            "answer": "Nopeuttaa työn suorittamista käyttämällä uudelleen ladattuja riippuvuuksia tai rakentamalla aiempien ajojen tuloksia."
          },
          { "answer": "Työssä käytettyjen arkaluonteisten muuttujien salaamiseen." },
          { "answer": "Työhön käytettävän Docker-kuvan määrittäminen." }
        ],
        "answer": "Nopeuttaa työn suorittamista käyttämällä uudelleen ladattuja riippuvuuksia tai rakentamalla aiempien ajojen tuloksia."
        "explanation": "Cache-avainsanaa käytetään määrittämään luettelo tiedostoista ja hakemistoista, jotka tallennetaan välimuistiin työn suoritusten välillä, mikä voi nopeuttaa merkittävästi liukuhihnaa välttämällä riippuvuuksien uudelleenlataamista tai muuttumattomien komponenttien rakentamista."
      },
      {
        "question": "Mikä on AWS CDK:ssa tärkein ero L1 (CFN) -rakenteen ja L2-rakenteen välillä?",
        "answers": [
          { "answer": "L1-konstruktit ovat käyttöliittymää, L2 taustajärjestelmää." },
          {
            "answer": "L1-konstruktit ovat korkean tason abstraktioita järkevillä oletusarvoilla, kun taas L2-konstruktit kartoitetaan suoraan CloudFormation-resursseihin."
          },
          {
            "answer": "L2-konstruktit ovat korkean tason abstraktioita järkevillä oletusasetuksilla ja mukavuusmenetelmillä, kun taas L1-konstruktit kartoitetaan suoraan raakaisiin CloudFormation-resursseihin."
          },
          {
            "answer": "L1-rakenteet ovat vanhentuneita, ja vain L2-rakenteita tulisi käyttää."
          }
        ],
        "answer": "L2-konstruktit ovat korkean tason abstraktioita järkevillä oletusasetuksilla ja mukavuusmenetelmillä, kun taas L1-konstruktit kartoitetaan suoraan raakaisiin CloudFormation-resursseihin."
        "explanation": "L1 (CFN) -rakenteet luodaan automaattisesti CloudFormation-spesifikaatioista, mikä tarjoaa suoran kartoituksen. L2-rakenteet ovat kuratoituja, korkeamman tason abstraktioita, jotka tarjoavat enemmän mukavuutta, järkeviä oletusasetuksia ja yleisten mallien tiivistelmän pienennystä."
      },
      {
        "question": "Mitä AWS IAM -ominaisuutta käytetään yleisesti GitLabin OIDC-palveluntarjoajan tuen kanssa?"
        "answers": [
          {
            "answer": "IAM-käyttäjät, joiden pääsyavaimet on tallennettu GitLab-muuttujiksi."
          },
          { "answer": "IAM-roolit EC2-instanssiprofiileille." },
          {
            "answer": "IAM-roolit, joissa OIDC-identiteetin tarjoaja on määritetty GitLabille."
          },
          { "answer": "AWS Secrets Manager noutaa väliaikaiset tunnistetiedot." }
        ],
        "answer": "IAM-roolit, joissa OIDC-identiteetin tarjoaja on määritetty GitLabille.",
        "explanation": "IAM OIDC -identiteetin tarjoajan käyttäminen antaa GitLabin turvallisesti pyytää väliaikaisia ​​valtuustietoja AWS:ltä ottamalla IAM-roolin, jolloin ei tarvita pitkäikäisiä AWS-käyttöavaimia GitLabin CI/CD-muuttujissa."
      },
      {
        "kysymys": "Kuka tyypillinen komento suoritettaisiin *ennen* cdk deploy -komentoa käyttöliittymän käyttöönoton aikana CDK:ta ja GitLab CI/CD:tä käyttäen valmistelemaan staattiset resurssit S3-sämpylän käyttöönottoa varten?",
        "answers": [
          { "answer": "`npm testi`" },
          { "answer": "`docker build -t frontend .`" },
          { "answer": "`npm run build` tai `yarn build`" },
          { "answer": "`cdk synth`" }
        ],
        "answer": "npm run build" tai "yarn build",
        "explanation": "Useimmissa JavaScript-pohjaisissa käyttöliittymissä (React, Vue, Angular) koontikomento, kuten `npm run build`, kokoaa sovelluksen staattisiksi HTML-, CSS- ja JavaScript-tiedostoiksi, jotka CDK:n S3-käyttöönottorakenne sitten lataa."
      },
      {
        "question": "Mihin `cdk bootstrap` -komentoa käytetään ensisijaisesti?",
        "answers": [
          { "answer": "Uuden CDK-projektin luominen mallista." },
          { "answer": "AWS CDK Toolkitin asentaminen maailmanlaajuisesti." },
          {
            "answer": "Alkuresurssien tarjoaminen AWS-ympäristössä (tili/alue), jota CDK vaatii pinojen käyttöönottamiseksi, kuten resurssien S3-säilö."
          },
          { "answer": "Kaikkien CDK-sovelluksessa määritettyjen pinojen käyttöönotto." }
        ],
        "answer": "Alkuresurssien tarjoaminen AWS-ympäristössä (tili/alue), jota CDK vaatii pinojen käyttöönottamiseksi, kuten resurssien S3-säilö."
        "explanation": "`cdk bootstrap` määrittää tarvittavan infrastruktuurin (esim. S3-säihön tiedostovaroille, IAM-roolit käyttöönottoa varten), jonka CDK tarvitsee suorittaakseen käyttöönotot tietylle AWS-tilille ja -alueelle."
      },
      {
        "question": "Kuinka voit varmistaa, että GitLab CI/CD -työ toimii vain tietyillä juoksijoilla?",
        "answers": [
          { "answer": "Nimeyttämällä työ tietyllä etuliitteellä." },
          {
            "answer": "Ympäristö-avainsanan käyttö työn määrittelyssä."
          },
          {
            "answer": "Tagien määrittäminen juoksijoille ja niiden määrittäminen työn määrittelyssä."
          },
          {
            "answer": "Määrittämällä juoksijan IP-valitut listat projektiasetuksissa."
          }
        ],
        "answer": "Tagien määrittäminen juoksijoille ja niiden määrittäminen työn määrittelyssä."
        "explanation": "Juoksijat voidaan määrittää tunnisteilla (esim. `docker`, `windows`, `gpu`). .gitlab-ci.yml:n työt voivat sitten käyttää tags-avainsanaa määrittääkseen, mitkä juoksijat voivat suorittaa ne."
      },
      {
        "question": "Mitä API Gateway ensisijaisesti tarjoaa, kun otetaan käyttöön taustasovellusliittymä AWS Lambdalla ja API-yhdyskäytävällä CDK:n kanssa?",
        "answers": [
          { "answer": "API-pyyntö- ja vastaustietojen pitkäaikainen tallennus." },
          {
            "answer": "Täysin hallittu laskentaympäristö Lambda-funktion suorittamiseen."
          },
          {
            "answer": "HTTP-päätepiste, pyynnön reititys, valtuutus ja nopeusrajoitus lambda-toimintoillesi."
          },
          { "answer": "Relaatiotietokantapalvelu taustajärjestelmään." }
        ],
        "answer": "HTTP-päätepiste, pyynnön reititys, valtuutus ja nopeusrajoitus Lambda-toimintoillesi."
        "explanation": "Amazon API Gateway toimii "etuovena" Lambda-pohjaisille sovellusliittymillesi, käsittelee saapuvat HTTP-pyynnöt, kutsuu oikean Lambda-toiminnon ja hallitsee asioita, kuten todennusta, valtuutusta, kuristusta ja välimuistia."
      },
      {
        "question": "Jos haluat käyttää yhteistä konfiguraatiota tai muunnosa useisiin CDK-pinon tai sovelluksen rakenteisiin ohjelmallisesti (esim. lisäämällä tietyn tunnisteen kaikkiin S3-säihoihin), mikä CDK-ominaisuus olisi sopivin?",
        "answers": [
          {
            "answer": "Muokkaa syntetisoitua CloudFormation-mallia manuaalisesti."
          },
          { "answer": "CDK-kontekstimuuttujien käyttäminen." },
          { "answer": "CDK-näkökohdan käyttöönotto." },
          { "answer": "Luodaan erillisiä L1-rakenteita kullekin resurssille." }
        ],
        "answer": "CDK-näkökohdan käyttöönotto."
        "explanation": "CDK-näkökohtien avulla voit vierailla ja muokata rakenteita laajuudessa (kuten pinossa tai sovelluksessa) vierailijakuvion avulla. Tämä sopii mainiosti monialaisten ongelmien, kuten tunnisteiden, suojauskäytäntöjen tai vaatimustenmukaisuuden tarkistuksen, soveltamiseen."
      },
      {
        "question": "Mikä on "artefakttien" tehtävä GitLab CI/CD -työssä?",
        "answers": [
          { "answer": "Docker-kuvan määrittäminen työlle." },
          { "answer": "Riippuvuuksien tallentamiseksi välimuistiin liukuhihnaajojen välillä." },
          {
            "answer": "Määrittää tiedostoja ja hakemistoja, jotka tulee siirtää yhdestä työstä seuraaviin töihin myöhemmissä vaiheissa tai ladattavaksi."
          },
          { "answer": "Ympäristömuuttujien tallentamiseksi työlle." }
        ],
        "answer": "Määrittääksesi tiedostot ja hakemistot, jotka siirretään yhdestä työstä seuraaviin töihin myöhemmissä vaiheissa tai ladattavaksi.",
        "explanation": "Työn artefaktit ovat työn luomia tiedostoja (esim. koontitulosteita, testiraportteja), joita voidaan käyttää muissa valmisteltavana olevissa töissä tai jotka voidaan ladata GitLab-käyttöliittymästä."
      },
      {
        "question": "Missä määrittelisit käytettävän Docker-kuvan, suorittimen/muistin allokoinnin ja porttikartoitukset konttipohjaiselle taustapalvelulle, joka on otettu käyttöön Amazon ECS:ssä CDK:n avulla?",
        "answers": [
          { "answer": "GitLab-ajokokoonpanossa." },
          { "answer": "Suoraan Docker-tiedostossa." },
          {
            "answer": "ECS-tehtävämääritelmän sisällä, joka on määritetty käyttämällä CDK-konstruktioita, kuten `ecs.FargateTaskDefinition` tai `ecs.Ec2TaskDefinition`."
          },
          { "answer": "S3-ryhmäkäytännössä." }
        ],
        "answer": "ECS-tehtävämääritelmässä, joka on määritetty käyttämällä CDK-rakenteita, kuten "ecs.FargateTaskDefinition" tai "ecs.Ec2TaskDefinition".",
        "explanation": "ECS Task Definition on suunnitelma sovelluksellesi. Se määrittää säilön kuvan, suorittimen ja muistin, porttikartoitukset, ympäristömuuttujat ja muut parametrit, joita tarvitaan Docker-säilöjesi suorittamiseen ECS:ssä."
      },
      {
        "question": "Mitä `cdk diff` -komento antaa sinun tehdä?",
        "answers": [
          { "answer": "Näytä erot kahden Git-haaran välillä." },
          { "answer": "Ota käyttöön vain muutokset edellisen käyttöönoton jälkeen." },
          {
            "answer": "Vertaa CDK-sovelluksessasi määritettyä pinoa AWS:ssä tällä hetkellä käytössä olevaan pinoon ja näytä ehdotetut muutokset."
          },
          {
            "answer": "Laske ehdotettujen infrastruktuurimuutosten kustannusero."
          }
        ],
        "answer": "Vertaa CDK-sovelluksessasi määritettyä pinoa AWS:ssä tällä hetkellä käytössä olevaan pinoon ja näytä ehdotetut muutokset."
        "explanation": "`cdk diff` on tärkeä komento, jonka avulla tarkastellaan, mitä muutoksia (luodut, päivitykset, poistot) AWS-infrastruktuuriisi tehdään, ennen kuin ne otetaan käyttöön "cdk deploy" -komennolla."
      },
      {
        "question": "Kuinka voit määrittää monivaiheisessa GitLab CI/CD -putkessa, että työ myöhemmässä vaiheessa suoritetaan vasta sen jälkeen, kun tietyt työt aikaisemmassa vaiheessa on suoritettu onnistuneesti, mikä mahdollistaa rinnakkaisen suorittamisen vaiheiden sisällä?",
        "answers": [
          { "answer": "Käytetään riippuvuudet-avainsanaa." },
          {
            "answer": "Tarve-avainsanan käyttäminen vaadittujen töiden luettelon kanssa."
          },
          {
            "answer": "Myöhemmissä vaiheissa olevat työt odottavat automaattisesti kaikkia aikaisempien vaiheiden töitä."
          },
          { "answer": "Asettamalla työn prioriteetit prioriteetti-avainsanalla." }
        ],
        "answer": "Tarve-avainsanan käyttäminen vaadittujen töiden luettelon kanssa."
        "explanation": "Tarpeet-avainsana luo ohjatun asyklisen kaavion (DAG) töiden riippuvuuksista, jolloin työt voivat alkaa heti, kun niiden määritetyt edeltäjätyöt valmistuvat, sen sijaan, että odotettaisiin koko edellisen vaiheen päättymistä."
      },
      {
        "question": "Mikä on Origin Access Identity (OAI) tai Origin Access Control (OAC) tarkoitus, kun palvellaan käyttöliittymäsovellusta S3:sta CloudFrontin kautta?",
        "answers": [
          {
            "answer": "Salli julkisen lukuoikeuden suoraan S3-alueelle."
          },
          {
            "answer": "Tarjoaa käyttäjille IAM-tunnistetiedot S3-säilöä varten."
          },
          {
            "answer": "Rajoita suora pääsy S3-säilöyn varmistamalla, että sisältö toimitetaan vain CloudFrontin kautta."
          },
          { "answer": "Säilön S3-ämpärisisällön välimuistiin reunojen paikoissa." }
        ],
        "answer": "Rajoita suora pääsy S3-säilöyn varmistamalla, että sisältöä tarjotaan vain CloudFrontin kautta."
        "explanation": "OAI (vanhempi) tai OAC (uudempi, suositeltu) sallii CloudFrontin noutaa turvallisesti yksityistä sisältöä S3-säilöstä katsojien puolesta samalla, kun se estää käyttäjiä ohittamasta CloudFrontia ja pääsemästä suoraan S3-säilön sisältöön."
      },
      {
        "question": "Kuinka voit hallita ympäristökohtaisia ​​määrityksiä (esim. eri ilmentymäkokoja dev- ja prod-versioille) AWS CDK -sovelluksessa, joka on otettu käyttöön GitLab CI/CD:n kautta?",
        "answers": [
          { "answer": "Koodaamalla arvot suoraan CDK-konstruktioihin." },
          {
            "answer": "Käyttämällä erillisiä Git-haaroja kullekin ympäristölle ja muokkaamalla CDK-koodia jokaisessa haarassa."
          },
          {
            "answer": "Kontekstimuuttujien välittäminen (`-c avain=arvo`) tai ympäristömuuttujien käyttö cdk synth/deploy -toiminnon aikana GitLab CI -töiden sisällä ja näiden lukeminen CDK-sovelluksessa."
          },
          {
            "answer": "Muokkaa CloudFormation-mallia manuaalisesti `cdk synth' jälkeen."
          }
        ],
        "answer": "Kontekstimuuttujien välittäminen (`-c key=value`) tai ympäristömuuttujien käyttäminen cdk synth/deploy -toiminnon aikana GitLab CI -töissä ja näiden lukeminen CDK-sovelluksessa.",
        "explanation": "CDK-sovelluksia voidaan parametroida kontekstiarvojen avulla ("cdk.jsonista", komentoriviltä tai ympäristömuuttujista). GitLab CI -työt voivat sitten asettaa nämä arvot eri tavalla eri käyttöönottoympäristöissä (esim. dev, staging, prod)."
      },
      {
        "question": "Mikä on .gitlab-ci.yml:n ylätasolla tai työkohtaisesti määritetyn "image" -avainsanan merkitys?",
        "answers": [
          {
            "answer": "Se määrittää AWS ECS:ssä käyttöön otettavan sovelluksen kuvan."
          },
          {
            "answer": "Se määrittää Docker-kuvan, jossa GitLab CI/CD -työ suoritetaan."
          },
          {
            "answer": "Se asettaa taustakuvan GitLab-putkinäkymälle."
          },
          { "answer": "Se linkittää CDK-perusrakennekuvaan." }
        ],
        "answer": "Se määrittää Docker-kuvan, jossa GitLab CI/CD -työ suoritetaan."
        "explanation": "Avainsana "image" kertoo GitLab Runnerille, mitä Docker-kuvaa käyttää suoritusympäristönä CI/CD-työlle, tarjoten tarvittavat työkalut ja riippuvuudet (esim. Node.js, Python, AWS CLI, CDK CLI)."
      },
      {
        "question": "Mitä AWS-palvelua yleensä käyttäisit CDK:n kanssa relaatiotietokannan (esim. PostgreSQL, MySQL) määrittämiseen ja hallintaan taustapalveluasi varten?",
        "answers": [
          { "answer": "Amazon DynamoDB" },
          { "answer": "Amazon S3" },
          {
            "answer": "Amazon RDS (relaatiotietokantapalvelu) tai Amazon Aurora"
          },
          { "answer": "Amazon ElastiCache" }
        ],
        "answer": "Amazon RDS (relaatiotietokantapalvelu) tai Amazon Aurora",
        "explanation": "Amazon RDS tarjoaa hallittuja relaatiotietokantaesiintymiä. Aurora on AWS:n MySQL- ja PostgreSQL-yhteensopiva relaatiotietokanta, joka on rakennettu pilveen. Molempia voidaan valmistaa ja hallita CDK:n avulla."
      },
      {
        "question": "Jos CDK-sovelluksesi on pakattava paikallista koodia, kuten Lambda-funktion käsittelijä tai Docker-kuva paikallisesta Docker-tiedostosta, kuinka CDK käsittelee näitä?",
        "answers": [
          {
            "answer": "Sinun on esiladattava nämä manuaalisesti S3:een tai ECR:ään ennen kuin suoritat `cdk deploy' -toiminnon."
          },
          { "answer": "CDK löytää ja ohittaa paikalliset tiedostot automaattisesti." },
          {
            "answer": "CDK käyttää "resursseja", jotka niputtavat paikallisia tiedostoja/hakemistoja tai rakentavat Docker-otoksia ja lataavat ne Bootstrap S3 -säilöön tai ECR-tietovarastoon käyttöönoton aikana."
          },
          {
            "answer": "Nämä tiedostot upotetaan suoraan CloudFormation-malliin."
          }
        ],
        "answer": "CDK käyttää "resursseja", jotka niputtavat paikallisia tiedostoja/hakemistoja tai rakentavat Docker-kuvia ja lataavat ne käynnistyksen S3-säilöön tai ECR-tietovarastoon käyttöönoton aikana.",
        "explanation": "CDK:n omaisuusmallin avulla voit määrittää Lambda-koodin paikallisesta hakemistosta tai Docker-kuvia paikallisesta Docker-tiedostosta. CDK-käyttöönoton aikana CDK CLI pakkaa ja lataa nämä resurssit AWS:ään (S3 tiedostoille, ECR kuville), jotta CloudFormation voi käyttää niitä."
      },
      {
        "question": "Mikä on 'Protected Variables' tarkoitus GitLab CI/CD -asetuksissa?",
        "answers": [
          { "answer": "Jotta muuttujat ovat vain tiettyjen käyttäjien käytettävissä." },
          { "answer": "Salataan kaikki CI/CD-muuttujat oletuksena." },
          {
            "answer": "Muuttujien paljastaminen vain suojatuilla haaroilla tai tunnisteilla suoritettaville töille, mikä parantaa arkaluonteisten tietojen turvallisuutta."
          },
          {
            "answer": "Estä muuttujia ohittamasta työtason määritelmiä."
          }
        ],
        "answer": "Muuttujien paljastaminen vain suojatuilla haaroilla tai tunnisteilla suoritettaville töille, mikä parantaa arkaluontoisten tietojen turvallisuutta."
        "explanation": "Suojatut muuttujat välitetään vain suojatuissa haaroissa (esim. "main") tai suojatuissa tunnisteissa suoritettaville töille, mikä on paras käytäntö salaisuuksien, kuten käyttöönottotietojen, hallinnassa."
      },
      {
        "question": "Palvelimettomassa taustajärjestelmässä, AWS Lambdan lisäksi, mitä palvelua käytetään yleisesti CDK:n kanssa sovelluksen tilan tai tietojen tallentamiseen erittäin saatavilla olevalla NoSQL-tyylillä?",
        "answers": [
          { "answer": "Amazon RDS" },
          { "answer": "Amazon EBS (Elastic Block Store)" },
          { "answer": "Amazon DynamoDB" },
          { "answer": "AWS-tallennusyhdyskäytävä" }
        ],
        "answer": "Amazon DynamoDB",
        "explanation": "Amazon DynamoDB on täysin hallittu, palvelimeton NoSQL-avainarvo- ja asiakirjatietokanta, joka tarjoaa korkean skaalautuvuuden ja käytettävyyden, joten se on suosittu valinta palvelimettomille sovelluksille, jotka on rakennettu Lambdalla ja CDK:lla."
      },
      {
        "question": "Kuinka voit tuhota kaikki tietyn CDK-pinon luomat AWS-resurssit CDK CLI:n avulla?",
        "answers": [
          {
            "answer": "Poistamalla pinon AWS CloudFormation -konsolista."
          },
          { "answer": "Käyttämällä `cdk delete <StackName>` -komentoa." },
          { "answer": "Käyttämällä `cdk delete <StackName>` -komentoa." },
          {
            "answer": "Poistamalla pinon määritelmä CDK-sovelluksesta ja suorittamalla `cdk deploy`."
          }
        ],
        "answer": "Käyttämällä `cdk tuhota <StackName>` -komentoa.",
        "explanation": "Komento `cdk delete <StackName>` poistaa määritetyn pinon ja kaikki siihen liittyvät resurssit AWS-tililtäsi CDK-sovelluksessasi määritetyllä tavalla."
      },
      {
        "question": "Kuinka voit sisällyttää ulkoisia YAML-määrityksiä päätiedostoon `.gitlab-ci.yml` uudelleenkäytettävyyden ja modulaarisuuden edistämiseksi?",
        "answers": [
          {
            "answer": "Käytetään tuonti-lauseita tiedoston alussa."
          },
          {
            "answer": "Include-avainsanan käyttäminen poluilla paikallisiin tiedostoihin, ulkoisiin URL-osoitteisiin tai malleihin muista projekteista."
          },
          { "answer": "Kopioi ja liitä sisältö suoraan päätiedostoon." },
          {
            "answer": "GitLab CI/CD ei tue ulkoisten YAML-tiedostojen sisällyttämistä."
          }
        ],
        "answer": "Include-avainsanan käyttäminen poluilla paikallisiin tiedostoihin, ulkoisiin URL-osoitteisiin tai malleihin muista projekteista."
        "explanation": "Include-avainsana .gitlab-ci.yml:ssä mahdollistaa monimutkaisten liukuhihnamäärittelyjen jakamisen pienempiin, uudelleenkäytettäviin osiin, jotka voidaan hankkia samasta arkistosta, muista tietovarastoista tai jopa etä-URL-osoitteista."
      },
      {
        "question": "Missä taustapalvelun kehittyneessä CI/CD-putkistossa yleensä suoritetaan "integraatiotestejä", jotka varmistavat palvelusi ja muiden palveluiden (kuten tietokannan) välisen vuorovaikutuksen?",
        "answers": [
          {
            "answer": "Vain kehittäjien paikallisilla koneilla ennen koodin painamista."
          },
          { "answer": "Osa `cdk synth` -komentoa." },
          {
            "answer": "Oma testivaiheessa GitLab CI/CD-putkessa sen jälkeen, kun palvelu on otettu käyttöön testi-/vaiheistusympäristössä."
          },
          { "answer": "Docker-kuvanmuodostusprosessin aikana." }
        ],
        "answer": "Oma testivaiheessa GitLab CI/CD-putkessa sen jälkeen, kun palvelu on otettu käyttöön testi-/vaiheistusympäristössä."
        "explanation": "Integraatiotestit edellyttävät, että palvelu ja sen riippuvuudet (kuten tietokannat tai muut mikropalvelut) ovat käynnissä. Siten ne suoritetaan yleensä CI/CD-liukuhihnassa sen jälkeen, kun ne on otettu käyttöön ei-tuotantoympäristössä."
      },
      {
        "question": "Mihin 'CDK Aspektia' käytetään?",
        "answers": [
          {
            "answer": "Määrittää CDK-konstruktiodokumentaation visuaalisen ulkoasun."
          },
          {
            "answer": "Tietyn tyyppinen L3-rakenne käyttöliittymien rakentamiseen."
          },
          {
            "answer": "Mekanismi, jolla käytetään toimintoja tai muutoksia kaikkiin tietyn tyyppisiin rakenteisiin laajuuden sisällä (esim. pino tai sovellus) vierailijamallin avulla."
          },
          { "answer": "IAM-oikeuksien hallinta CDK-käyttöönottoa varten." }
        ],
        "answer": "Mekanismi, jolla käytetään toimintoja tai muutoksia kaikkiin tietyn tyyppisiin rakenteisiin laajuuden sisällä (esim. pino tai sovellus) vierailijamallin avulla."
        "explanation": "Aspektit kulkevat rakennepuun läpi ja antavat sinun suorittaa toimintoja, kuten lisätä tunnisteita, pakottaa käytäntöjä tai tarkistaa läpikäymisen aikana havaittujen konstruktien yhteensopivuuden."
      },
      {
        "question": "Kun otat käyttöön taustapalvelua, jos sinun on tallennettava arkaluontoisia tietoja, kuten tietokannan salasanoja, jotta *sovellus voi käyttää ajon aikana* (ei liukuhihnan tunnistetietoja), mitkä AWS-palvelut on yleensä integroitu CDK:hen tätä varten?",
        "answers": [
          { "answer": "Koodaa ne sovelluksen lähdekoodiin." },
          { "answer": "Niiden tallentaminen pelkkänä tekstinä GitLabin CI/CD-muuttujiin." },
          {
            "answer": "AWS Secrets Manager tai AWS Systems Manager Parameter Store (SecureString-tyyppi)."
          },
          {
            "answer": "Niiden upottaminen suoraan ECS-tehtävämäärityksiin ympäristömuuttujiksi."
          }
        ],
        "answer": "AWS Secrets Manager tai AWS Systems Manager Parameter Store (SecureString-tyyppi).",
        "explanation": "AWS Secrets Manager ja Parameter Store (käyttäen SecureStringiä) on suunniteltu salaisuuksien turvalliseen tallentamiseen ja hallintaan. CDK-sovellukset voivat myöntää IAM-oikeudet ECS:n tai Lambdan kaltaisille palveluille näiden salaisuuksien noutamiseksi suorituksen aikana."
      },
      {
        "question": "Mikä on vaiheet-avainsanan rooli tiedostossa ".gitlab-ci.yml"?",
        "answers": [
          {
            "answer": "Määrittää eri käyttöönottoympäristöt (kehittäjä, staging, prod)."
          },
          { "answer": "Luettelo käsittelyssä käytetyt Docker-kuvat." },
          {
            "answer": "Määrittää työryhmien suoritusjärjestyksen. Samassa vaiheessa olevat työt voivat ajaa rinnakkain, kun taas eri vaiheissa olevat työt suoritetaan oletusarvoisesti peräkkäin."
          },
          {
            "answer": "Määrittää ehdot, joissa putkilinjan tulee toimia."
          }
        ],
        "answer": "Määrittää työryhmien suoritusjärjestyksen. Samassa vaiheessa olevat työt voivat ajaa rinnakkain, kun taas eri vaiheissa olevat työt suoritetaan oletusarvoisesti peräkkäin."
        "explanation": "Avainsana "vaiheet" määrittelee CI/CD-liukuhihnan yleisen suoritusjärjestyksen (esim. rakentaa, testaa, ota käyttöön). Kaikki yhden vaiheen työt suoritetaan yleensä rinnakkain (jos käytettävissä on tarpeeksi juoksijoita)."
      },
      {
        "question": "Jos määrität CDK-sovelluksessasi S3-alueen käyttöliittymän resursseille, kuinka voit varmistaa, että sen sisältö poistetaan automaattisesti, kun CDK-pino tuhoutuu?",
        "answers": [
          {
            "answer": "S3-ryhmät poistetaan aina automaattisesti, kun niiden pääpino tuhoutuu."
          },
          {
            "answer": "Sinun on tyhjennettävä ämpäri manuaalisesti ennen kuin suoritat `cdk tuhota`."
          },
          {
            "answer": "Asettamalla "autoDeleteObjects"-ominaisuuden arvoksi "true" ja "removalPolicyn" arvoksi "RemovalPolicy.DESTROY" CDK S3 -säilön rakenteessa."
          },
          {
            "answer": "Tämä edellyttää mukautetun Lambda-resurssin kirjoittamista ja käyttöönottoa."
          }
        ],
        "answer": "Asettamalla "autoDeleteObjects"-ominaisuuden arvoksi "true" ja "removalPolicyn" arvoksi "RemovalPolicy.DESTROY" CDK S3 -säilössä.",
        "explanation": "Oletusarvoisesti S3-säilöjä ei poisteta, jos ne sisältävät objekteja. Asettamalla "autoDeleteObjects: true" (joka ottaa käyttöön apulambdan) yhdessä "removalPolicy: RemovalPolicy.DESTROY" kanssa varmistaa, että ämpäri ja sen sisältö poistetaan, kun pino tuhoutuu."
      },
      {
        "question": "Mikä AWS-palvelu on välttämätön liikenteen reitittämiseksi käyttöliittymään (S3/CloudFront) ja taustapalveluun (ECS/Lambda) mukautetuilla verkkotunnuksilla?",
        "answers": [
          { "answer": "AWS Direct Connect" },
          { "answer": "Amazon Route 53" },
          { "answer": "AWS Transit Gateway" },
          { "answer": "Amazonin VPC-päätepisteet" }
        ],
        "answer": "Amazon Route 53",
        "explanation": "Amazon Route 53 on skaalautuva DNS (Domain Name System) -verkkopalvelu. Sen avulla määrität DNS-tietueita (esim. A, CNAME) osoittamaan mukautetut verkkotunnuksesi AWS-resursseihin, kuten CloudFront-jakeluihin tai sovelluskuormituksen tasapainottajiin, jotka tarjoavat palveluitasi."
      },
      {
        "question": "Kuinka voit siirtää yhdessä GitLab CI/CD-työssä (esim. rakennettu kuvatunniste) luodut dynaamiset arvot toiseen työhön seuraavassa vaiheessa?",
        "answers": [
          {
            "answer": "Kirjoitamalla ne jaettuun tiedostojärjestelmään, johon kaikki juoksijat pääsevät."
          },
          {
            "answer": "Käytetään GitLabin asetuksissa määritettyjä globaaleja ympäristömuuttujia."
          },
          {
            "answer": "Kirjoitamalla arvot .env-tiedostoon, ilmoittamalla se artefaktiksi komennolla "artifacts:reports:dotenv", joka lataa ne muuttujina seuraaviin töihin samassa liukuhihnassa."
          },
          { "answer": "Tämä ei ole mahdollista, työt ovat täysin eristyksissä." }
        ],
        "answer": "Kirjoitamalla arvot .env-tiedostoon, ilmoittamalla se artefaktiksi komennolla "artifacts:reports:dotenv", joka lataa ne muuttujina seuraaviin töihin samassa liukuhihnassa.",
        "explanation": "Artifacts:reports:dotenv:n käyttäminen sallii töiden viedä muuttujia, jotka ovat automaattisesti käytettävissä ympäristömuuttujina myöhemmissä vaiheissa oleviin töihin, mikä helpottaa dynaamista tiedonkulkua liukuhihnan sisällä."
      },
      {
        "question": "Kun määritetään Amazon ECS -palvelu CDK:ssa, mikä on "desiredCount" -ominaisuuden asettamisen tarkoitus?",
        "answers": [
          {
            "answer": "Enimmäismäärä tehtäviä, joihin palvelu voi skaalata."
          },
          {
            "answer": "Vähintämäärä terveellisiä tehtäviä palvelun tulee ylläpitää."
          },
          {
            "answer": "Tehtävien määrä, jotka ECS:n tulee käynnistää ja ylläpitää palvelua varten."
          },
          { "answer": "Kunkin tehtävän halutut suorittimen yksiköt." }
        ],
        "answer": "Tehtävien määrä, jotka ECS:n tulee käynnistää ja ylläpitää palvelua varten."
        "explanation": "ECS-palvelun määritelmän "desiredCount" määrittää, kuinka monta tehtävämäärittelyn esiintymää (eli säilöjä) on suoritettava ja ylläpidettävä ECS-ajoitusohjelman avulla."
      },
      {
        "question": "Mikä on yleinen strategia käyttöliittymä- ja taustapalveluiden versiointiin CI/CD-putkessa, erityisesti käytettäessä CDK:ta käyttöönottoihin?",
        "answers": [
          { "answer": "Käytetään käyttöönottopäivämäärää versionumerona." },
          {
            "answer": "Git commit SHA:iden tai Git-tunnisteiden käyttäminen versiotunnisteena ja niiden välittäminen CDK-sovellukselle (esim. Docker-kuvatageille tai Lambda-versioille)."
          },
          {
            "answer": "Arkistossa olevaan tekstitiedostoon tallennetun versionumeron kasvattaminen."
          },
          {
            "answer": "CDK versioi käyttöönotot automaattisesti, joten manuaalista versiointia ei tarvita."
          }
        ],
        "answer": "Git commit SHA:iden tai Git-tunnisteiden käyttäminen versiotunnisteena ja niiden välittäminen CDK-sovellukselle (esim. Docker-kuvatageille tai Lambda-versioille).",
        "explanation": "Git commit SHA:t tai -tunnisteet tarjoavat ainutlaatuisia ja jäljitettäviä versiotunnisteita. Ne voidaan siirtää CDK-sovellukseen (esim. prosessissa olevien konteksti- tai ympäristömuuttujien kautta) Docker-kuvien, version Lambda-funktioiden tai nimenkäyttöartefaktien merkitsemiseksi."
      },
      {
        "question": "Mitä GitLabin CI/CD-työn avainsanan "rules" avulla voit tehdä tarkemmalla ohjauksella kuin vanhemmilla "vain"/"paitsi"-avainsanoilla?",
        "answers": [
          { "answer": "Määritä töiden suoritusjärjestys vaiheessa." },
          {
            "answer": "Määritä Docker-kuva työlle olosuhteiden perusteella."
          },
          {
            "answer": "Määritä monimutkaiset ehdot (esim. haaran nimen, toimitusviestin, tiedostomuutosten, muuttujien perusteella) sille, milloin työ tulee lisätä liukuhihnaan, ja hallitse työmuuttujia näiden ehtojen perusteella."
          },
          { "answer": "Rajoita työtehtävän samanaikaisten osallistujien määrää." }
        ],
        "answer": "Määritä monimutkaiset ehdot (esim. haaran nimen, toimitusviestin, tiedostomuutosten, muuttujien perusteella) sille, milloin työ tulee lisätä liukuhihnaan, ja hallitse työmuuttujia näiden ehtojen perusteella."
        "explanation": "Säännöt-avainsana tarjoaa tehokkaan tavan sisällyttää tai sulkea pois töitä liukuhihnasta eri ehtojen perusteella. Se tarjoaa enemmän joustavuutta kuin "vain"/"paitsi" liukuhihnan toiminnan ohjaamiseen."
      },
      {
        "question": "Kuinka voit viitata yhdessä CDK-pinossa luotuun resurssiin (esim. VPC:n tunnukseen) toisessa CDK-pinossa samassa CDK-sovelluksessa?",
        "answers": [
          {
            "answer": "Koodaamalla resurssin ARN AWS-konsolista."
          },
          {
            "answer": "CDK-pinot ovat täysin eristettyjä, eivätkä ne voi viitata resursseihin toisistaan."
          },
          {
            "answer": "Siirtämällä konstruktio tai sen ominaisuudet (esim. `vpc.vpcId`) rekvisiittana riippuvalle pinolle ilmentymisen aikana tai käyttämällä `CfnOutput` yhdessä pinossa ja `Fn.importValue` toisessa (pinojen väliset viittaukset)."
          },
          { "answer": "Käytetään yleisiä CDK-muuttujia." }
        ],
        "answer": "Siirtämällä konstruktio tai sen ominaisuudet (esim. `vpc.vpcId`) rekvisiittana riippuvaan pinoon ilmentymisen aikana tai käyttämällä `CfnOutput` yhdessä pinossa ja `Fn.importValue` toisessa (pinojen väliset viittaukset).",
        "explanation": "Samassa CDK-sovelluksessa oleville pinoille, jotka on otettu käyttöön samalle tilille/alueelle, suora omaisuuden välitys on yleistä. Löyhästi kytketyille pinoille tai pinoille eri alueilla/tileillä CloudFormation-ristipinoviittaukset `CfnOutput`- ja `Fn.import`Value`ck.- ja `Fn.import`Value`ck. CDK:ssa) käytetään."
      },
      {
        "question": "Jos haluat seurata CDK:n kautta käyttöön otettujen taustapalveluiden (esim. Lambda, ECS) kuntoa ja suorituskykyä, mikä AWS-palvelu tarjoaa mittareita, lokeja ja hälytyksiä?",
        "answers": [
          { "answer": "AWS Config" },
          { "answer": "Amazon CloudWatch" },
          { "answer": "AWS X-Ray" },
          { "answer": "AWS-palveluluettelo" }
        ],
        "answer": "Amazon CloudWatch",
        "explanation": "Amazon CloudWatch on AWS-resurssien keskusvalvontapalvelu. Se kerää lokeja, mittareita (esim. prosessorin käyttöastetta, kutsujen määrää, virheprosentteja) ja antaa sinun asettaa hälytyksiä näiden perusteella saadaksesi ilmoituksia ongelmista."
      },
      {
        "question": "Mikä on 'GitLab-ympäristö' CI/CD:n yhteydessä?",
        "answers": [
          { "answer": "GitLab-apuohjelman käyttöjärjestelmä." },
          {
            "answer": "Tapa määrittää nimetyt käyttöönottokohteet (esim. `staging`, `production`) GitLabissa, mikä auttaa seuraamaan käyttöönottoja, hallitsemaan käyttöoikeuksia ja hallitsemaan ympäristökohtaisia ​​muuttujia."
          },
          { "answer": "Tietytty versio GitLab-ohjelmistosta." },
          { "answer": "CI/CD-töihin käytetty säilökuva." }
        ],
        "answer": "Tapa määrittää nimetyt käyttöönottokohteet (esim. `staging`, `production`) GitLabissa, mikä auttaa seuraamaan käyttöönottoja, hallitsemaan pääsyä ja hallitsemaan ympäristökohtaisia ​​muuttujia.",
        "explanation": "GitLab-ympäristöt tarjoavat tavan seurata käyttöönottoja tiettyihin kohteisiin, tarkastella käyttöönottohistoriaa, määrittää ympäristökohtaisia ​​muuttujia ja ottaa käyttöön ominaisuuksia, kuten suojattuja ympäristöjä ja käyttöönottojen manuaalisia hyväksyntöjä."
      },
      {
        "question": "Jos sinun on suoritettava mukautettu logiikka CloudFormation-asennuksen aikana, jota olemassa olevat resurssit eivät tue natiivisti (esim. resurssin hallinta paikallisessa järjestelmässä tai monimutkainen API-kutsu infrastruktuurin valmistuttua), mitä CDK-mekanismia voit käyttää?",
        "answers": [
          { "answer": "Siirry manuaalisesti cdk:n käyttöönottoprosessin aikana." },
          { "answer": "CDK-näkökohdat." },
          {
            "answer": "AWS CDK:n mukautetut resurssit, joita usein tukee AWS Lambda -toiminto."
          },
          {
            "answer": "Muokkaa syntetisoitua CloudFormation-mallia mukautettujen komentosarjojen lisäämiseksi."
          }
        ],
        "answer": "AWS CDK:n mukautetut resurssit, joita usein tukee AWS Lambda -toiminto."
        "explanation": "CDK:n mukautettujen resurssien avulla voit laajentaa CloudFormationin ominaisuuksia kirjoittamalla mukautettua hallintalogiikkaa AWS Lambda -funktioon, jonka CloudFormation kutsuu pinon luonti-, päivitys- tai poistotoimintojen aikana."
      },
      {
        "question": "Kun rakennat Docker-kuvia taustapalveluasi varten GitLab CI/CD -putkessa, mihin työnnät nämä kuvat yleensä AWS ECS:n tai EKS:n saataville?",
        "answers": [
          { "answer": "Paikalliseen Docker-rekisteriin GitLab-runnerissa." },
          {
            "answer": "Suoraan EC2-esiintymiin, jotka suorittavat säilöjä."
          },
          {
            "answer": "Amazon Elastic Container Registry (ECR) tai muuhun säilörekisteriin, kuten Docker Hubiin tai GitLabin omaan konttirekisteriin."
          },
          { "answer": "S3-ämpäriin." }
        ],
        "answer": "Amazon Elastic Container Registry (ECR) tai muuhun konttirekisteriin, kuten Docker Hub tai GitLabin omaan konttirekisteriin."
        "explanation": "Säilöorganisaattorit, kuten ECS ja EKS, vetävät Docker-kuvia säilörekisteristä. Amazon ECR on täysin hallittu AWS:n tarjoama Docker-konttirekisteri, joten se on yleinen valinta. GitLab tarjoaa myös sisäänrakennetun rekisterin."
      },
      {
        "question": "Kuinka voit käynnistää käyttöönottotyön manuaalisesti GitLabissa tietylle ympäristölle (esim. tuotanto) sen jälkeen, kun kaikki testit on läpäissyt ja ehkä manuaalisen tarkistuksen jälkeen?",
        "answers": [
          { "answer": "Painamalla tiettyä vahvistusviestiä." },
          { "answer": "Tämä ei ole mahdollista, kaikki työt on automatisoitava." },
          {
            "answer": "Määrittämällä käyttöönottotyön "kun: manuaalinen" ja valinnaisesti yhdistämällä sen GitLab-ympäristöön."
          },
          { "answer": "Siirryttämällä SSH:lle runneriin ja suorittamalla komentosarjan." }
        ],
        "answer": "Asettamalla käyttöönottotyön "kun: manuaalinen" ja valinnaisesti yhdistämällä sen GitLab-ympäristöön.",
        "explanation": "Asetus "kun: manuaalinen" työlle .gitlab-ci.yml-tiedostossa lisää toistopainikkeen GitLab-käyttöliittymään kyseiselle työlle, jolloin valtuutetut käyttäjät voivat käynnistää sen manuaalisesti, jota käytetään usein tuotantokäyttöönotuksissa tai arkaluonteisissa toiminnoissa."
      },
      {
        "question": "Mikä on ensisijainen hyöty korkeamman tason (L2/L3) konstruktien käyttämisestä AWS CDK:ssa alemman tason L1 (CFN) konstrukteihin verrattuna?",
        "answers": [
          {
            "answer": "L2/L3-rakenteet tarjoavat tarkemman hallinnan jokaiselle CloudFormation-omaisuudelle."
          },
          {
            "answer": "L2/L3-rakenteet tarjoavat paremman suorituskyvyn cdk-syntiikan aikana."
          },
          {
            "answer": "L2/L3-rakenteet kapseloivat parhaat käytännöt, tarjoavat järkeviä oletusarvoja ja vähentävät vakiokoodia tehden infrastruktuurin määrittelystä tiiviimmän ja kehittäjäystävällisemmän."
          },
          {
            "answer": "L1-rakenteet ovat aina turvallisempia kuin L2/L3-rakenteet."
          }
        ],
        "answer": "L2/L3-rakenteet kapseloivat parhaat käytännöt, tarjoavat järkeviä oletusarvoja ja vähentävät yleiskoodia tehden infrastruktuurin määrittelystä tiiviimmän ja kehittäjäystävällisemmän."
        "explanation": "Korkeamman tason rakenteet (L2 ja mallipohjainen L3) on suunniteltu yksinkertaistamaan yleisiä käyttötapauksia poistamalla suuren osan raakaa CloudFormationin monimutkaisuudesta, tarjoamalla käteviä API-liittymiä ja sisällyttämällä AWS:n parhaat käytännöt."
      },
      {
        "question": "Mikä on 'Infrastructure as Code (IaC)' ja miten AWS CDK ilmentää tätä periaatetta?",
        "answers": [
          {
            "answer": "IaC määrittää infrastruktuurin manuaalisesti AWS-konsolin kautta, ja CDK dokumentoi nämä vaiheet."
          },
          {
            "answer": "IaC on käytäntö, jossa infrastruktuuria hallitaan ja provisioidaan koneellisesti luettavien määritystiedostojen avulla manuaalisen konfiguroinnin sijaan. CDK:n avulla voit määrittää infrastruktuurin tutuilla ohjelmointikielillä."
          },
          {
            "answer": "IaC viittaa palvelinkeskusten fyysiseen laitteistoinfrastruktuuriin, jota CDK auttaa inventoimaan."
          },
          {
            "answer": "IaC on erityinen AWS-palvelu koodin käyttöönotolle, ja CDK on sen asiakas."
          }
        ],
        "answer": "IaC on käytäntö, jossa infrastruktuuria hallitaan ja provisioidaan koneellisesti luettavien määritystiedostojen avulla manuaalisen konfiguroinnin sijaan. CDK:n avulla voit määrittää infrastruktuurin tutuilla ohjelmointikielillä."
        "explanation": "CDK toteuttaa IaC:n sallimalla kehittäjien käyttää kieliä, kuten TypeScript, Python, Java jne., määrittääkseen pilviresursseja, mikä mahdollistaa versioinnin, uudelleenkäytön ja infrastruktuurin automatisoinnin."
      },
      {
        "question": "Kuinka voit toteuttaa perushyväksyntävaiheen ennen käyttöönottoa tuotantoympäristössä GitLab CI/CD:ssä?",
        "answers": [
          { "answer": "Lisäämällä "sleep"-komennon käyttöönottotyöhön." },
          {
            "answer": "Määrittämällä tuotannon käyttöönottotyön kanssa "kun: manuaalinen" ja varmistamalla, että vain valtuutetut käyttäjät voivat käynnistää sen, mahdollisesti yhdistettynä suojattuihin ympäristöihin."
          },
          {
            "answer": "Lähettämällä sähköposti-ilmoitus ja odottamalla vastausta ennen kuin jatkat."
          },
          {
            "answer": "GitLab CI/CD ei tue nimenomaisia ​​hyväksymisvaiheita; tarvitaan kolmannen osapuolen työkaluja."
          }
        ],
        "answer": "Määrittämällä tuotannon käyttöönottotyön kanssa "kun: manuaalinen" ja varmistamalla, että vain valtuutetut käyttäjät voivat käynnistää sen, mahdollisesti yhdistettynä suojattuihin ympäristöihin.",
        "explanation": ""Kun: manuaalinen" -työ edellyttää nimenomaista käyttäjän toimia käynnistyäkseen. Yhdessä GitLabin suojatut ympäristöt -ominaisuuden kanssa voit rajoittaa sitä, kuka saa käynnistää käyttöönottoja kriittisiin ympäristöihin, kuten tuotantoon."
      },
      {
        "question": "Mikä on cdk.json-tiedoston ensisijainen tarkoitus, kun käytät TypeScriptiä AWS CDK -sovelluksessasi?",
        "answers": [
          { "answer": "AWS-tunnistetietojen tallentaminen käyttöönottoa varten." },
          {
            "answer": "Määritä CloudFormation-malli suoraan JSON-muodossa."
          },
          {
            "answer": "Määrittää, kuinka CDK Toolkit suorittaa sovelluksesi (esim. komento suorittaa kuten `npx ts-node --prefer-ts-exts bin/my-app.ts`) ja tallentaa kontekstiarvot."
          },
          { "answer": "Luettelo kaikki CDK-projektin npm-riippuvuudet." }
        ],
        "answer": "Määrittää, kuinka CDK Toolkit suorittaa sovelluksesi (esim. komento suorittaa kuten `npx ts-node --prefer-ts-exts bin/my-app.ts`) ja tallentaa kontekstiarvot.",
        "explanation": "Cdk.json-tiedosto kertoo CDK:n CLI:lle, kuinka CDK-sovellus suoritetaan ("app"-avaimen kautta), ja sitä voidaan käyttää myös pysyvän kontekstitietojen tallentamiseen, joka parametroi CDK-pinot."
      },
      {
        "question": "Jos käyttöliittymäsovelluksesi (esim. isännöi S3/CloudFront) tarvitsee todennettuja API-kutsuja taustapalvelullesi (esim. API Gateway Lambda-valtuutetuilla), mikä AWS-palvelu voi auttaa hallitsemaan käyttäjien kirjautumista, sisäänkirjautumista ja token-pohjaista todennusta?",
        "answers": [
          { "answer": "AWS IAM (Identity and Access Management)" },
          { "answer": "Amazon Cognito" },
          { "answer": "AWS Shield" },
          { "answer": "AWS-avainhallintapalvelu (KMS)" }
        ],
        "answer": "Amazon Cognito",
        "explanation": "Amazon Cognito tarjoaa käyttäjäidentiteetin ja käyttöoikeuksien hallinnan verkko- ja mobiilisovelluksille. Se voi käsitellä käyttäjien rekisteröintiä, kirjautumista ja antaa JWT-tunnuksia, joita voidaan käyttää API-kutsujen todentamiseen palveluihin, kuten API Gateway."
      },
      {
        "question": "Mikä on 'merge request pipeline' (tai 'branch pipeline') GitLab CI/CD:ssä?",
        "answers": [
          {
            "answer": "Puhelu, joka toimii vain sen jälkeen, kun yhdistämispyyntö on yhdistetty."
          },
          {
            "answer": "Puhelu, joka käynnistetään manuaalisesti yhdistämispyynnön käyttöliittymästä."
          },
          {
            "answer": "Puhelus, joka suoritetaan yhdistämispyynnön lähdehaaran sitoumuksissa tai erityisesti itse yhdistämispyynnössä, jota käytetään usein testien ja laaduntarkistuksia suorittamiseen ennen yhdistämistä."
          },
          {
            "answer": "Puhelu, joka ottaa muutokset käyttöön yhdistämispyynnöstä suoraan tuotantoon."
          }
        ],
        "answer": "Puhelu, joka suoritetaan yhdistämispyynnön lähdehaaran sitoumuksissa tai nimenomaan itse yhdistämispyynnössä, jota käytetään usein testien ja laaduntarkistusten suorittamiseen ennen yhdistämistä."
        "explanation": "Yhdistämispyyntöputket ovat ratkaisevan tärkeitä CI:lle, koska niiden avulla voit vahvistaa muutokset erillään ennen kuin ne integroidaan pääkooditietokantaan, mikä auttaa havaitsemaan ongelmat varhaisessa vaiheessa."
      },
      {
        "question": "Kuinka AWS CDK Toolkit yleensä määrittää, mille AWS-alueelle ja tilille resurssit otetaan käyttöön, jos sitä ei ole erikseen määritelty koodissa tai ympäristömuuttujissa?",
        "answers": [
          {
            "answer": "Se on aina oletusarvo 'us-east-1' ja oletustili AWS CLI -profiilissasi."
          },
          {
            "answer": "Se kysyy käyttäjältä aluetta ja tiliä jokaisen `cdk:n käyttöönoton` aikana."
          },
          {
            "answer": "Se käyttää ensisijaisesti nykyisessä AWS CLI -profiilissa määritettyä aluetta ja tiliä (esim. "aws configure" tai ympäristömuuttujat, kuten "AWS_PROFILE", "AWS_DEFAULT_REGION")."
          },
          {
            "answer": "Se lukee alueen ja tilin cdk.json-tiedostosta."
          }
        ],
        "answer": "Se käyttää ensisijaisesti nykyisessä AWS CLI -profiilissa määritettyä aluetta ja tiliä (esim. "aws configure" tai ympäristömuuttujat, kuten "AWS_PROFILE", "AWS_DEFAULT_REGION").",
        "explanation": "CDK CLI luottaa AWS SDK:n normaaliin valtuustieto- ja alueratkaisuketjuun, joka usein käyttää oletusarvoisesti aktiivisen AWS CLI -profiilisi asetuksia tai tavallisia AWS-ympäristömuuttujia. Nämä voidaan ohittaa CDK-koodin pinokohtaisesti tai tarvittaessa CLI-parametreilla."
      },
      {
        "question": "Mikä on "monorepo" vs. "polyrepo" -lähestymistapa käyttöliittymän ja taustajärjestelmän käyttöönoton yhteydessä ja miten se voi vaikuttaa GitLabin CI/CD-putkirakenteeseen?",
        "answers": [
          {
            "answer": "Monorepo tarkoittaa yhtä putkia kaikille projekteille; polyrepo tarkoittaa, ettei putkia."
          },
          {
            "answer": "Monorepo tallentaa käyttöliittymän ja taustajärjestelmän samaan arkistoon, mahdollisesti jakaa yhden monimutkaisen putkilinjan tai käyttämällä polkupohjaisia ​​triggereitä. Polyrepo käyttää erillisiä tietovarastoja, mikä johtaa erillisiin putkiin palvelua kohti."
          },
          {
            "answer": "Monorepo on monoliittisille sovelluksille, polyrepo mikropalveluille; CDK tukee vain polyrepoa."
          },
          {
            "answer": "Monorepo käyttää yhtä GitLab-instanssia, polyrepo käyttää useita."
          }
        ],
        "answer": "Monorepo tallentaa käyttöliittymän ja taustajärjestelmän samaan arkistoon, mahdollisesti jakaa yhden monimutkaisen putkilinjan tai käyttämällä polkupohjaisia ​​triggereitä. Polyrepo käyttää erillisiä tietovarastoja, mikä johtaa erillisiin putkiin palvelua kohden."
        "explanation": "Monorepo voi yksinkertaistaa palvelujen välisiä muutoksia, mutta saattaa vaatia monimutkaisempaa CI/CD-logiikkaa (esim. "säännöt:muutokset"), jotta vältytään palvelujen uudelleenrakentamiselta tai uudelleensijoittamisesta. Polyrepos tarjoaa yksinkertaisempia, itsenäisiä putkistoja, mutta voi tehdä koordinoidusta käyttöönotosta haastavampaa."
      },
      {
        "question": "Mikä on "needs:"-avainsana GitLab CI/CD:ssä ja miten se eroaa "dependencies:"-avainsanasta, jota käytetään "artefacts" kanssa?",
        "answers": [
          {
            "answer": "`needs:` määrittää Docker-kuvat, `dependencies:` määrittää ohjelmistopaketit."
          },
          {
            "answer": ""needs:" määrittää työn suoritusjärjestyksen, joka luo DAG:n, sallien aikaisemman aloituksen kuin vaihepohjaisen suorituksen; "dependencies:" ohjaa artefaktien latausta tietyistä töistä, joihin "needs:" viittaa."
          },
          {
            "answer": "`riippuvuudet:` määrittää työn suoritusjärjestyksen, `needs:` ohjaa artefaktien latausta."
          },
          {
            "answer": "Ne ovat keskenään vaihdettavia avainsanoja, joilla on samat toiminnot."
          }
        ],
        "answer": ""needs:" määrittää työn suoritusjärjestyksen, joka luo DAG:n, sallien aikaisemman aloituksen kuin vaihepohjaisen suorituksen; "dependencies:" ohjaa artefaktien latausta tietyistä töistä, johon "needs:" viittaa.",
        "explanation": ""needs:" sallii työn alkamisen heti, kun luetellut aiemmat työt on suoritettu, vaiheesta riippumatta. Jos "needs:" on käytössä, työ lataa oletusarvoisesti vain artefakteja `needs:` -kohdassa luetelluista töistä. Avainsana `dependencies:` voi tarkentaa tätä edelleen tai sitä voidaan käyttää vaihepohjaisen työn suorittamisen kanssa.
      },
      {
        "question": "Kun määrität AWS Lambda -funktion CDK:ssa käyttämällä rakennetta, kuten "lambda.Function", kuinka voit määrittää sen ajonaikaisen ympäristön (esim. Node.js 18.x, Python 3.11)?",
        "answers": [
          {
            "answer": "Asettamalla ympäristömuuttujan GitLab CI/CD -työhön."
          },
          {
            "answer": "Se tunnistetaan automaattisesti käsittelijän tiedostopäätteestä."
          },
          {
            "answer": "Lambda.Function-rakenteen "runtime"-ominaisuuden käyttäminen, esim. "lambda.Runtime.NODEJS_18_X".
          },
          {
            "answer": "Sisällyttämällä "runtime.txt"-tiedoston Lambdan käyttöönottopakettiin."
          }
        ],
        "answer": "Lambda.Function"-rakenteen "runtime"-ominaisuuden käyttäminen, esim. "lambda.Runtime.NODEJS_18_X".",
        "explanation": "CDK:n Lambda-rakenteet tarjoavat "runtime"-ominaisuuden, jossa määrität halutun Lambda-ajonaikaisen ympäristön käyttämällä ennalta määritettyjä vakioita, kuten `lambda.Runtime.NODEJS_18_X`, `lambda.Runtime.PYTHON_3_11` jne."
      },
      {
        "question": "Mikä on AWS CloudFormationin ensisijainen rooli, jota AWS CDK käyttää konepellin alla?",
        "answers": [
          { "answer": "Koodivarastopalvelu, joka on samanlainen kuin Git." },
          { "answer": "Koontipalvelu sovelluskoodin kokoamiseen." },
          {
            "answer": "Infrastruktuurin hallinta- ja hallintapalvelu, jonka avulla voit mallintaa, tarjota ja hallita AWS:ää ja kolmannen osapuolen resursseja mallien avulla."
          },
          {
            "answer": "Valvontapalvelu sovelluksen suorituskyvyn seurantaan."
          }
        ],
        "answer": "Infrastruktuurin hallinta- ja hallintapalvelu, jonka avulla voit mallintaa, tarjota ja hallita AWS:ää ja kolmannen osapuolen resursseja mallien avulla."
        "explanation": "AWS CDK syntetisoi CloudFormation-malleja. CloudFormation sitten tulkitsee nämä mallit luodakseen, päivittääkseen tai poistaakseen AWS-resursseja ennustettavalla ja deklaratiivisella tavalla."
      },
      {
        "question": "Mikä on attribuutin "allow_failure: true" tarkoitus työlle tiedostossa ".gitlab-ci.yml"?",
        "answers": [
          { "answer": "Se saa työn automaattisesti yrittämään uudelleen epäonnistuessa." },
          {
            "answer": "Se sallii työn epäonnistumisen aiheuttamatta koko liukuhihnan epäonnistumista. Sitä käytetään usein ei-kriittisiin töihin, kuten koodilinttereihin tai valinnaisiin testeihin."
          },
          {
            "answer": "Se pakottaa työn raportoimaan aina onnistumisesta, riippumatta sen poistumiskoodista."
          },
          { "answer": "Se ohittaa työn suorittamisen kokonaan." }
        ],
        "answer": "Se sallii työn epäonnistumisen aiheuttamatta koko liukuhihnan epäonnistumista. Sitä käytetään usein ei-kriittisiin töihin, kuten koodilinttereihin tai valinnaisiin testeihin."
        "explanation": "Kun "allow_failure: true" on asetettu, työn epäonnistuminen ei pysäytä liukuhihnan etenemistä tai merkitse koko liukuhihnaa epäonnistuneeksi. Tämä on hyödyllistä tiedottamistyössä tai ei-estotarkistuksissa."
      },
      {
        "question": "Kuinka AWS CDK voi auttaa hallitsemaan ja ottamaan käyttöön useita sovelluksesi esiintymiä eri ympäristöissä (esim. lavastus, tuotanto) samasta CDK-koodikannasta?",
        "answers": [
          {
            "answer": "CDK ei tue usean ympäristön käyttöönottoja; jokaiselle tarvitaan erillinen CDK-sovellus."
          },
          {
            "answer": "Kopioimalla ja liittämällä pinomääritykset manuaalisesti ja nimeämällä resursseja uudelleen."
          },
          {
            "answer": "Parametrisoimalla pinoja käyttämällä rekvisiitta, kontekstimuuttujia tai ympäristömuuttujia. Sovelluksen/pinojen eri esiintymiä voidaan syntetisoida ja ottaa käyttöön ympäristökohtaisilla kokoonpanoilla (esim. `new MyStack(app, 'StagingStack', { envType: 'staging).' .
          },
          {
            "answer": "AWS CloudFormation StackSetsin kautta, joita CDK hallitsee suoraan."
          }
        ],
        "answer": "Parametrisoimalla pinoja käyttämällä rekvisiitta, kontekstimuuttujia tai ympäristömuuttujia. Sovelluksen/pinojen eri esiintymiä voidaan syntetisoida ja ottaa käyttöön ympäristökohtaisilla kokoonpanoilla (esim. `new MyStack(app, 'StagingStack', { envType: 'staging).' .
        "explanation": "CDK:n ohjelmallinen luonne mahdollistaa pinojen ilmentämisen useita kertoja eri kokoonpanoilla, usein CI/CD-liukuhihnasta välitettävien ympäristömuuttujien tai kontekstiarvojen ohjaamana, mikä mahdollistaa johdonmukaisen käyttöönoton eri ympäristöissä yhdestä koodikannasta."
      }
    ]
  },
  {
    "name": "AWS Fullstack -kehittäjähaastattelu",
    "image": "https://images.unsplash.com/photo-1589149098258-3e9102cd63d3",
    "questions": [
      {
        "question": "Sinun on otettava käyttöön skaalautuva, palvelimeton REST API. Mikä AWS-palveluiden yhdistelmä sopii parhaiten API-päätepisteelle ja taustalogiikalle?",
        "answers": [
          { "answer": "EC2 and Elastic Load Balancer" },
          { "answer": "API Gateway ja AWS Lambda" },
          { "answer": "AWS AppSync and Elastic Beanstalk" },
          { "answer": "Amazon S3 ja AWS Step Functions" }
        ],
        "answer": "API Gateway ja AWS Lambda",
        "explanation": "API Gateway luo, julkaisee, ylläpitää, valvoo ja suojaa sovellusliittymiä. AWS Lambda suorittaa koodia ilman palvelinta, mikä on ihanteellinen API-yhdyskäytävän käynnistämälle taustalogiikalle."
      },
      {
        "question": "Mihin isännöitte nykyaikaisessa verkkosovelluksessa staattiset käyttöliittymäresurssit (esim. React-, Angular-, Vue-koontitiedostot) varmistaaksesi alhaisen viiveen ja korkean käytettävyyden maailmanlaajuisesti?",
        "answers": [
          { "answer": "Suoraan AWS Lambda -toiminnolla" },
          { "answer": "Amazon EC2 -esiintymässä verkkopalvelimella" },
          { "answer": "Amazon S3:ssa, jakelija Amazon CloudFront" },
          { "answer": "Amazon DynamoDB:ssä" }
        ],
        "answer": "Amazon S3:ssa, jakelija Amazon CloudFront",
        "explanation": "S3 tarjoaa objektitallennustilan, ja CloudFront (CDN) tallentaa resurssit välimuistiin reunapaikoissa, mikä vähentää viivettä."
      },
      {
        "question": "Sovelluksesi vaatii joustavan NoSQL-tietokannan, joka skaalautuu saumattomasti ja tarjoaa yksinumeroisen millisekunnin latenssin. Mikä AWS-tietokantapalvelu sopii parhaiten?",
        "answers": [
          { "answer": "Amazon RDS for PostgreSQL" },
          { "answer": "Amazon Redshift" },
          { "answer": "Amazon DynamoDB" },
          { "answer": "Amazon Aurora" }
        ],
        "answer": "Amazon DynamoDB",
        "explanation": "DynamoDB on avainarvo-/asiakirjatietokanta, joka tarjoaa alhaisen viiveen suorituskyvyn mittakaavassa, täysin hallittu ja palvelimeton."
      },
      {
        "question": "Mikä AWS-palvelu tarjoaa täysin hallitun jatkuvan integraation ja jatkuvan toimituksen (CI/CD) työnkulun sovelluskoodisi rakentamiseen, testaamiseen ja käyttöönottoon?",
        "answers": [
          { "answer": "AWS CodeCommit" },
          { "answer": "AWS CodeBuild" },
          { "answer": "AWS CodeDeploy" },
          { "answer": "AWS CodePipeline" }
        ],
        "answer": "AWS CodePipeline",
        "explanation": "CodePipeline automatisoi CI/CD-työnkulut integroitumalla CodeCommitin (lähde), CodeBuildin (koonti) ja CodeDeploy:n (käyttöönotto) kanssa."
      },
      {
        "question": "Mikä AWS-palvelu tarjoaa käyttäjäpoolit ja identiteettivarastot?",
        "answers": [
          { "answer": "AWS IAM (Identity and Access Management)" },
          { "answer": "Amazon Cognito" },
          { "answer": "AWS Secrets Manager" },
          { "answer": "AWS Shield" }
        ],
        "answer": "Amazon Cognito",
        "explanation": "Cognito tarjoaa käyttäjien kirjautumisen/sisäänkirjautumisen ja käyttöoikeuksien hallinnan. Käyttäjävarastot ovat hakemistoja; identiteettivarastot myöntävät AWS-palvelun käyttöoikeuden."
      },
      {
        "question": "Skenaario: Sovelluksesi sallii käyttäjien ladata kuvia. Sinun on tallennettava alkuperäinen kuva, luotava automaattisesti pikkukuvaversio ja tallennettava kuvan metatiedot. Mitä palveluita käyttäisit ensisijaisesti toteuttaaksesi tämän palvelimettomasti?",
        "answers": [
          {
            "answer": "EC2 kuvankäsittelyyn, RDS metatietoihin, S3 tallennus."
          },
          {
            "answer": "S3 tallennustilaa varten, lambda S3-tapahtumien käynnistämää pikkukuvien luomista varten, DynamoDB metatiedoille."
          },
          {
            "answer": "Elastic Beanstalk kuvankäsittelyyn, S3 tallennukseen, ElastiCache metatietoihin."
          },
          {
            "answer": "API-yhdyskäytävä kuvien vastaanottamiseen, Lambda tallentamiseen EBS:lle, RDS metadatalle."
          }
        ],
        "answer": "S3 tallennustilaa varten, lambda S3-tapahtumien käynnistämää pikkukuvien luomista varten, DynamoDB metatiedoille."
        "explanation": "S3 tallentaa kuvat. S3-tapahtumat laukaisevat Lambdan pikkukuvaa varten. DynamoDB tallentaa metatiedot nopeaa kyselyä varten."
      },
      {
        "question": "Skenaario: Palvelimeton API, joka on rakennettu API Gatewaylla ja Lambdalla, kärsii ajoittaisista vioista. Mitkä AWS-palvelut ovat välttämättömiä näiden ongelmien diagnosoinnissa ja vianmäärityksessä tarkastelemalla lokeja, mittareita ja pyyntöjäljitystä?",
        "answers": [
          {
            "answer": "AWS Config, AWS Trusted Advisor ja Amazon Inspector."
          },
          { "answer": "Amazon CloudWatch (Logs & Metrics) ja AWS X-Ray." },
          {
            "answer": "AWS CloudFormation, AWS Systems Manager ja AWS Health Dashboard."
          },
          {
            "answer": "Amazon S3 (lokit), AWS Glue (lokien käsittelyyn) ja Amazon QuickSight (visualisointiin)."
          }
        ],
        "answer": "Amazon CloudWatch (Logs & Metrics) ja AWS X-Ray."
        "explanation": "CloudWatch Logs tallentaa lokit, CloudWatch Metrics tarjoaa suorituskykytietoja ja X-Ray tarjoaa päästä-päähän pyyntöjäljityksen virheenkorjausta varten."
      },
      {
        "question": "Skenaario: Olet rakentamassa chat-sovellusta, jossa useiden käyttäjien on saatava reaaliaikaisia ​​viestejä. Mikä AWS-palvelu on suunniteltu erityisesti hallitsemaan asiakkailta tulevia pysyviä WebSocket-yhteyksiä tämän reaaliaikaisen, kaksisuuntaisen viestinnän mahdollistamiseksi?",
        "answers": [
          { "answer": "Amazon SQS viestijonoon." },
          { "answer": "Amazon SNS push-ilmoituksille." },
          { "answer": "AWS AppSync GraphQL-tilauksilla." },
          { "answer": "Amazon API Gateway (WebSocket API:t)." }
        ],
        "answer": "Amazon API Gateway (WebSocket API).",
        "explanation": "API Gateway WebSocket -sovellusliittymät mahdollistavat reaaliaikaisen, kaksisuuntaisen viestinnän hallitsemalla pysyviä yhteyksiä asiakkaiden kanssa."
      },
      {
        "question": "Skenaario: Fullstack-sovelluksesi koostuu useista mikropalveluista (esim. tilauspalvelu, maksupalvelu, ilmoituspalvelu), joiden on kommunikoitava asynkronisesti parantaakseen joustavuutta ja skaalautuvuutta. Mikä AWS-palvelu soveltuu parhaiten viestien jonottamiseen näiden mikropalvelujen välillä?",
        "answers": [
          {
            "answer": "Amazon Kinesis -datavirrat reaaliaikaiseen tiedonkäsittelyyn."
          },
          {
            "answer": "AWS-askelfunktiot monimutkaisten työnkulkujen järjestämiseen."
          },
          { "answer": "Amazon SQS (yksinkertainen jonopalvelu)." },
          { "answer": "Amazon ElastiCache muistin välimuistiin." }
        ],
        "answer": "Amazon SQS (Simple Queue Service).",
        "explanation": "SQS mahdollistaa irrotetut, skaalautuvat mikropalvelut tarjoamalla hallittuja viestijonoja asynkronista viestintää varten."
      },
      {
        "question": "Kuinka sovelluksesi, joka toimii AWS Lambdalla tai EC2:lla, pääsee turvallisesti tietokannan valtuustietoihin tai kolmannen osapuolen API-avaimiin ilman koodausta sovelluskoodiin?",
        "answers": [
          {
            "answer": "Tallenna ne tekstitiedostoon asennuspaketin sisällä."
          },
          {
            "answer": "Välitä ne ympäristömuuttujiksi suoraan Lambda/EC2-määrityskonsolissa."
          },
          {
            "answer": "Käytä AWS Secrets Manageria tai AWS Systems Managerin parametrivarastoa (SecureString)."
          },
          {
            "answer": "Upota ne määritysobjektiin suoraan lähdekoodissa."
          }
        ],
        "answer": "Käytä AWS Secrets Manageria tai AWS Systems Managerin parametrivarastoa (SecureString).",
        "explanation": "Secrets Manager (elinkaari, kierto) ja Parameter Store SecureString tarjoavat suojatun, IAM-ohjatun pääsyn salaisuuksiin suorituksen aikana."
      },
      {
        "question": "Mikä on NAT-yhdyskäytävän ensisijainen tarkoitus Amazon VPC:ssä?",
        "answers": [
          {
            "answer": "Salli julkisissa aliverkoissa olevien esiintymien pääsy Internetiin."
          },
          {
            "answer": "Antaa yksityisissä aliverkoissa olevien esiintymien aloittaa lähtevän liikenteen Internetiin samalla kun estetään saapuva liikenne."
          },
          { "answer": "Tarjoaa erillisen laitteistoyhteyden AWS:ään." },
          {
            "answer": "Tarkistaa aliverkkojen välistä liikennettä haitallisen toiminnan varalta."
          }
        ],
        "answer": "Salli yksityisissä aliverkoissa olevien esiintymien aloittaa lähtevän liikenteen Internetiin samalla kun estetään saapuva liikenne."
        "explanation": "NAT-yhdyskäytävä on hallittu palvelu, joka sallii yksityisten aliverkkojen resurssien (esim. EC2-tausta-esiintymien, Lambda-toimintojen) pääsyn Internetiin tai muihin AWS-palveluihin, mutta estää Internetiä muodostamasta yhteyksiä kyseisiin ilmentymiin."
      },
      {
        "question": "Mikä on Amazon S3:ssa oletustallennusluokka juuri ladatuille objekteille, jos mitään ei ole määritetty?",
        "answers": [
          { "answer": "S3 Glacier Deep Archive" },
          { "answer": "S3 Intelligent-Tiering" },
          { "answer": "S3 Standard" },
          { "answer": "S3 One Zone-IA" }
        ],
        "answer": "S3 Standard",
        "explanation": "S3 Standard on oletustallennusluokka, joka tarjoaa korkean kestävyyden, saatavuuden ja suorituskyvyn usein käytetyille tiedoille."
      },
      {
        "question": "Millä AWS-palvelulla voit ajaa Docker-säilöjä ilman taustalla olevien EC2-instanssien hallintaa, keskittyen puhtaasti konttityökuormaan?",
        "answers": [
          { "answer": "Amazon EC2 Docker asennettuna" },
          { "answer": "Amazon ECS EC2-laukaisutyypillä" },
          { "answer": "AWS Fargate" },
          { "answer": "AWS Elastic Beanstalk Docker-alustalla" }
        ],
        "answer": "AWS Fargate",
        "explanation": "AWS Fargate on palvelimeton laskentamoottori säilöille, joka toimii sekä Amazon ECS:n että EKS:n kanssa. Sinun ei tarvitse muodostaa, määrittää tai skaalata virtuaalikoneiden klustereita käyttääksesi säilöjä."
      },
      {
        "question": "Mikä on AWS IAM -roolien ensisijainen rooli myönnettäessä lupia AWS-palveluille tai sovelluksille, jotka toimivat EC2/Lambdalla?",
        "answers": [
          { "answer": "Luo pysyviä avaimia palveluille." },
          { "answer": "Käyttäjien salasanojen ja MFA-asetusten määrittäminen." },
          {
            "answer": "Suojattu oikeuksien delegoiminen entiteeteille, joihin luotat, ilman pitkäaikaisten valtuustietojen jakamista."
          },
          {
            "answer": "Hallitsee AWS-resurssien laskutusta ja kustannusten kohdentamista."
          }
        ],
        "answer": "Oikeuksien siirtäminen luotettavasti entiteeteille, joihin luotat, ilman pitkäaikaisten valtuustietojen jakamista."
        "explanation": "IAM-roolit tarjoavat väliaikaiset suojaustiedot, joita AWS-palvelut tai -sovellukset voivat käyttää AWS-sovellusliittymäkutsujen tekemiseen. Tämä on turvallisempaa kuin pääsyavainten upottaminen."
      },
      {
        "question": "Haluat ottaa käyttöön julkaisu-/tilausviestimallin lähettääksesi ilmoituksia useille kiinnostuneille loppupään palveluille. Mikä AWS-palvelu sopii tähän parhaiten?",
        "answers": [
          { "answer": "Amazon SQS (Simple Queue Service)" },
          { "answer": "Amazon SNS (yksinkertainen ilmoituspalvelu)" },
          { "answer": "AWS Step Functions" },
          { "answer": "Amazon Kinesis Data Streams" }
        ],
        "answer": "Amazon SNS (yksinkertainen ilmoituspalvelu)",
        "explanation": "SNS on täysin hallittu pub/sub-viestintäpalvelu, joka mahdollistaa mikropalvelujen, hajautettujen järjestelmien ja palvelimettomien sovellusten irrottamisen. Julkaisijat lähettävät viestejä aiheille, ja useat tilaajat (esim. Lambda, SQS, HTTP-päätepisteet) vastaanottavat ne."
      },
      {
        "question": "Mikä on tärkein hyöty Amazon RDS Multi-AZ -asennusten käyttämisestä relaatiotietokannassa?",
        "answers": [
          {
            "answer": "Parannettu lukuskaalautuvuus käyttämällä useita lukukopioita."
          },
          { "answer": "Pienemmät kustannukset verrattuna yksittäisiin AZ-käyttöönottoihin." },
          { "answer": "Parempi tietokantaan kirjoitusteho." },
          {
            "answer": "Parannettu saatavuus ja kestävyys synkronisen replikoinnin ansiosta eri AZ:n valmiustilan ilmentymään."
          }
        ],
        "answer": "Parannettu saatavuus ja kestävyys synkronisen replikoinnin ansiosta eri AZ:n valmiustilan ilmentymään."
        "explanation": "RDS Multi-AZ -asennukset replikoivat tiedot automaattisesti synkronisesti valmiustilassa olevaan ilmentymään eri käytettävyysvyöhykkeellä, mikä tarjoaa tietojen redundanssin, eliminoi I/O-jäädytyksiä ja minimoi viivepiikit järjestelmän varmuuskopioiden aikana. Se tarjoaa vikasietotuki DB-esiintymille."
      },
      {
        "question": "Mikä tiedosto AWS CodeBuild -projektissa määrittää koontikomennot ja niihin liittyvät asetukset?",
        "answers": [
          { "answer": "Dockerfile" },
          { "answer": "buildspec.yml (tai buildspec.yaml)" },
          { "answer": "appspec.yml" },
          { "answer": "template.yaml" }
        ],
        "answer": "buildspec.yml (tai buildspec.yaml)",
        "explanation": "Buildingspec-tiedosto on kokoelma YAML-muodossa olevia koontikomentoja ja niihin liittyviä asetuksia, joita CodeBuild käyttää koonnoksen suorittamiseen. Se määrittelee vaiheet, kuten asennus, pre_build, build ja post_build."
      },
      {
        "question": "Kun käytät Amazon CloudFrontia, mikä on 'Alkuperä':n tarkoitus?",
        "answers": [
          { "answer": "AWS-alue, jossa CloudFront määritettiin." },
          { "answer": "Loppukäyttäjän sijainti, josta pyynnöt tehdään." },
          {
            "answer": "Lähdesijainti (esim. S3-säilö, HTTP-palvelin), josta CloudFront saa tiedostosi välimuistiin ja palveluun."
          },
          { "answer": "Tietytty välimuistin käyttäytymissääntö." }
        ],
        "answer": "Lähdesijainti (esim. S3-säilö, HTTP-palvelin), josta CloudFront saa tiedostosi välimuistiin ja palveluun."
        "explanation": "CloudFront-alkuperä on sisältösi alkuperäinen sijainti. CloudFront hakee sisällön alkuperästä ja tallentaa sen välimuistiin lähempänä käyttäjiä."
      },
      {
        "question": "Mikä AWS Amplify on ensisijaisesti suunniteltu auttamaan kehittäjiä?",
        "answers": [
          { "answer": "Matalan tason verkkoinfrastruktuurin hallinta." },
          {
            "answer": "Täyden pinon verkko- ja mobiilisovellusten rakentaminen, käyttöönotto ja isännöiminen ominaisuuksilla, kuten todennus, tallennus ja API."
          },
          {
            "answer": "Suorittaa laajamittaista data-analytiikkaa ja varastointia."
          },
          { "answer": "Monimutkaisten koneoppimiskoulutusten järjestäminen." }
        ],
        "answer": "Täyden pinon verkko- ja mobiilisovellusten rakentaminen, käyttöönotto ja isännöinti ominaisuuksilla, kuten todennus, tallennus ja sovellusliittymät."
        "explanation": "AWS Amplify tarjoaa joukon työkaluja ja palveluita, joiden avulla kehittäjät voivat nopeasti rakentaa ja ottaa käyttöön skaalautuvia fullstack-sovelluksia, jotka tarjoavat CLI-työkaluketjuja, käyttöliittymäkomponentteja ja isännöintipalvelun."
      },
      {
        "question": "Mikä on DynamoDB:ssä tärkein ero paikallisen toissijaisen indeksin (LSI) ja maailmanlaajuisen toissijaisen indeksin (GSI) välillä?",
        "answers": [
          {
            "answer": "LSI:t voidaan luoda vain taulukon luomisen yhteydessä, kun taas GSI:t voidaan lisätä myöhemmin."
          },
          {
            "answer": "LSI:t jakavat taulukon provisioidun suorituskyvyn, kun taas GSI:illä on oma."
          },
          {
            "answer": "LSI:iden on käytettävä samaa osioavainta kuin perustaulukko, kun taas GSI:t voivat käyttää erilaisia ​​osio- ja lajitteluavaimia."
          },
          { "answer": "Kaikki edellä mainitut." }
        ],
        "answer": "Kaikki edellä mainitut."
        "explanation": "LSI:t käyttävät samaa osioavainta kuin perustaulukko, mutta eri lajitteluavainta, jakavat suorituskyvyn ja ne on luotava taulukkoa luotaessa. GSI:illä voi olla eri osio- ja lajitteluavaimet, niillä voi olla erillinen provisioitu suorituskyky ja ne voidaan luoda/poistaa taulukon luomisen jälkeen."
      },
      {
        "question": "Mikä on AWS WAF:n (Web Application Firewall) tarkoitus?",
        "answers": [
          { "answer": "DNS-tietueiden hallinta verkkotunnuksessasi." },
          { "answer": "Tarjoaa suojatun etäkäytön EC2-instanssiin." },
          {
            "answer": "Suojatakseen verkkosovelluksia yleisiltä verkkohyödykkeiltä, ​​kuten SQL-injektio ja cross-site scripting (XSS)."
          },
          { "answer": "Salataan lepotilassa olevat tiedot S3-sävyissä." }
        ],
        "answer": "Suojatakseen verkkosovelluksia yleisiltä verkkohyödykkeiltä, ​​kuten SQL-injektio ja cross-site scripting (XSS).",
        "explanation": "AWS WAF auttaa suojaamaan verkkosovelluksiasi tai sovellusliittymiäsi yleisiltä verkkohyödyllisiltä, ​​jotka voivat vaikuttaa saatavuuteen, vaarantaa turvallisuuden tai kuluttaa liikaa resursseja sallimalla sinun määrittää sääntöjä, jotka suodattavat liikennettä."
      },
      {
        "question": "Jos haluat määrittää koko AWS-infrastruktuurisi koodiksi, joka mahdollistaa toistettavat ja ennustettavat käyttöönotot, mitä AWS-palvelua tai -työkalua käyttäisit ensisijaisesti?",
        "answers": [
          { "answer": "AWS-hallintakonsoli" },
          { "answer": "AWS SDK:t" },
          { "answer": "AWS CloudFormation tai AWS CDK (Cloud Development Kit)" },
          { "answer": "AWS Elastic Beanstalk" }
        ],
        "answer": "AWS CloudFormation tai AWS CDK (Cloud Development Kit)",
        "explanation": "AWS CloudFormation tarjoaa yhteisen kielen kaikkien pilviympäristösi infrastruktuuriresurssien kuvaamiseen ja tarjoamiseen. AWS CDK:n avulla voit määrittää pilviinfrastruktuurisi tutuilla ohjelmointikielillä."
      },
      {
        "question": "Millainen API Gateway -päätepiste sopii parhaiten, jos haluat, että API on käytettävissä vain Amazon VPC:stä?",
        "answers": [
          { "answer": "Reunaoptimoitu päätepiste" },
          { "answer": "Alueellinen päätepiste" },
          { "answer": "Yksityinen päätepiste" },
          { "answer": "Julkinen päätepiste" }
        ],
        "answer": "Yksityinen päätepiste",
        "explanation": "Yksityiset API-päätepisteet ovat käytettävissä vain Amazon Virtual Private Cloud -palvelusta (VPC) käyttämällä käyttöliittymän VPC-päätepistettä. Tämä pitää liikenteen AWS-verkon sisällä eikä julkisen Internetin sisällä."
      },
      {
        "question": "Mitä AWS-palvelua käyttäisit monivaiheisen työnkulun järjestämiseen, joka sisältää useita Lambda-toimintoja, ihmisen hyväksymisvaiheita ja ehdollista logiikkaa?",
        "answers": [
          { "answer": "Amazon SQS" },
          { "answer": "AWS Lambda itse takaisinsoittojen kanssa" },
          { "answer": "AWS Step Functions" },
          { "answer": "Amazon EventBridge" }
        ],
        "answer": "AWS-askeltoiminnot",
        "explanation": "AWS Step Functions antaa sinun koordinoida useita AWS-palveluita palvelimettomiksi työnkulkuiksi. Voit määrittää tilakoneet, jotka kuvaavat työnkulkusi vaiheiden sarjana, niiden suhteina sekä niiden tuloina ja lähdöinä."
      },
      {
        "question": "Mikä on AWS Lambda Layers -kerrosten käytön tärkein etu?",
        "answers": [
          { "answer": "Lambda-funktioiden samanaikaisuuden automaattinen skaalaus." },
          {
            "answer": "Lambda-toimintojen käyttöönottopaketin koon pienentämiseksi ja yhteisen koodin/riippuvuuksien jakamiseksi."
          },
          {
            "answer": "Tarjoaa oma HTTP-päätepiste Lambda-toiminnoille."
          },
          { "answer": "Ympäristömuuttujien salaamiseen Lambda-funktioita varten." }
        ],
        "answer": "Lambda-toimintojen käyttöönottopaketin koon pienentämiseksi ja yhteisen koodin/riippuvuuksien jakamiseksi."
        "explanation": "Lambda-tasojen avulla voit pakata kirjastoja ja muita riippuvuuksia, jotka voit jakaa useiden Lambda-toimintojen kesken. Näin asennuspakettisi pysyy pieninä ja yleisten komponenttien hallinta on helpompaa."
      },
      {
        "question": "Mitä AppSpec-tiedosto määrittää AWS CodeDeployissa?",
        "answers": [
          { "answer": "Lähdekoodivaraston sijainti." },
          { "answer": "Sovelluksen kääntämisen koontikomennot." },
          {
            "answer": "Ohjeet sovelluksen käyttöönottoon, mukaan lukien lähdetiedostot, elinkaaritapahtumakoukut ja käyttöönottokokoonpanot."
          },
          { "answer": "Käyttöönoton IAM-roolin käyttöoikeudet." }
        ],
        "answer": "Ohjeet sovelluksen käyttöönottoon, mukaan lukien lähdetiedostot, elinkaaritapahtumakoukut ja käyttöönottokokoonpanot."
        "explanation": "Sovellusmääritystiedosto (AppSpec) on YAML- tai JSON-muotoinen tiedosto, jota CodeDeploy käyttää käyttöönoton hallintaan. Se määrittää lähdetiedostot, koukut, jotka suoritetaan eri elinkaaren tapahtumissa (esim. BeforeInstall, AfterInstall) ja muita käyttöönottoparametreja."
      },
      {
        "question": "Mikä Amazon S3:n ominaisuus auttaa estämään vahingossa tapahtuvan tietojen poistamisen tai päällekirjoittamisen pitämällä useita objektin muunnelmia samassa lokerossa?",
        "answers": [
          { "answer": "S3 Cross-Region Replication" },
          { "answer": "S3-versiointi" },
          { "answer": "S3 Lifecycle Policy" },
          { "answer": "S3-tallennusluokan analyysi" }
        ],
        "answer": "S3-versiointi",
        "explanation": "S3-version avulla voit säilyttää useita versioita objektista yhdessä ryhmässä. Tämä voi auttaa sinua palauttamaan objekteja tahattomasta poistosta tai sovellusvirheistä ja arkistoida objekteja."
      },
      {
        "question": "Mikä on Amazon Route 53:n ensisijainen tehtävä?",
        "answers": [
          { "answer": "Suojatun VPN-yhteyden tarjoaminen VPC:llesi." },
          {
            "answer": "Toimii skaalautuvana DNS-verkkopalveluna, mukaan lukien verkkotunnuksen rekisteröinti ja kuntotarkastukset."
          },
          {
            "answer": "Saapuvan sovellusliikenteen jakaminen useille kohteille, kuten EC2-esiintymille."
          },
          { "answer": "Sovellustesi SSL/TLS-varmenteiden hallinta." }
        ],
        "answer": "Toimii skaalautuvana DNS (Domain Name System) -verkkopalveluna, mukaan lukien verkkotunnuksen rekisteröinti ja kuntotarkastukset.",
        "explanation": "Amazon Route 53 on erittäin saatavilla oleva ja skaalautuva DNS-pilvipalvelu. Se on suunniteltu tarjoamaan kehittäjille ja yrityksille erittäin luotettava ja kustannustehokas tapa reitittää loppukäyttäjät Internet-sovelluksiin."
      },
      {
        "question": "Sinun on tallennettava usein käytetyt tiedot RDS-tietokannastasi välimuistiin, jotta viivettä voidaan vähentää raskaassa työmäärässä. Mikä AWS-palvelu sopii tähän?",
        "answers": [
          { "answer": "Amazon S3" },
          { "answer": "Amazon DynamoDB Accelerator (DAX)" },
          { "answer": "Amazon ElastiCache (Käyttäen Redistä tai Memcachedia)" },
          { "answer": "AWS-tallennusyhdyskäytävä" }
        ],
        "answer": "Amazon ElastiCache (käyttäen Redistä tai Memcachedia)",
        "explanation": "Amazon ElastiCache on verkkopalvelu, jonka avulla on helppo ottaa käyttöön, käyttää ja skaalata muistissa olevaa välimuistia pilvessä. Se parantaa sovelluksen suorituskykyä mahdollistamalla tietojen hakemisen nopeista, hallituista, muistissa olevista välimuistista sen sijaan, että luottaisit kokonaan hitaampiin levypohjaisiin tietokantoihin."
      },
      {
        "question": "Mikä on 'tapahtumalähde' AWS Lambdan yhteydessä palvelimettomassa sovelluksessa?",
        "answers": [
          {
            "answer": "Lambda-funktion kirjoittamiseen käytetty ohjelmointikieli."
          },
          {
            "answer": "AWS-palvelu tai mukautettu sovellus, joka julkaisee tapahtumia Lambda-toiminnon käynnistämiseksi."
          },
          {
            "answer": "IAM-rooli, joka myöntää Lambda-funktiolle käyttöoikeudet."
          },
          { "answer": "Lambda-funktion palauttamat lähtötiedot." }
        ],
        "answer": "AWS-palvelu tai mukautettu sovellus, joka julkaisee tapahtumia Lambda-toiminnon käynnistämiseksi."
        "explanation": "Tapahtuman lähde on AWS-palvelu (kuten S3, API Gateway, SQS, DynamoDB Streams) tai mukautettu sovellus, joka luo tapahtumia, jotka käynnistävät AWS Lambda -toiminnon suorittamisen."
      },
      {
        "question": "Mikä on käsite "Idempotenssi" API-suunnittelun ja Lambda-toimintojen yhteydessä ja miksi se on tärkeää?",
        "answers": [
          {
            "answer": "Varmistaa, että toiminto voidaan suorittaa useita kertoja samalla teholla kuin jos se suoritettaisiin vain kerran; tärkeää uudelleenyritysten ja kaksoiskappaleiden käsittelyssä."
          },
          {
            "answer": "API:n käyttö vain tietyistä IP-osoitteista turvallisuuden vuoksi."
          },
          { "answer": "API:n optimointi mahdollisimman pienelle viiveelle." },
          {
            "answer": "Sallii API:n versioinnin helposti rikkomatta olemassa olevia asiakkaita."
          }
        ],
        "answer": "Varmistaa, että toiminto voidaan suorittaa useita kertoja samalla vaikutuksella kuin jos se suoritettaisiin vain kerran; tärkeää uudelleenyritysten ja kaksoiskappaleiden käsittelyssä."
        "explanation": "Idempotenssi varmistaa, että saman pyynnön tekeminen useita kertoja tuottaa saman tuloksen kuin kerran. Tämä on erittäin tärkeää hajautetuissa järjestelmissä, joissa verkko-ongelmista tai ohimenevistä virheistä johtuvat uudelleenyritykset ovat yleisiä, mikä estää tahattomat sivuvaikutukset, kuten päällekkäisen käsittelyn."
      },
      {
        "question": "Mitä AWS-palvelua käyttäisit, jos sinun on rakennettava GraphQL API -taustaohjelma sovelluksellesi?",
        "answers": [
          { "answer": "Amazon API Gateway REST-päätepisteillä" },
          { "answer": "AWS Lambda suoraan" },
          { "answer": "AWS AppSync" },
          { "answer": "Amazon EC2 mukautetulla GraphQL-palvelimella" }
        ],
        "answer": "AWS AppSync",
        "explanation": "AWS AppSync on hallittu palvelu, joka käyttää GraphQL:ää, jotta sovellusten on helppo saada juuri tarvitsemansa tiedot. Se voi muodostaa yhteyden useisiin tietolähteisiin, kuten DynamoDB-, Lambda-, RDS- ja HTTP-päätepisteisiin."
      },
      {
        "question": "Kuinka voit myöntää EC2-instanssille oikeudet käyttää S3-säilöä ilman pitkäaikaisia ​​pääsyavaimia?",
        "answers": [
          { "answer": "Upottamalla pääsyavaimet EC2-käyttäjätietoihin." },
          {
            "answer": "Luomalla IAM-käyttäjän ja tallentamalla sen tunnistetiedot EC2-instanssiin."
          },
          {
            "answer": "Määrittämällä IAM-rooli, jolla on tarvittavat S3-oikeudet EC2-ilmentymän profiilille."
          },
          {
            "answer": "Määrittämällä S3-säilökäytännön sallimaan anonyymi käyttö."
          }
        ],
        "answer": "Asettamalla IAM-rooli tarvittavilla S3-oikeuksilla EC2-ilmentymän profiiliin."
        "explanation": "EC2-ilmentymän profiiliin liitetyn IAM-roolin käyttäminen on turvallisin tapa. EC2-ilmentymä vastaanottaa automaattisesti väliaikaiset tunnistetiedot roolilta, jolloin pääsyavaimia ei tarvitse hallita."
      },
      {
        "question": "Mikä on Amazon Elastic File Systemin (EFS) ensisijainen käyttötapa?",
        "answers": [
          {
            "answer": "Tallenna lohkotason tallennustilavuuksia EC2-esiintymille, joilla on korkeat IOPS-vaatimukset."
          },
          { "answer": "Tarjoaa objektitallennustilaa staattista verkkosivuston isännöintiä varten." },
          {
            "answer": "Tarjoaa skaalautuvaa, jaettua tiedostotallennustilaa käytettäväksi AWS-pilvipalveluiden ja paikallisten resurssien kanssa, käytettävissä NFS-protokollan kautta."
          },
          { "answer": "Tietojen pitkäaikainen arkistointi erittäin alhaisilla kustannuksilla." }
        ],
        "answer": "Tarjoaa skaalautuvaa, jaettua tiedostotallennustilaa käytettäväksi AWS-pilvipalveluiden ja paikallisten resurssien kanssa, käytettävissä NFS-protokollan kautta."
        "explanation": "Amazon EFS tarjoaa yksinkertaisen, skaalautuvan, joustavan tiedostotallennustilan, joka voidaan asentaa useisiin EC2-esiintymiin (tai muihin palveluihin, kuten ECS/EKS) samanaikaisesti. Se on ihanteellinen jaetuille tietojoukoille, sisällönhallintajärjestelmille jne."
      },
      {
        "question": "Mitä eroa on suojausryhmän ja verkon ACL:n (NACL) välillä AWS-verkon yhteydessä?",
        "answers": [
          { "answer": "Turvallisuusryhmät ovat tilattomia; NACL:t ovat tilallisia." },
          {
            "answer": "Turvallisuusryhmät toimivat ilmentymätasolla; NACL:t toimivat aliverkkotasolla."
          },
          {
            "answer": "Turvallisuusryhmät sallivat vain säännöt; NACL:illä on vain estosääntöjä."
          },
          {
            "answer": "Ei ole toiminnallista eroa; ne ovat keskenään vaihdettavissa."
          }
        ],
        "answer": "Turvallisuusryhmät toimivat ilmentymätasolla; NACL:t toimivat aliverkkotasolla."
        "explanation": "Suojausryhmät toimivat virtuaalisena palomuurina EC2-esiintymille, jotka ohjaavat saapuvaa ja lähtevää liikennettä ilmentymistasolla (tilallinen). Verkon ACL-luettelot toimivat palomuurina, joka ohjaa liikennettä yhdestä tai useammasta aliverkosta (tilaton)."
      },
      {
        "question": "Jos sinun on suoritettava Lambda-toiminto CloudFrontin reunapaikoissa sisällön toimituksen mukauttamiseksi (esim. muokata otsikoita, A/B-testaus), mitä palvelua käyttäisit?",
        "answers": [
          { "answer": "AWS WAF" },
          { "answer": "AWS Shield Advanced" },
          { "answer": "Lambda@Edge" },
          { "answer": "Amazon API Gatewayn alueelliset päätepisteet" }
        ],
        "answer": "Lambda@Edge",
        "explanation": "Lambda@Edge antaa sinun suorittaa Lambda-toimintoja AWS Edge Locations -kohdissa vastauksena CloudFront-tapahtumiin (katsojan pyyntö, alkuperäpyyntö, lähtökohta vastaus, katsojan vastaus), jolloin voit mukauttaa sisällön toimitusta alhaisella viiveellä."
      },
      {
        "question": "Mihin 'Dead-Letter Queue'ta (DLQ)" käytetään Amazon SQS:ssä?",
        "answers": [
          {
            "answer": "Onnistuneesti käsiteltyjen viestien tallentamiseen."
          },
          { "answer": "Vanhojen viestien arkistointi, joita ei enää tarvita." },
          {
            "answer": "Eristää ja käsitellä viestejä, joita kuluttajasovellus ei pysty käsittelemään onnistuneesti tietyn uudelleenyritysten määrän jälkeen."
          },
          { "answer": "SQS-pääjonon suorituskyvyn lisääminen." }
        ],
        "answer": "Eristää ja käsitellä viestejä, joita kuluttajasovellus ei pysty käsittelemään onnistuneesti tietyn uudelleenyritysten määrän jälkeen."
        "explanation": "DLQ on jono, jossa muut (lähde)jonot voivat lähettää viestejä, joita ei voida käsitellä onnistuneesti. Tämä auttaa ongelmallisten viestien vianmäärityksessä estämättä pääjonoa ja mahdollistaa myöhemmän analyysin tai uudelleenkäsittelyn."
      },
      {
        "question": "Mikä AWS-palvelu tarjoaa hallittuja relaatiotietokantaesiintymiä, joissa on automaattinen korjaus, varmuuskopiointi ja skaalaus, jotka tukevat moottoreita, kuten MySQL, PostgreSQL, SQL Server jne.?",
        "answers": [
          { "answer": "Amazon DynamoDB" },
          { "answer": "Amazon Redshift" },
          { "answer": "Amazon RDS (relaatiotietokantapalvelu)" },
          { "answer": "Amazon DocumentDB" }
        ],
        "answer": "Amazon RDS (relaatiotietokantapalvelu)",
        "explanation": "Amazon RDS helpottaa relaatiotietokannan määrittämistä, käyttöä ja skaalaamista pilvessä. Se tarjoaa kustannustehokasta ja kokoa muutettavaa kapasiteettia samalla kun automatisoi aikaa vievät hallintatehtävät."
      },
      {
        "question": "Mikä on "Artefact", kun käytät AWS CodePipelinea?",
        "answers": [
          { "answer": "Tietetty versio liukuhihnan kokoonpanosta." },
          {
            "answer": "Tiedostojen tai muutosten kokoelma, jotka tulostetaan liukuhihnassa olevan toiminnon avulla (esim. koontituloste, lähdekoodi)."
          },
          { "answer": "Manuaalinen hyväksyntävaihe valmisteilla." },
          { "answer": "Kolmannen osapuolen työkalu, joka on integroitu prosessiin." }
        ],
        "answer": "Tiedostojen tai muutosten kokoelma, jotka tulostetaan liukuhihnassa olevan toiminnon avulla (esim. koontituloste, lähdekoodi).",
        "explanation": "CodePipelinen artefaktit ovat tiedostoja (kuten lähdekoodi, rakennetut sovellukset tai määritystiedostot), jotka siirretään liukuhihnassa olevien vaiheiden ja toimien välillä. Ne tallennetaan S3-artefaktialueeseen."
      },
      {
        "question": "Mikä on Amazon CloudTrailin ensisijainen tarkoitus?",
        "answers": [
          {
            "answer": "Sovellusten suorituskyvyn seurantaan ja mittareiden keräämiseen."
          },
          {
            "answer": "Tarjoaa visuaalisen käyttöliittymän AWS-resurssien hallintaan."
          },
          {
            "answer": "Kirjautua, seurata jatkuvasti ja säilyttää tilitoimintoja, jotka liittyvät AWS-infrastruktuurin toimintoihin (API-kutsut)."
          },
          { "answer": "Infrastruktuurin käyttöönoton automatisointi koodin avulla." }
        ],
        "answer": "Kirjautua, seurata jatkuvasti ja säilyttää tilitoimintoja, jotka liittyvät AWS-infrastruktuurin toimintoihin (API-kutsut).",
        "explanation": "CloudTrail tarjoaa AWS-tilisi tapahtumien tapahtumahistorian, mukaan lukien AWS-hallintakonsolin, AWS SDK:iden, komentorivityökalujen ja muiden AWS-palveluiden kautta tehdyt toimet. Tämä on ratkaisevan tärkeää tietoturva-analyysin, resurssien muutosten seurannan ja vaatimustenmukaisuuden tarkastuksen kannalta."
      },
      {
        "question": "Mikä AWS-palvelu tarjoaa täysin hallitun, erittäin skaalautuvan ja kustannustehokkaan tietovarastoratkaisun?",
        "answers": [
          { "answer": "Amazon RDS" },
          { "answer": "Amazon DynamoDB" },
          { "answer": "Amazon Redshift" },
          { "answer": "Amazon S3 Select" }
        ],
        "answer": "Amazon Redshift",
        "explanation": "Amazon Redshift on nopea, täysin hallittu, petatavun mittakaavainen tietovarastopalvelu, jonka avulla on helppoa ja kustannustehokasta analysoida kaikki tietosi käyttämällä SQL-standardia ja olemassa olevia Business Intelligence (BI) -työkaluja."
      },
      {
        "question": "Mikä on "laukaisimien" rooli Amazon Cognito User Poolsissa?",
        "answers": [
          { "answer": "Skaalaa automaattisesti käyttäjäryhmän kapasiteetin." },
          {
            "answer": "AWS Lambda -toimintojen käynnistäminen käyttäjän elinkaaren eri vaiheissa (esim. ennen rekisteröitymistä, vahvistuksen jälkeistä vahvistusta, ennen tunnuksen luomista)."
          },
          {
            "answer": "Multi-Factor Authentication (MFA) -todennuksen pakottaminen kaikille käyttäjille."
          },
          {
            "answer": "Integraatio kolmannen osapuolen identiteetintarjoajien kanssa suoraan."
          }
        ],
        "answer": "AWS Lambda -toimintojen käynnistäminen käyttäjän elinkaaren eri vaiheissa (esim. ennen rekisteröitymistä, vahvistuksen jälkeistä vahvistusta, ennen tunnuksen luomista).",
        "explanation": "Cognito User Pool -laukaisimien avulla voit mukauttaa käyttäjien työnkulkuja kutsumalla Lambda-toimintoja tietyissä kohdissa, kuten tarkistamalla käyttäjän attribuutteja ennen kirjautumista, lähettämällä mukautettuja vahvistusviestejä tai muokkaamalla vaatimuksia tunnustunnisteissa."
      },
      {
        "question": "Sinun on luotava AWS-infrastruktuuri käyttämällä tuttua ohjelmointikieltä, kuten Python, TypeScript tai Java. Minkä AWS-infrastruktuurin koodina (IaC) -työkalun valitsisit?",
        "answers": [
          { "answer": "AWS CloudFormation -mallit (YAML/JSON)" },
          { "answer": "AWS-hallintakonsoli" },
          { "answer": "AWS CDK (Cloud Development Kit)" },
          { "answer": "AWS CLI-komentosarjat" }
        ],
        "answer": "AWS CDK (Cloud Development Kit)",
        "explanation": "AWS CDK on avoimen lähdekoodin ohjelmistokehityskehys, joka määrittää pilvisovellusresurssit tutuilla ohjelmointikielillä. Se tarjoaa resurssit AWS CloudFormationin kautta."
      },
      {
        "question": "Mitä 'varattu läpimeno' tarkoittaa Amazon DynamoDB:n yhteydessä?",
        "answers": [
          {
            "answer": "Taulukon käytettävissä olevan tiedontallennustilan kokonaismäärä."
          },
          {
            "answer": "Taulukon tai hakemiston tukemien luku- ja kirjoitustoimintojen määrä sekunnissa."
          },
          {
            "answer": "DynamoDB-taulukolle varattu verkon kaistanleveys."
          },
          { "answer": "Samanaikaisten käyttäjäyhteyksien sallittu määrä." }
        ],
        "answer": "Luku- ja kirjoitustoimintojen määrä sekunnissa, jota taulukko tai indeksi voi tukea."
        "explanation": "Varastettu suorituskyky mitataan lukukapasiteettiyksiköinä (RCU) ja kirjoituskapasiteettiyksiköinä (WCU). Määrität tarvitsemasi kapasiteetin, ja DynamoDB varaa resursseja täyttääkseen kapasiteetin ennustettavalla suorituskyvyllä."
      },
      {
        "question": "Mikä AWS CodeDeployn käyttöönottostrategia siirtää liikennettä asteittain sovelluksen vanhasta versiosta uuteen versioon, mikä mahdollistaa seurannan ja nopean palautuksen, jos ongelmia ilmenee?",
        "answers": [
          { "answer": "Käyttöönotto" },
          { "answer": "Sininen/vihreä käyttöönotto" },
          { "answer": "Canary-käyttöönotto tai lineaarinen käyttöönotto" },
          { "answer": "Kaikki kerralla käyttöönotto" }
        ],
        "answer": "Kanarian käyttöönotto tai lineaarinen käyttöönotto",
        "explanation": "Canary- ja Lineaariset käyttöönotot (rullaavat päivitykset) siirtävät liikennettä määritettävin askelin (esim. 10 % kerrallaan). Sininen/vihreä vaihtaa kaiken liikenteen uuteen ympäristöön testauksen jälkeen. Paikalla olevat päivitykset."
      },
      {
        "question": "Mihin Amazon EventBridgeä käytetään ensisijaisesti modernissa palvelimettomassa arkkitehtuurissa?",
        "answers": [
          { "answer": "Suurten binääriobjektien turvallinen tallennus." },
          {
            "answer": "Tapahtumapohjaisten sovellusten rakentaminen reitittämällä tapahtumia AWS-palveluiden, mukautettujen sovellusten ja SaaS-sovellusten välillä."
          },
          { "answer": "Relaatiotietokantapalvelun tarjoaminen." },
          { "answer": "Käyttäjä-identiteetin ja käyttöoikeuksien hallinta." }
        ],
        "answer": "Tapahtumapohjaisten sovellusten rakentaminen reitittämällä tapahtumia AWS-palvelujen, mukautettujen sovellusten ja SaaS-sovellusten välillä."
        "explanation": "Amazon EventBridge on palvelimeton tapahtumaväyläpalvelu, jonka avulla on helppo yhdistää sovelluksia omien sovelluksien tietojen, integroitujen Software-as-a-Service (SaaS) -sovellusten ja AWS-palvelujen avulla. Se mahdollistaa löyhästi kytkettyjen, tapahtumalähtöisten arkkitehtuurien rakentamisen."
      },
      {
        "question": "Kun määritetään S3-säilö staattista verkkosivuston isännöintiä varten, mitä yleensä käytetään "hakemistoasiakirjana"?",
        "answers": [
          { "answer": "JSON-tiedosto, jossa luetellaan kaikki verkkosivuston sisältö." },
          {
            "answer": "Yksisivuisen sovelluksen pääasiallinen JavaScript-tiedosto."
          },
          {
            "answer": "HTML-tiedosto, joka toimii hakemiston oletussivuna (esim. index.html)."
          },
          { "answer": "Määritystiedosto CloudFrontille." }
        ],
        "answer": "HTML-tiedosto, joka toimii hakemiston oletussivuna (esim. index.html).",
        "explanation": "Kun määrität S3-ryhmän verkkosivuston isännöintiä varten, hakemistodokumentti (yleensä index.html) on verkkosivu, jonka Amazon S3 palauttaa, kun pyyntö tehdään verkkosivuston juureen tai mihin tahansa alikansioon."
      },
      {
        "question": "Mitä eroa on AWS Shield Standardin ja AWS Shield Advancedin välillä?",
        "answers": [
          {
            "answer": "Shield Standard on maksullinen palvelu; Shield Advanced on ilmainen."
          },
          {
            "answer": "Shield Standard suojaa vain EC2-esiintymiä; Shield Advanced suojaa kaikkia AWS-resursseja."
          },
          {
            "answer": "Shield Standard tarjoaa automaattisen suojan yleisiä DDoS-hyökkäyksiä vastaan ​​kaikille AWS-asiakkaille ilman lisämaksua; Shield Advanced tarjoaa parannetun, mukautettavan suojan ja pääsyn DDoS Response Teamiin (DRT)."
          },
          {
            "answer": "Shield Standard on verkkokerroksen hyökkäyksiä varten; Shield Advanced on sovelluskerroksen hyökkäyksiä varten."
          }
        ],
        "answer": "Shield Standard tarjoaa automaattisen suojan yleisiä DDoS-hyökkäyksiä vastaan ​​kaikille AWS-asiakkaille ilman lisämaksua; Shield Advanced tarjoaa parannetun, mukautettavan suojan ja pääsyn DDoS Response Teamiin (DRT).",
        "explanation": "AWS Shield Standard on automaattisesti käytössä kaikille AWS-asiakkaille. Shield Advanced on maksullinen palvelu, joka tarjoaa kehittyneemmän suojan sovelluksille, jotka toimivat palveluissa, kuten EC2, ELB, CloudFront, Route 53 ja Global Accelerator, mukaan lukien 24x7-pääsy AWS:n DDoS-tiimiin liittyvään DDRTKESS-suojaukseen ja kustannussuojaukseen."
      },
      {
        "question": "Kuinka AWS Key Management Service (KMS) auttaa tietojen salauksessa?",
        "answers": [
          {
            "answer": "Salaamalla ja purkamalla suoraan suuria tietomääriä KMS-palvelun sisällä."
          },
          {
            "answer": "Luomalla, hallitsemalla ja hallitsemalla salausavaimia (Customer Master Keys - CMK), joita käytetään muihin AWS-palveluihin tai -sovelluksiin tallennettujen tietojen salaamiseen."
          },
          {
            "answer": "Tarjoamalla laitteiston suojausmoduulin (HSM), jota hallitset täysin."
          },
          {
            "answer": "Skannaamalla tietosi arkaluontoisten tietojen varalta ja salaamalla ne automaattisesti."
          }
        ],
        "answer": "Luomalla, hallitsemalla ja hallitsemalla salausavaimia (Customer Master Keys - CMK), joita käytetään muihin AWS-palveluihin tai -sovelluksiin tallennettujen tietojen salaamiseen."
        "explanation": "AWS KMS tarjoaa turvallisen ja joustavan palvelun salausavaimien hallintaan. Se integroituu moniin AWS-palveluihin yksinkertaistaakseen tietojen salaamista näillä avaimilla. Sinä hallitset avainten (CMK) elinkaarta ja käyttöoikeuksia. Näitä avaimia käytetään salaamaan/purkaamaan dataavaimet, jotka puolestaan ​​salaavat/purkaavat todelliset tietosi."
      },
      {
        "question": "Sinulla on Docker-tiedostolla määritetty konttisovellus. Mikä AWS-palvelu on erityisesti suunniteltu tallentamaan ja hallitsemaan Docker-säiliökuviasi?",
        "answers": [
          { "answer": "Amazon S3" },
          { "answer": "AWS CodeCommit" },
          { "answer": "Amazon ECR (Elastic Container Registry)" },
          { "answer": "Amazon EC2 Instance Store" }
        ],
        "answer": "Amazon ECR (elastic Container Registry)",
        "explanation": "Amazon ECR on täysin hallittu Docker-säilörekisteri, jonka avulla kehittäjien on helppo tallentaa, hallita ja ottaa käyttöön Docker-säilökuvia. Se integroituu hyvin ECS:n, EKS:n ja Fargaten kanssa."
      },
      {
        "question": "Mikä on VPC-päätepiste ja minkä ongelman se ratkaisee?",
        "answers": [
          {
            "answer": "VPN-yhteys paikalliseen verkkoosi; ratkaisee hybridiyhteyden."
          },
          {
            "answer": "Julkinen IP-osoite EC2-instanssille; ratkaisee Internetin käytettävyyden."
          },
          {
            "answer": "Sen avulla voit yhdistää VPC:si yksityisesti tuettuihin AWS-palveluihin (esim. S3, DynamoDB) ja VPC-päätepistepalveluihin ilman Internet-yhdyskäytävää, NAT-laitetta, VPN-yhteyttä tai AWS Direct Connect -yhteyttä. Ratkaisee turvallisen, yksityisen yhteyden palveluihin."
          },
          {
            "answer": "Kuormantasaaja liikenteen jakamiseen; ratkaisee korkean käytettävyyden."
          }
        ],
        "answer": "Sen avulla voit yhdistää VPC:si yksityisesti tuettuihin AWS-palveluihin (esim. S3, DynamoDB) ja VPC-päätepalveluihin ilman Internet-yhdyskäytävää, NAT-laitetta, VPN-yhteyttä tai AWS Direct Connect -yhteyttä. Ratkaisee turvallisen, yksityisen yhteyden palveluihin.",
        "explanation": "VPC-päätepisteet pitävät liikennettä VPC:n ja tuetun AWS-palvelun välillä Amazon-verkossa, mikä parantaa turvallisuutta ja mahdollisesti pienentää tiedonsiirtokustannuksia. On Interface Endpoints (jossa käytetään elastisia verkkoliitäntöjä) ja Gateway Endpoints (S3:lle ja DynamoDB:lle)."
      },
      {
        "question": "Mikä on Amazon Auroran Global Database -ominaisuuden ensisijainen käyttötapa?",
        "answers": [
          {
            "answer": "Skaalaa automaattisesti tietokannan tallennuskapasiteettia useille alueille."
          },
          {
            "answer": "Tarjoaa matalan viiveen globaaleja lukuja ja hätäpalautusta replikoimalla tietokanta useille AWS-alueille."
          },
          {
            "answer": "Eri alueille tallennettujen tietokannan varmuuskopioiden salaamiseen."
          },
          {
            "answer": "Ottaa käyttöön tietokantojen väliset kyselyt Aurora-ilmentymien välillä eri alueilla."
          }
        ],
        "answer": "Tarjoaa alhaisen latenssin globaaleja lukuja ja katastrofipalautusta replikoimalla tietokanta useille AWS-alueille."
        "explanation": "Amazon Aurora Global Database on suunniteltu maailmanlaajuisesti hajautetuille sovelluksille, jolloin yksi Aurora-tietokanta voi kattaa useita AWS-alueita. Se replikoi tietoja tyypillisellä alle sekunnin viiveellä, mikä mahdollistaa nopeat paikalliset lukemat toissijaisilla alueilla ja tarjoaa tehokkaan katastrofipalautusvaihtoehdon."
      },
      {
        "question": "Jos haluat suorittaa koodin vastauksena DynamoDB-taulukon muutoksiin (esim. kun uusi nimike lisätään tai kohde päivitetään), mitä AWS-palvelua käyttäisit yleensä laukaisinkohteena?",
        "answers": [
          { "answer": "Amazon EC2-instanssi" },
          { "answer": "AWS Lambda -toiminto (DynamoDB Streamsin kautta)" },
          { "answer": "Amazon SQS -jono" },
          { "answer": "AWS-vaihetoimintojen tilakone" }
        ],
        "answer": "AWS Lambda -toiminto (DynamoDB Streamsin kautta)",
        "explanation": "DynamoDB-virrat kaappaavat aikajärjestyksessä järjestetyn nimiketason muutosten sarjan DynamoDB-taulukkoon. Nämä virrat voidaan sitten määrittää tapahtumalähteiksi AWS Lambdalle, jolloin voit käynnistää Lambda-toiminnon käsittelemään nämä muutokset, esimerkiksi replikoimaan tietoja, lähettämään ilmoituksia tai suorittamaan aggregaatioita."
      },
      {
        "question": "Millä CloudWatch-ominaisuuden avulla voit luoda räätälöityjä näkymiä mittareista ja hälytyksistä AWS-resursseillesi, mikä tarjoaa konsolidoidun toiminnallisen kojelaudan?",
        "answers": [
          { "answer": "CloudWatch Logs Insights" },
          { "answer": "CloudWatch-hälytykset" },
          { "answer": "CloudWatch Dashboards" },
          { "answer": "CloudWatch-tapahtumat (nyt EventBridge)" }
        ],
        "answer": "CloudWatch Dashboards",
        "explanation": "CloudWatch Dashboardit ovat muokattavissa olevia CloudWatch-konsolin kotisivuja, joiden avulla voit seurata resurssejasi yhdessä näkymässä, jopa eri alueilla sijaitsevia resursseja. Voit luoda mittareita, kaavioita ja hälytyksiä näyttäviä hallintapaneeleja."
      },
      {
        "question": "Olet ottamassa käyttöön mikropalveluarkkitehtuuria Amazon ECS:ssä. Kuinka voit ottaa palveluiden löytämisen käyttöön, jotta palvelut voivat dynaamisesti löytää ja kommunikoida keskenään?",
        "answers": [
          { "answer": "Koodaamalla IP-osoitteet palvelukokoonpanoissa." },
          { "answer": "Käytetään Amazon ECS:ään integroitua AWS Cloud Mapia." },
          {
            "answer": "DNS-tietueiden manuaalinen päivittäminen reitissä 53 jokaiselle palveluinstanssille."
          },
          {
            "answer": "Luotamme yksinomaan elastisiin kuormituksen tasapainottajiin kaikessa yksiköiden välisessä viestinnässä."
          }
        ],
        "answer": "Käytetään Amazon ECS:ään integroitua AWS Cloud Mapia."
        "explanation": "AWS Cloud Map antaa sinun rekisteröidä mitä tahansa sovellusresursseja, kuten tietokantoja, jonoja, mikropalveluita ja muita pilviresursseja mukautetuilla nimillä. Sovelluksesi voi sitten kysellä näitä nimiä AWS SDK:n tai DNS:n kautta. ECS integroituu Cloud Mapiin, jotta palveluiden löytäminen on helppoa konttisovelluksille."
      },
      {
        "question": "Mikä on kutsutyypin tarkoitus kutsuttaessa AWS Lambda -funktiota (esim. RequestResponse, Event, DryRun)?",
        "answers": [
          {
            "answer": "Se määrittää Lambda-funktion ohjelmointikielen ajonajan."
          },
          {
            "answer": "Se määrittää, kuinka Lambda-toiminto käynnistetään ja kuinka soittaja odottaa vastausta."
          },
          {
            "answer": "Se määrittää muistin varauksen lambda-toiminnolle."
          },
          {
            "answer": "Se hallitsee Lambda-toiminnolle myönnettyjä IAM-oikeuksia."
          }
        ],
        "answer": "Se määrittää, kuinka Lambda-toiminto laukaistaan ​​ja kuinka soittaja odottaa vastausta."
        "explanation": "'RequestResponse' (oletus, synkroninen) odottaa funktion valmistumista ja palauttaa tuloksen. 'Event' (asynkroninen) kutsuu funktion ja palauttaa sen välittömästi. 'DryRun' testaa käyttöoikeuksia kutsumatta funktiota varsinaisesti."
      },
      {
        "question": "Millä Amazon S3 -ominaisuuden avulla voit automaattisesti siirtää kohteita kustannustehokkaampiin tallennusluokkiin (esim. S3 Standard-IA, S3 Glacier) tai poistaa ne tietyn ajan kuluttua?",
        "answers": [
          { "answer": "S3-versiointi" },
          { "answer": "S3-ryhmäkäytännöt" },
          { "answer": "S3 Lifecycle Policy" },
          { "answer": "S3:n replikointiajan ohjaus (RTC)" }
        ],
        "answer": "S3-elinkaarikäytännöt",
        "explanation": "S3 Lifecycle -käytäntöjen avulla voit määrittää sääntöjä, jotka automatisoivat objektien siirtymisen eri tallennusluokkiin tai vanhentavat (poistavat) objektit tietyn ajan kuluttua. Tämä auttaa optimoimaan varastointikustannuksia ja hallitsemaan objektien elinkaaria."
      },
      {
        "question": "Jos palvelimettomassa sovelluksessa Lambda-toiminnon on suoritettava pitkäkestoinen tehtävä (esim. videon käsittely, joka saattaa ylittää Lambdan enimmäissuoritusajan), mikä palvelu voisi järjestää tämän jakamalla sen pienempiin vaiheisiin tai hallitsemalla pitkäkestoista työtä?",
        "answers": [
          { "answer": "Amazon API Gateway" },
          {
            "answer": "AWS Fargate koko pitkän tehtävän suorittamiseen säilössä"
          },
          {
            "answer": "AWS-vaihetoiminnot työnkulun organisointiin, mahdollisesti yhdistettynä Fargaten tai Batchin kanssa itse pitkälle tehtävälle."
          },
          { "answer": "Amazon SQS asettaa tehtävän jonoon määräämättömäksi ajaksi." }
        ],
        "answer": "AWS-vaihetoiminnot työnkulun organisointiin, mahdollisesti yhdistettynä Fargaten tai Batchin kanssa itse pitkää tehtävää varten."
        "explanation": "AWS Step Functions voi organisoida työnkulkuja, jotka sisältävät pitkäkestoisia tehtäviä. Lambdan rajat ylittävissä tehtävissä Step Functions voi integroitua palveluihin, kuten AWS Batch tai AWS Fargate (toimintotehtävien tai palveluintegraatioiden kautta) suorittaakseen laskentaintensiivisen osan, kun taas Step Functions hallitsee yleistä tilaa ja toistoja."
      },
      {
        "question": "Mikä on Amazon Aurora Serverlessin käytön ensisijainen hyöty verrattuna provisoituun Amazon Auroraan?",
        "answers": [
          { "answer": "Se tarjoaa huomattavasti suuremman kirjoitusnopeuden." },
          {
            "answer": "Se käynnistyy automaattisesti, sammuu ja skaalaa kapasiteettia ylös tai alas sovelluksesi tarpeiden mukaan, mikä tekee siitä ihanteellisen harvoin, ajoittaiseen tai arvaamattomaan työkuormaan."
          },
          {
            "answer": "Se tarjoaa enemmän tietokantamoottorivaihtoehtoja (esim. SQL Server)."
          },
          {
            "answer": "Se mahdollistaa suoran SSH-käytön taustalla oleviin tietokantaesiintymiin."
          }
        ],
        "answer": "Se käynnistyy automaattisesti, sammuu ja skaalaa kapasiteettia ylös tai alas sovelluksesi tarpeiden mukaan, mikä tekee siitä ihanteellisen harvoin, ajoittaiseen tai arvaamattomaan työkuormaan."
        "explanation": "Aurora Serverless on on-demand, automaattisesti skaalautuva kokoonpano Amazon Auroralle. Se säätää tietokannan kapasiteettia automaattisesti sovellusten kysynnän perusteella, mikä vähentää vaihtelevien työkuormien kustannuksia, kun maksat vain kulutetusta kapasiteetista."
      },
      {
        "question": "Millä AWS-palvelulla voit luoda ja hallita SSL/TLS-varmenteita verkkosivustollesi tai sovelluksellesi, jota tarjoavat palvelut, kuten Elastic Load Balancing tai CloudFront?",
        "answers": [
          { "answer": "AWS IAM" },
          { "answer": "AWS KMS (Key Management Service)" },
          { "answer": "AWS-varmenteiden hallinta (ACM)" },
          { "answer": "AWS Secrets Manager" }
        ],
        "answer": "AWS Certificate Manager (ACM)",
        "explanation": "AWS Certificate Manager (ACM) hoitaa monimutkaisen luomisen, tallennuksen ja uusimisen julkisten ja yksityisten SSL/TLS X.509 -varmenteiden ja -avaimien, jotka suojaavat AWS-sivustojasi ja -sovelluksiasi. Voit tarjota julkisia varmenteita ilmaiseksi käytettäväksi ACM-integroitujen palvelujen kanssa."
      }
    ]
  },
  {
    "name": "AWS SaaS -käyttöönoton ja -virheenkorjauksen asiantuntija",
    "image": "https://images.unsplash.com/photo-1612838320302-4b3b3b3b3b3b",
    "questions": [
      {
        "question": "Mikä CLI-komento ottaa käyttöön CloudFormation-pinon?",
        "answers": [
          {
            "answer": "aws cloudformation deploy --template-file template.yaml"
          },
          { "answer": "aws deploy create-stack template.yml" },
          { "answer": "aws s3 cp template.yml stack-deploy" },
          { "answer": "aws ec2 create-stack --template template.yaml" }
        ],
        "answer": "aws cloudformation deploy --template-file template.yaml",
        "explanation": "Oikea komento käyttää CloudFormation-palvelun deploy-komentoa parametrin --template-file kanssa. Muut vaihtoehdot käyttävät joko vääriä palvelunimiä (ec2) tai virheellistä komentosyntaksia."
      },
      {
        "question": "Kuinka 'Lambda-toiminto aikakatkaisu' -virheen vianmääritys?",
        "answers": [
          { "answer": "Kasvata aikakatkaisun arvoa ja tarkista loputtomat silmukat" },
          { "answer": "Vähennä muistin varausta" },
          { "answer": "Ota VPC-määritys käyttöön" },
          { "answer": "Poista toiminto ja luo se uudelleen" }
        ],
        "answer": "Kasvata aikakatkaisun arvoa ja tarkista loputtomat silmukat",
        "explanation": "Lambda-aikakatkaisu tapahtuu, kun suoritus ylittää määritetyn keston. Pidennä ensin aikakatkaisua (enintään 15 minuuttiin) ja analysoi sitten pitkään käynnissä olevien prosessien tai loputtomien silmukoiden koodi CloudWatch-lokien avulla."
      },
      {
        "question": "Mikä komento näyttää reaaliaikaiset Lambda-lokit?",
        "answers": [
          { "answer": "aws logs tail /aws/lambda/my-function" },
          { "answer": "aws lambda get-log my-function" },
          { "answer": "aws cloudwatch stream-logs lambda" },
          { "answer": "aws lambda trace --function my-function" }
        ],
        "answer": "aws logs tail /aws/lambda/my-function",
        "explanation": "Aws logs tail -komento seuraa lokivirtoja reaaliajassa. Muut vaihtoehdot käyttävät vääriä palvelunimiä tai olemattomia komentoja."
      },
      {
        "question": "Mikä on ensimmäinen askel '403 Forbidden' -virheiden korjaamiseen S3:sta?",
        "answers": [
          { "answer": "Tarkista ryhmäkäytännöt ja IAM-oikeudet" },
          { "answer": "Ota CORS-määritys käyttöön" },
          { "answer": "Kasvata kauhan tallennuskapasiteettia" },
          { "answer": "Muokkaa verkon ACL-luetteloita" }
        ],
        "answer": "Tarkista ryhmäkäytännöt ja IAM-oikeudet",
        "explanation": "403-virheet osoittavat tyypillisesti lupaongelmia. Tarkista ensin pyynnön esittäneen entiteetin ryhmäkäytännöt (julkinen käyttöoikeus) ja IAM-oikeudet ennen verkkosääntöjen tutkimista."
      },
      {
        "question": "Mikä palvelu yrittää automaattisesti uudelleen epäonnistuneita tietokantasiirtoja?",
        "answers": [
          { "answer": "AWS DMS (tietokannan siirtopalvelu)" },
          { "answer": "RDS automaattiset varmuuskopiot" },
          { "answer": "Lambda eksponentiaalisella perääntymisellä" },
          { "answer": "EC2-pisteinstanssit" }
        ],
        "answer": "AWS DMS (tietokannan siirtopalvelu)",
        "explanation": "AWS DMS:ssä on sisäänrakennettu uudelleenyrityslogiikka tietokantojen siirtoja varten. Vaikka Lambda voi toteuttaa uudelleenyrityksiä, DMS on suunniteltu tietokannan siirtotehtäviin automaattisen palautuksen kanssa."
      },
      {
        "question": "Kuinka ratkaista 'Cold Start' -ongelmat Lambdassa?",
        "answers": [
          { "answer": "Käytä määritettyä samanaikaisuutta" },
          { "answer": "Lisää muistin varausta" },
          { "answer": "Muunna EC2-esiintymiksi" },
          { "answer": "Ota röntgenseuranta käyttöön" }
        ],
        "answer": "Käytä määritettyä samanaikaisuutta",
        "explanation": "Provisioned Concurrency pitää toiminnot alustettuina ja valmiina vastaamaan. Muistin lisääminen auttaa, mutta ei poista kylmäkäynnistystä. Röntgen auttaa vain diagnosoimaan, ei ehkäisemään."
      },
      {
        "question": "Mikä CLI-komento kutsuu Lambda-funktion testausta varten?",
        "answers": [
          {
            "answer": "aws lambda invoke --function-name my-function output.txt"
          },
          { "answer": "aws lambda testaa my-function payload.json" },
          { "answer": "aws-funktio kutsuu minun funktioni" },
          { "answer": "aws lambda run --function my-function" }
        ],
        "answer": "aws lambda invoke --function-name my-function output.txt",
        "explanation": "Invoke-komento edellyttää tulostiedoston määrittämistä. Muut valinnat käyttävät väärää komentosyntaksia tai olemattomia alikomentoja."
      },
      {
        "question": "Mikä on paras tapa hallita ympäristömuuttujia eri vaiheissa?",
        "answers": [
          { "answer": "Käytä Parameter Storea Systems Managerissa" },
          { "answer": "Tallenna GitHubin salaisuuksiin" },
          { "answer": "Kovakoodi käyttöönottoskripteissä" },
          { "answer": "Käytä S3-säilömäärityksiä" }
        ],
        "answer": "Käytä Parameter Storea Systems Managerissa",
        "explanation": "Parametrisäilö tarjoaa suojatun, versioidut tallennustilan IAM-käyttöoikeuksien hallinnan kanssa. GitHub Secrets toimii vain CI/CD:llä, S3 ei ole suojattu kirjautumistiedoille."
      },
      {
        "question": "Kuinka debug '502 Bad Gateway' API Gatewayssa?",
        "answers": [
          { "answer": "Tarkista Lambda-integroinnin aikakatkaisuarvot" },
          { "answer": "Muokkaa Route 53 DNS -asetuksia" },
          { "answer": "Kasvata API Gatewayn välimuistin kokoa" },
          { "answer": "Ota CloudFront-jakelu käyttöön" }
        ],
        "answer": "Tarkista lambda-integroinnin aikakatkaisuarvot",
        "explanation": "502-virheitä esiintyy usein, kun taustapalvelut (kuten Lambda) aikakatkaisu ennen vastaamista. API-yhdyskäytävällä on enintään 29 sekunnin aikakatkaisu, Lambda voi olla jopa 15 minuuttia."
      },
      {
        "question": "Mikä komento luo ECS-palvelun?",
        "answers": [
          {
            "answer": "aws ecs create-service --cluster my-cluster --service-name my-service"
          },
          { "answer": "aws ecs new service my-service" },
          { "answer": "aws deploy create-ecs-service" },
          { "answer": "aws ec2 create-ecs-service" }
        ],
        "answer": "aws ecs create-service --cluster my-cluster --service-name my-service",
        "explanation": "ECS-palvelut luodaan ecs-nimiavaruuden kautta. Muut vaihtoehdot käyttävät vääriä palvelunimiä tai olemattomia komentoja."
      },
      {
        "question": "Kuinka vianmääritys "Laitteessa ei ole tilaa" EC2:ssa?",
        "answers": [
          { "answer": "Muuta EBS-taltion kokoa ja muokkaa tiedostojärjestelmää" },
          { "answer": "Käynnistä ilmentymä uudelleen" },
          { "answer": "Lisää ilmentymän tyyppiä" },
          { "answer": "Poista CloudWatch-lokit" }
        ],
        "answer": "Muuta EBS-taltion kokoa ja muokkaa tiedostojärjestelmää",
        "explanation": "Kun kokoa on muutettu AWS-konsolin/CLI:n kautta, tiedostojärjestelmää on laajennettava kasvuosien tai vastaavien työkalujen avulla. Pelkkä uudelleenkäynnistys ei ratkaise tallennusongelmia."
      },
      {
        "question": "Mikä komento listaa käynnissä olevat kontit ECS:ssä?",
        "answers": [
          { "answer": "aws ecs list-container-instances --cluster my-cluster" },
          { "answer": "aws ec2 description-containers" },
          { "answer": "aws docker ps" },
          { "answer": "aws ecs get-containers" }
        ],
        "answer": "aws ecs list-container-instances --cluster my-cluster",
        "explanation": "ECS hallitsee säilön ilmentymiä oman sovellusliittymänsä kautta. Docker ps -komento toimii vain paikallisissa Docker-asennuksissa."
      },
      {
        "question": "Mikä on ensimmäinen askel API-vastausten korkean latenssin diagnosoimiseksi?",
        "answers": [
          { "answer": "Käytä CloudWatch-mittareita ja röntgenseurantaa" },
          { "answer": "Kasvata lambda-muistin varausta" },
          { "answer": "Lisää API Gateway -vaiheita" },
          { "answer": "Ota automaattinen skaalaus käyttöön" }
        ],
        "answer": "Käytä CloudWatch-mittareita ja röntgenseurantaa",
        "explanation": "X-Ray tarjoaa palvelukarttoja ja jälkiä pullonkaulojen tunnistamiseen. Skaalaus tulee tehdä vasta perimmäisen syyn tunnistamisen jälkeen."
      },
      {
        "question": "Kuinka peruuttaa epäonnistunut CloudFormation-käyttöönotto?",
        "answers": [
          { "answer": "Käytä AWS-konsolin palautusvaihtoehtoa" },
          { "answer": "Poista pino ja luo uudelleen" },
          { "answer": "Muokkaa mallia ja asenna uudelleen" },
          {
            "answer": "aws cloudformation rollback-stack -- pinon-nimi oma-pino"
          }
        ],
        "answer": "Käytä AWS-konsolin palautusvaihtoehtoa",
        "explanation": "Konsoli tarjoaa yhden napsautuksen palautuksen epäonnistuneille käyttöönotuksille. CLI vaatii monimutkaisempia pinon päivitystoimintoja."
      },
      {
        "question": "Mikä komento tekee verkkoyhteyden vianmäärityksen VPC:ssä?",
        "answers": [
          { "answer": "aws ec2 description-network-interfaces" },
          { "answer": "aws vpc test-connectivity" },
          { "answer": "aws-verkkodiagnoosi" },
          { "answer": "aws check-vpc-routes" }
        ],
        "answer": "aws ec2 description-network-interfaces",
        "explanation": "Tämä komento näyttää ENI:n tilan ja määritykset. Muut valinnat käyttävät olemattomia komentoja."
      },
      {
        "question": "Kuinka virheenkorjaus 'Tehtävä epäonnistui' käynnistys' ECS:ssä?",
        "answers": [
          { "answer": "Tarkista tehtävän määritelmä ja säilölokit" },
          { "answer": "Kasvata suorittimen varausta" },
          { "answer": "Muokkaa suojausryhmiä" },
          { "answer": "Rakenna Docker-kuva uudelleen" }
        ],
        "answer": "Tarkista tehtävän määritelmä ja säilölokit",
        "explanation": "Yleisiä ongelmia ovat virheelliset säilömääritykset, puuttuvat käyttöoikeudet tai ECS-palvelun tapahtumalokeissa näkyvät resurssirajoitukset."
      },
      {
        "question": "Mikä CLI-komento saa RDS:n hitaita kyselylokeja?",
        "answers": [
          { "answer": "aws rds description-db-log-files" },
          { "answer": "aws-lokit saavat rds-slow-queries" },
          { "answer": "aws rds export-logs-to-s3" },
          { "answer": "aws mysql show-slow-logs" }
        ],
        "answer": "aws rds description-db-log-files",
        "explanation": "Listaa ensin saatavilla olevat lokit kuvaus-db-lokitiedostoilla ja lataa sitten komennolla download-db-log-file-portion. Muut vaihtoehdot käyttävät vääriä palvelunimiä."
      },
      {
        "question": "Mikä on paras tapa seurata Lambda-muistin käyttöä?",
        "answers": [
          { "answer": "CloudWatch Lambda Insights" },
          { "answer": "Röntgensegmentin merkinnät" },
          { "answer": "S3-käyttölokit" },
          { "answer": "API-yhdyskäytävän tiedot" }
        ],
        "answer": "CloudWatch Lambda Insights",
        "explanation": "Lambda Insights tarjoaa yksityiskohtaisia ​​muisti-/suoritinmittareita. X-Ray keskittyy jäljittämiseen resurssien tarkkailun sijaan."
      },
      {
        "question": "Kuinka ratkaistaan ​​"Määritettyä ryhmää ei ole olemassa" käyttöönoton aikana?",
        "answers": [
          { "answer": "Vahvista S3-säilön nimi ja alue" },
          { "answer": "Lisää IAM-oikeuksia" },
          { "answer": "Muokkaa ACL-luetteloita" },
          { "answer": "Ota versiointi käyttöön" }
        ],
        "answer": "Vahvista S3-säilön nimi ja alue",
        "explanation": "Yleisiä syitä ovat kirjoitusvirheet säilön nimissä tai käyttöönotto väärälle alueelle. S3-säilön nimet ovat globaaleja, mutta toiminnassa aluekohtaisia."
      },
      {
        "question": "Mikä komento testaa API Gateway -päätepisteet?",
        "answers": [
          { "answer": "aws apigateway test-invoke-method" },
          {
            "answer": "curl -X POST https://api-id.execute-api.region.amazonaws.com/stage"
          },
          { "answer": "aws lambda invoke api-test" },
          { "answer": "aws api testipäätepiste" }
        ],
        "answer": "aws apigateway testi-invoke-method",
        "explanation": "Test-invoke-method-komento vahvistaa integraation ilman julkista paljastamista. Curl vaatii käyttöönotetun vaiheen ja asianmukaiset käyttöoikeudet."
      },
      {
        "question": "Kuinka diagnosoida korkea suorittimen käyttöaste EC2:ssa?",
        "answers": [
          {
            "answer": "Käytä CloudWatch Metricsia ja asenna CloudWatch-agentti"
          },
          { "answer": "Käynnistä ilmentymä välittömästi uudelleen" },
          { "answer": "Päivitä suurempaan ilmentymätyyppiin" },
          { "answer": "Tarkista S3-käyttömallit" }
        ],
        "answer": "Käytä CloudWatch Metricsia ja asenna CloudWatch-agentti",
        "explanation": "Agentti tarjoaa yksityiskohtaisia ​​järjestelmämittareita. Uudelleenkäynnistys tai skaalaus tulee tehdä vasta juuriprosessin tunnistamisen jälkeen."
      },
      {
        "question": "Mikä komento päivittää Lambda-funktion ympäristömuuttujat?",
        "answers": [
          {
            "answer": "aws lambda update-function-configuration --environment Variables={KEY=VAL}"
          },
          { "answer": "aws lambda set-env my-function KEY=VAL" },
          { "answer": "aws update-lambda-env --function my-function KEY=VAL" },
          { "answer": "aws-funktion asetuspäivitys --env KEY=VAL" }
        ],
        "answer": "aws lambda update-function-configuration --environment Variables={KEY=VAL}",
        "explanation": "Ympäristömuuttujat ovat osa funktion konfiguraatiota. Muut vaihtoehdot käyttävät olemattomia komentoja tai väärää syntaksia."
      },
      {
        "question": "Kuinka 'InvalidSignatureException'-vianmääritys API-kutsuissa?",
        "answers": [
          { "answer": "Tarkista AWS-tunnistetietojen vanheneminen ja alue" },
          { "answer": "Lisää API-yhdyskäytävän aikakatkaisua" },
          { "answer": "Muokkaa VPC-suojausryhmiä" },
          { "answer": "Ota CloudTrail-loki käyttöön" }
        ],
        "answer": "Tarkista AWS-tunnistetietojen vanheneminen ja alue",
        "explanation": "Virheelliset allekirjoitukset viittaavat yleensä kellon vinoon, vanhentuneisiin valtuustietoihin tai alueelliseen yhteensopimattomuuteen. Tarkista aina valtuustiedot komennolla "aws sts get-caller-identity".
      },
      {
        "question": "Mikä komento vie DynamoDB-taulukon S3:een?",
        "answers": [
          { "answer": "aws dynamodb export-table-to-point-in-time" },
          { "answer": "aws s3 sync dynamodb://table s3://bucket" },
          { "answer": "aws backup export-dynamodb-table" },
          { "answer": "aws data-pipeline create-from-dynamodb" }
        ],
        "answer": "aws dynamodb export-table-to-point-in-time",
        "explanation": "Tämä natiivikomento suorittaa ajankohtaisia ​​vientiä. Data Pipeline vaatii monimutkaisemman asennuksen samankaltaisille toiminnoille."
      },
      {
        "question": "Kuinka virheenkorjaus "Suoritus epäonnistui konfigurointivirheen vuoksi" Lambdassa?",
        "answers": [
          { "answer": "Tarkista funktion roolien käyttöoikeudet ja resurssikäytännöt" },
          { "answer": "Lisää toiminnon aikakatkaisua" },
          { "answer": "Aseta funktiokoodi uudelleen" },
          { "answer": "Ota VPC-kulkulokit käyttöön" }
        ],
        "answer": "Tarkista funktion roolien käyttöoikeudet ja resurssikäytännöt",
        "explanation": "Määritysvirheet liittyvät usein IAM-käyttöoikeuksiin tai resurssikäytäntöihin (kuten S3-säilön käyttöoikeuksiin). Tarkista CloudTrailista pääsy estetty -virheet."
      },
      {
        "question": "Mikä komento listaa kaikki käynnissä olevat EC2-instanssit?",
        "answers": [
          {
            "answer": "aws ec2 description-instances --filters Nimi=esiintymän-tilan-nimi,Arvot=käynnissä"
          },
          { "answer": "aws list ec2-instanssit" },
          { "answer": "aws ec2 get-running-instances" },
          { "answer": "aws compute list-esiintymiä" }
        ],
        "answer": "aws ec2 description-instances --filters Nimi=esiintymän-tilan-nimi,Arvot=käynnissä",
        "explanation": "Komento description-instances suodattimilla on oikea lähestymistapa. Muut vaihtoehdot käyttävät olemattomia komentoja."
      },
      {
        "question": "Kuinka ratkaista 'TooManyRequestsException' AWS API -kutsuissa?",
        "answers": [
          { "answer": "Ota eksponentiaalinen backoff asiakaskoodissa käyttöön" },
          { "answer": "Kasvata IAM-roolin käyttöoikeuksia" },
          { "answer": "Päivitä AWS-tukisuunnitelma" },
          { "answer": "Muokkaa CloudWatchin hälytyskynnysarvoja" }
        ],
        "answer": "Ota eksponentiaalinen backoff asiakaskoodiin",
        "explanation": "AWS-palvelut hillitsevät API-pyyntöjä. Eksponentiaalinen perääntyminen värinän kanssa on suositeltu uudelleenyritysstrategia."
      },
      {
        "question": "Mikä komento tarkistaa CloudFormation-pinon ajautumisen?",
        "answers": [
          { "answer": "aws cloudformation detect-stack-drift" },
          { "answer": "aws cfn check-drift --stack my-stack" },
          { "answer": "aws cloudformation verify-stack" },
          { "answer": "aws drift -tunnistuksen aloitus" }
        ],
        "answer": "aws cloudformation detect-stack-drift",
        "explanation": "Detect-stack-drift käynnistää ajautumisen havaitsemisen. Tulokset tarkistetaan komennolla description-stack-drift-detection-status."
      },
      {
        "question": "Kuinka vianetsintä "Moduulia ei voi tuoda" Lambdassa?",
        "answers": [
          { "answer": "Tarkista, että käyttöönottopaketti sisältää riippuvuudet" },
          { "answer": "Lisää funktiomuistia" },
          { "answer": "Muokkaa suoritusaikaista versiota" },
          { "answer": "Ota VPC-määritys käyttöön" }
        ],
        "answer": "Varmista, että käyttöönottopaketti sisältää riippuvuuksia",
        "explanation": "Tämä virhe osoittaa puuttuvista Python/Node.js-moduuleista. Testaa käyttöönottopaketit aina lambda-localilla tai SAM CLI:llä ennen käyttöönottoa."
      },
      {
        "question": "Mikä komento mahdollistaa S3-sämpäriversion?",
        "answers": [
          {
            "answer": "aws s3api put-bucket-versioning --bucket my-bucket --versioning-configuration Status=Enabled"
          },
          { "answer": "aws s3 versioning enable my-bucket" },
          { "answer": "aws s3 modify-bucket --versioning true" },
          { "answer": "aws bucket-version enable s3://my-bucket" }
        ],
        "answer": "aws s3api put-bucket-versioning --bucket my-bucket --versioning-configuration Status=Enabled",
        "explanation": "Versiointia hallitaan s3api-alikomentojen kautta. Muut vaihtoehdot käyttävät väärää komentosyntaksia."
      },
      {
        "question": "Kuinka 'TaskMemoryExhausted' -virheenkorjaus ECS:ssä?",
        "answers": [
          {
            "answer": "Kasvata tehtävämuistin rajoja ja tarkista muistivuotoja"
          },
          { "answer": "Lisää CPU-yksiköitä" },
          { "answer": "Muokkaa verkkotilaa" },
          { "answer": "Ota Fargate Spot käyttöön" }
        ],
        "answer": "Kasvata tehtävämuistin rajoja ja tarkista muistivuotojen varalta",
        "explanation": "Muistin rajat on asetettu tehtävämäärityksiin. Käytä CloudWatch Container Insightsia muistin käyttötapojen seuraamiseen."
      },
      {
        "question": "Mikä komento määrittää CI/CD-liukuhihnan Elastic Beanstalkille?",
        "answers": [
          { "answer": "eb pipeline create" },
          { "answer": "aws codepipeline create-beanstalk" },
          { "answer": "aws deploy create-application" },
          { "answer": "eb init --pipeline" }
        ],
        "answer": "eb-putkien luominen",
        "explanation": "Elastic Beanstalk CLI (eb) sisältää putkikohtaisia ​​komentoja. Muut vaihtoehdot yhdistävät palveluja väärin."
      },
      {
        "question": "Kuinka ratkaistaan ​​"Suojausryhmän tunnusta ei ole olemassa" -virhe?",
        "answers": [
          { "answer": "Tarkista, että suojausryhmä on olemassa nykyisellä alueella" },
          { "answer": "Luo uusi IAM-rooli" },
          { "answer": "Muokkaa verkon ACL-luetteloita" },
          { "answer": "Ota VPC-kulkulokit käyttöön" }
        ],
        "answer": "Varmista, että suojausryhmä on olemassa nykyisellä alueella",
        "explanation": "Suojausryhmät ovat aluekohtaisia. Alueiden väliset viittaukset vaativat erillisen SG:n luomisen kohdealueella."
      },
      {
        "question": "Mikä komento kiertää RDS-tietokannan tunnistetietoja?",
        "answers": [
          {
            "answer": "aws rds modify-db-instance --master-user-password new-password"
          },
          { "answer": "aws secretsmanager rotate-secret --secret-id db-creds" },
          { "answer": "aws iam update-login-profile" },
          { "answer": "aws rotate-credentials rds" }
        ],
        "answer": "aws rds modify-db-instance --master-user-password new-password",
        "explanation": "Käytä RDS-hallituille tunnistetiedoille modify-db-instance. Secrets Manager on parempi ulkoiseen valtuustietojen hallintaan."
      },
      {
        "question": "Kuinka 'Isäntäavaimen vahvistus epäonnistui' vianmääritys CodeDeployissa?",
        "answers": [
          { "answer": "Vahvista SSH-avain käyttöönottoryhmän määrityksissä" },
          { "answer": "Lisää käyttöönoton aikakatkaisua" },
          { "answer": "Muokkaa automaattisen skaalauksen ryhmää" },
          { "answer": "Ota CloudWatch-agentti käyttöön" }
        ],
        "answer": "Vahvista SSH-avain käyttöönottoryhmän kokoonpanossa",
        "explanation": "Tämä virhe osoittaa, että CodeDeploy- ja kohde-esiintymien välinen SSH-avain ei täsmää. Luo tai vahvista avainparit."
      },
      {
        "question": "Mikä komento tarkistaa EBS-taltion salauksen tilan?",
        "answers": [
          { "answer": "aws ec2 description-volumes --volume-ids vol-12345" },
          { "answer": "aws ebs check-encryption vol-12345" },
          { "answer": "aws encrypt status --volume vol-12345" },
          { "answer": "aws-tilavuustiedot vol-12345" }
        ],
        "answer": "aws ec2 description-volumes --volume-ids vol-12345",
        "explanation": "Salauksen tila näkyy taltion tiedoissa. Muut vaihtoehdot käyttävät olemattomia komentoja."
      },
      {
        "question": "Kuinka korjataan 'Suoritusroolia ei ole valtuutettu kutsumaan CreateNetworkInterfacea'",
        "answers": [
          { "answer": "Lisää AWSLambdaVPCAccessExecutionRole-käytäntö rooliin" },
          { "answer": "Lisää lambda-muistia" },
          { "answer": "Muokkaa VPC-reittitaulukoita" },
          { "answer": "Ota julkinen IP-osoitus käyttöön" }
        ],
        "answer": "Lisää AWSLambdaVPCAccessExecutionRole-käytäntö rooliin",
        "explanation": "VPC:n lambdatoiminnot vaativat erityisiä käyttöoikeuksia ENI:iden hallintaan. Tämä hallittu käytäntö antaa tarvittavat käyttöoikeudet."
      },
      {
        "question": "Mikä komento testaa S3-säihön käyttöoikeudet?",
        "answers": [
          { "answer": "aws s3 ls s3://bucket-name" },
          { "answer": "aws s3 test-access bucket-name" },
          { "answer": "aws check-s3-permissions bucket-name" },
          { "answer": "aws s3 verify bucket-name" }
        ],
        "answer": "aws s3 ls s3://bucket-name",
        "explanation": "Objektien luettelointi on yksinkertaisin pääsytesti. Vaatii s3:ListBucket-oikeuden. Muita komentoja ei ole olemassa."
      },
      {
        "question": "Kuinka ratkaista 'DockerTimeoutError' ECS-käyttöönotuksissa?",
        "answers": [
          { "answer": "Lisää ECS-tehtävän suorittamisen aikakatkaisua" },
          { "answer": "Pienennä säilön kuvan kokoa" },
          { "answer": "Muokkaa suojausryhmiä" },
          { "answer": "Ota käyttöön Fargate-kapasiteetin tarjoaja" }
        ],
        "answer": "Lisää ECS-tehtävän suorittamisen aikakatkaisua",
        "explanation": "Suuret kuvat tai hitaat verkot voivat vaatia pidempiä vetoaikoja. Säädä ECS-palvelun käyttöönottomääritysten aikakatkaisuja."
      },
      {
        "question": "Mikä komento luettelee CloudFront-jakelut?",
        "answers": [
          { "answer": "aws cloudfront list-distributions" },
          { "answer": "aws cf list" },
          { "answer": "aws-jakeluluettelo" },
          { "answer": "aws list-cloudfront" }
        ],
        "answer": "aws cloudfront list-distributions",
        "explanation": "CloudFront-toiminnot käyttävät pilvialueen nimiavaruutta. Muut vaihtoehdot käyttävät vääriä palvelulyhenteitä."
      },
      {
        "question": "Kuinka 'NoSuchBucket' -vianmääritys CloudFormationissa?",
        "answers": [
          { "answer": "Varmista, että S3-säilö on mallin alueella" },
          { "answer": "Lisää mallin aikakatkaisua" },
          { "answer": "Muokkaa IAM-rooleja" },
          { "answer": "Ota käyttöön ryhmäversiointi" }
        ],
        "answer": "Varmista, että S3-säilö on olemassa mallin alueella",
        "explanation": "CloudFormation-mallien on viitattava olemassa oleviin ryhmiin samalla alueella. Alueiden välinen käyttö vaatii erityisoikeuksia."
      },
      {
        "question": "Mikä komento pakottaa CloudFront-välimuistin mitätöinnin?",
        "answers": [
          {
            "answer": "aws cloudfront create-invalidation --distribution-id ID --paths '/*'"
          },
          { "answer": "aws cf invalidate-cache ID" },
          { "answer": "aws s3 sync --cf-invalidate" },
          { "answer": "aws invalidate-cloudfront ID" }
        ],
        "answer": "aws cloudfront create-invalidation --distribution-id ID --paths '/*'",
        "explanation": "Oikea välimuistin mitätöinti edellyttää uuden mitätöintipyynnön luomista. Muut vaihtoehdot käyttävät väärää komentosyntaksia."
      },
      {
        "question": "Kuinka korjata 'Ei voida ottaa roolia' -virheitä?",
        "answers": [
          { "answer": "Tarkista luottamussuhde IAM-roolissa" },
          { "answer": "Pidennä rooliistunnon kestoa" },
          { "answer": "Muokkaa suojausryhmiä" },
          { "answer": "Ota CloudTrail-loki käyttöön" }
        ],
        "answer": "Varmista luottamussuhde IAM-roolissa",
        "explanation": "Olettavan entiteetin (käyttäjä/rooli) on oltava luottamuskäytännössä. Käytä 'aws sts ota-role' rooliolettamien testaamiseen."
      },
      {
        "question": "Mikä komento tarkistaa Route 53 DNS:n etenemisen?",
        "answers": [
          { "answer": "dig +trace example.com" },
          { "answer": "aws route53 get-dns-propagation" },
          { "answer": "nslookup -type=soa example.com" },
          { "answer": "aws dns verify example.com" }
        ],
        "answer": "dig +trace example.com",
        "explanation": "Dig-komento tarjoaa yksityiskohtaisen DNS-selvityksen jäljityksen. AWS CLI:ssä ei ole DNS-etenemisen tarkistuskomentoja."
      },
      {
        "question": "Kuinka 'AccessDenied' -vianmääritys S3:een ladattaessa?",
        "answers": [
          { "answer": "Tarkista ryhmäkäytäntö ja IAM-oikeudet" },
          { "answer": "Ota siirtokiihdytys käyttöön" },
          { "answer": "Muokkaa CORS-määrityksiä" },
          { "answer": "Kasvata tallennustilaluokkaa" }
        ],
        "answer": "Tarkista ryhmäkäytäntö ja IAM-oikeudet",
        "explanation": "AccessDenied-virheet osoittavat lupaongelmia. Tarkista s3:PutObject-oikeudet sekä ryhmäkäytännöissä että IAM-rooleissa."
      },
      {
        "question": "Mikä komento päivittää olemassa olevan lambda-toimintokoodin?",
        "answers": [
          {
            "answer": "aws lambda update-function-code --function-name my-function --zip-file fileb://deploy.zip"
          },
          {
            "answer": "aws lambda deploy --function my-function --code deploy.zip"
          },
          { "answer": "aws function update-code my-function deploy.zip" },
          { "answer": "aws update-lambda --code-file deploy.zip" }
        ],
        "answer": "aws lambda update-function-code --function-name my-function --zip-file fileb://deploy.zip",
        "explanation": "Koodipäivityksiin käytetään update-function-code-alikomentoa. Muut vaihtoehdot käyttävät väärää syntaksia."
      },
      {
        "question": "Kuinka debugata 'ELB-HealthChecker' -virheet EC2:ssa?",
        "answers": [
          { "answer": "Tarkista suojausryhmät sallivat kuntotarkastusportit" },
          { "answer": "Kasvata esiintymän kokoa" },
          { "answer": "Muokkaa automaattisen skaalauksen ryhmää" },
          { "answer": "Ota käyttöön yksityiskohtainen seuranta" }
        ],
        "answer": "Varmista, että suojausryhmät sallivat kuntotarkastusportit",
        "explanation": "Kuntotarkistukset epäonnistuvat, kun suojausryhmät estävät pääsyn ilmentymän kuntotarkistusporttiin (oletus: 80/tcp)."
      },
      {
        "question": "Mikä komento luo ECR-arkiston?",
        "answers": [
          { "answer": "aws ecr create-repository --repository-name my-repo" },
          { "answer": "aws docker create-repo my-repo" },
          { "answer": "aws ecs new-repository my-repo" },
          { "answer": "aws-konttirekisteri luo my-repo" }
        ],
        "answer": "aws ecr create-repository --repository-name my-repo",
        "explanation": "ECR-varastoja hallitaan ecr-nimiavaruuden kautta. Muut vaihtoehdot käyttävät vääriä palvelunimiä."
      },
      {
        "question": "Kuinka ratkaista 'InvalidParameterException' CloudFormationissa?",
        "answers": [
          { "answer": "Vahvista malli cfn-lintillä" },
          { "answer": "Lisää pinon aikakatkaisua" },
          { "answer": "Muokkaa IAM-rooleja" },
          { "answer": "Ota pinon lopetussuoja käyttöön" }
        ],
        "answer": "Vahvista malli cfn-lintillä",
        "explanation": "Tämä virhe osoittaa mallin syntaksiongelmia. Käytä AWS CLI:n validate-template-komentoa tai cfn-lint-komentoa yksityiskohtaiseen vahvistukseen."
      },
      {
        "question": "Mikä komento luettelee kaikki käytettävissä olevat AWS-alueet?",
        "answers": [
          { "answer": "aws ec2 description-regions" },
          { "answer": "aws list-regions" },
          { "answer": "aws configure get-regions" },
          { "answer": "aws global description-regions" }
        ],
        "answer": "aws ec2 description-regions",
        "explanation": "Aluetietoja hallitaan EC2-palvelun kautta. Muut vaihtoehdot käyttävät olemattomia komentoja."
      },
      {
        "question": "Kuinka 'Yhteyden aikakatkaisu' -vianmääritys RDS:ään?",
        "answers": [
          { "answer": "Tarkista suojausryhmät ja NACL:t" },
          { "answer": "Kasvata DB-esiintymän luokkaa" },
          { "answer": "Muokkaa parametriryhmiä" },
          { "answer": "Ota käyttöön Multi-AZ-käyttöönotto" }
        ],
        "answer": "Tarkista suojausryhmät ja NACL:t",
        "explanation": "Aikakatkaisuvirheet osoittavat yleensä verkkoyhteysongelmia. Varmista, että suojausryhmät sallivat liikenteen oikeaan porttiin (oletus: 3306 MySQL:lle)."
      },
      {
        "question": "Mikä komento sallii S3:n staattisen verkkosivuston hosting?",
        "answers": [
          {
            "answer": "aws s3 -sivusto s3://my-bucket --index-document index.html"
          },
          {
            "answer": "aws s3api put-bucket-website --bucket my-bucket --website-configuration file://config.json"
          },
          { "answer": "aws s3 enable-static-hosting my-bucket" },
          { "answer": "aws website create --bucket my-bucket" }
        ],
        "answer": "aws s3api put-bucket-website --bucket my-bucket --website-configuration file://config.json",
        "explanation": "Verkkosivuston määritys vaatii JSON-määrityksen. s3api-komento on tarkin, vaikka muitakin menetelmiä on olemassa konsolin kautta."
      },
      {
        "question": "Kuinka 'Luettu aikakatkaisu' -virheenkorjaus AWS CLI:ssä?",
        "answers": [
          { "answer": "Lisää aikakatkaisua --cli-read-timeout-parametrilla" },
          { "answer": "Päivitä AWS CLI -versio" },
          { "answer": "Muokkaa IAM-oikeuksia" },
          { "answer": "Ota virheenkorjausloki käyttöön" }
        ],
        "answer": "Lisää aikakatkaisua --cli-read-timeout -parametrilla",
        "explanation": "Pitkäaikaisissa toimissa suurenna aikakatkaisuarvoja. Viankorjausloki (--debug) auttaa diagnosoimaan, mutta ei korjaa aikakatkaisuongelmia."
      },
      {
        "question": "Mikä komento tarkistaa CloudTrail-lokin eheyden?",
        "answers": [
          { "answer": "aws cloudtrail validate-logs --trail-name my-trail" },
          { "answer": "Käytä validite-logfile-integrity.sh-komentosarjaa" },
          { "answer": "aws logs verify my-trail-logs" },
          { "answer": "CloudTrail-vahvistus on automaattinen" }
        ],
        "answer": "Käytä validate-logfile-integrity.sh-komentosarjaa",
        "explanation": "AWS tarjoaa OpenSSL:n avulla vahvistuskomentosarjan CloudTrail-lokitiedoston eheyden tarkistamiseksi tiivistelmätiedostojen avulla."
      },
      {
        "question": "Kuinka ratkaista 'ThrottlingException' DynamoDB:ssä?",
        "answers": [
          { "answer": "Ota eksponentiaalinen peruutus sovelluskoodiin" },
          { "answer": "Lisää kapasiteettia" },
          { "answer": "Muokkaa osioavaimia" },
          { "answer": "Ota automaattinen skaalaus käyttöön" }
        ],
        "answer": "Ota eksponentiaalinen peruutus sovelluskoodiin",
        "explanation": "Välitön korjaus on uudelleenyritysten lisääminen. Pitkäaikainen ratkaisu saattaa edellyttää kapasiteetin säätämistä tai tiedonjakelun parantamista."
      },
      {
        "question": "Mikä komento valvoo EC2-ilmentymien tilantarkistuksia?",
        "answers": [
          { "answer": "aws ec2 description-instance-status" },
          { "answer": "aws cloudwatch get-instance-health" },
          { "answer": "aws health instance-checks" },
          { "answer": "aws monitor ec2-status" }
        ],
        "answer": "aws ec2 description-instance-status",
        "explanation": "Tämä komento näyttää järjestelmän/saavutettavuuden tilan. CloudWatch-hälytykset voidaan määrittää automaattista valvontaa varten."
      },
      {
        "question": "Kuinka 'InvalidClientTokenId':n vianmääritys CLI:ssä?",
        "answers": [
          { "answer": "Vahvista AWS_ACCESS_KEY_ID ja AWS_SECRET_ACCESS_KEY" },
          { "answer": "Lisää IAM-oikeuksia" },
          { "answer": "Muokkaa alueen määritystä" },
          { "answer": "Ota MFA käyttöön" }
        ],
        "answer": "Vahvista AWS_ACCESS_KEY_ID ja AWS_SECRET_ACCESS_KEY",
        "explanation": "Tämä virhe tarkoittaa virheellisiä tai vanhentuneita pääsyavaimia. Kierrä aina kirjautumistietoja säännöllisesti ja käytä tilapäisiä tunnistetietoja, kun mahdollista."
      }
    ]
  },
  {
    "name": "Geneettisen testauksen kehittäjä",
    "questions": [
      {
        "question": "Mikä on SNP?",
        "answers": [
          { "answer": "Proteiinia koodaava geeni" },
          { "answer": "Yksi nukleotidipolymorfismi" },
          { "answer": "Kromosomipoisto" },
          { "answer": "Eräänlainen RNA-molekyyli" }
        ],
        "answer": "Yksi nukleotidipolymorfismi",
        "explanation": "SNP:t ovat yksipohjaisia ​​muunnelmia, joita käytetään suku- ja sairausriskianalyysissä. Kehittäjät käsittelevät SNP-tietoja VCF-tiedostoissa."
      },
      {
        "question": "Mitä "CLIA-sertifioitu lab" tarkoittaa?",
        "answers": [
          {
            "answer": "Clinical Laboratory Improvement -muutosten mukainen laboratorio"
          },
          { "answer": "Syövän tutkimuslaboratorio" },
          { "answer": "CRISPR:ää käyttävä laboratorio" },
          { "answer": "Eläinlääketieteellisen genetiikan laboratorio" }
        ],
        "answer": "Clinical Laboratory Improvement -muutosten mukainen laboratorio",
        "explanation": "CLIA varmistaa testauksen tarkkuuden. Alustaen on integroitava CLIA-laboratorioiden kanssa kelvollisten kliinisten raporttien saamiseksi."
      },
      {
        "question": "Mikä tiedostomuoto tallentaa raakoja geneettisiä muunnelmia?",
        "answers": [
          { "answer": "VCF" },
          { "answer": "CSV" },
          { "answer": "JSON" },
          { "answer": "BAM" }
        ],
        "answer": "VCF",
        "explanation": "VCF (Variant Call Format) on vakiona SNP:ille/indeleille. Kehittäjät jäsentävät VCF-tiedostoja testituloksia varten."
      },
      {
        "question": "Mikä on "epävarman merkityksen muunnos" (VUS)?",
        "answers": [
          { "answer": "Mutaatio, jolla on epäselvä kliininen vaikutus" },
          { "answer": "Haitaton mutaatio" },
          { "answer": "Syöpää aiheuttava mutaatio" },
          { "answer": "RNA-spesifinen mutaatio" }
        ],
        "answer": "Mutaatio, jolla on epäselvä kliininen vaikutus",
        "explanation": "VUS-tulokset edellyttävät huolellista käyttöliittymämerkintää ja seurantasuosituksia."
      },
      {
        "question": "Mitä ACMG luokittelee?",
        "answers": [
          { "answer": "Geneettisten muunnelmien patogeenisyys" },
          { "answer": "Eettiset ohjeet" },
          { "answer": "Laboratoriolaitteiden standardit" },
          { "answer": "Datan salausprotokollat" }
        ],
        "answer": "Geneettisten varianttien patogeenisyys",
        "explanation": "ACMG-ohjeet (esim. hyvänlaatuiset/todennäköiset patogeeniset) on automatisoitu raportointiputkissa."
      },
      {
        "question": "Mikä on NGS?",
        "answers": [
          { "answer": "Seuraavan sukupolven järjestys" },
          { "answer": "Kansallinen geneettinen standardi" },
          { "answer": "Ei-geneettinen seulonta" },
          { "answer": "Uusi genomin sekvensointi" }
        ],
        "answer": "Seuraavan sukupolven sekvensointi",
        "explanation": "NGS mahdollistaa korkean suorituskyvyn sekvensoinnin. Kehittäjät optimoivat liukuhihnat FASTQ/BAM-tiedostoille."
      },
      {
        "question": "Mikä on BAM-tiedoston tarkoitus?",
        "answers": [
          { "answer": "Tallennetaan tasoitettuja järjestyslukuja" },
          { "answer": "Potilaiden demografisten tietojen tallentaminen" },
          { "answer": "Geenitietojen salaus" },
          { "answer": "Kromosomien visualisointi" }
        ],
        "answer": "Tallennetaan tasattuja järjestyslukuja",
        "explanation": "BAM-tiedostojen käsittelyyn tarvitaan työkaluja, kuten SAMtools."
      },
      {
        "question": "Mitä API-standardia käytetään terveydenhuollon tiedonvaihtoon?",
        "answers": [
          { "answer": "MIES" },
          { "answer": "GraphQL" },
          { "answer": "SOAP" },
          { "answer": "LEPÄ" }
        ],
        "answer": "MIES",
        "explanation": "FHIR integroi geneettiset tiedot EHR:iin (esim. Epic, Cerner)."
      },
      {
        "question": "Mitä on "herkkyys" geneettisessä testauksessa?",
        "answers": [
          { "answer": "Kyky havaita todellisia positiivisia" },
          { "answer": "Väärien positiivisten tulosten välttäminen" },
          { "answer": "Tietojenkäsittelynopeus" },
          { "answer": "Kokeen hinta" }
        ],
        "answer": "Kyky havaita todellisia positiivisia",
        "explanation": "Suuri herkkyys vähentää vääriä negatiivisia. Ilmoita nämä tiedot laboratorioissa."
      },
      {
        "question": "Mitä 'vaiheistus' tarkoittaa genomiikassa?",
        "answers": [
          { "answer": "Alleelien vanhempien alkuperän määrittäminen" },
          { "answer": "Heikkolaatuisten muunnelmien suodattaminen" },
          { "answer": "Potilastietojen salaus" },
          { "answer": "Geeniekspressioanalyysi" }
        ],
        "answer": "Alleelien vanhempien alkuperän määrittäminen",
        "explanation": "Vaiheittaiset tiedot parantavat esi- ja perintöraportteja."
      },
      {
        "question": "Mikä on 'PGx-raportti'?",
        "answers": [
          { "answer": "Farmakogenominen lääkevasteraportti" },
          { "answer": "Esivanhempien koostumusraportti" },
          { "answer": "Syövän riskiraportti" },
          { "answer": "Operaattorin tarkistusraportti" }
        ],
        "answer": "Farmakogenominen lääkevasteraportti",
        "explanation": "PGx-raportit ohjaavat lääkityksen annostusta kliinikoille."
      },
      {
        "question": "Mikä salaus vaaditaan geneettisille tiedoille?",
        "answers": [
          { "answer": "AES-256" },
          { "answer": "SHA-1" },
          { "answer": "MD5" },
          { "answer": "Ei salausta" }
        ],
        "answer": "AES-256",
        "explanation": "Geneettiset tiedot vaativat AES-256-salauksen lepotilassa/siirrossa."
      },
      {
        "question": "Mitä GINA säätelee?",
        "answers": [
          { "answer": "Geneettinen syrjintä" },
          { "answer": "Lab-tarkkuus" },
          { "answer": "Tietomuodot" },
          { "answer": "Lääkehyväksynnät" }
        ],
        "answer": "Geneettinen syrjintä",
        "explanation": "GINA kieltää geneettisten tietojen väärinkäytön työsuhteessa/vakuutuksessa."
      },
      {
        "question": "Mitä on "tietoinen suostumus" geneettisessä testauksessa?",
        "answers": [
          { "answer": "Potilaslupa riskien ymmärtämisen jälkeen" },
          { "answer": "Lab-laskutussopimus" },
          { "answer": "Tietojen analysointiprotokolla" },
          { "answer": "Ohjelmistolisenssi" }
        ],
        "answer": "Potilaslupa riskien ymmärtämisen jälkeen",
        "explanation": "Alustojen on dokumentoitava digitaalinen suostumus ja sallittava peruutukset."
      },
      {
        "question": "Mikä on "haplotyyppi"?",
        "answers": [
          { "answer": "Yhdessä perittyjen DNA-muunnelmien joukko" },
          { "answer": "RNA:n tyyppi" },
          { "answer": "Proteiinin rakenne" },
          { "answer": "Laboratoriolaite" }
        ],
        "answer": "Joukko DNA-variantteja periytyy yhdessä",
        "explanation": "Haplotyyppejä käytetään esi-isien ja tautien kytkentäanalyysissä."
      },
      {
        "question": "Mikä on FASTQ-tiedosto?",
        "answers": [
          { "answer": "Raakasekvenssilukemat laatupisteillä" },
          { "answer": "Tasatut sekvenssitiedot" },
          { "answer": "Variantin puhelutiedot" },
          { "answer": "Salatut potilastiedot" }
        ],
        "answer": "Raakasekvenssilukemat laatupisteillä",
        "explanation": "FASTQ-tiedostot käsitellään NGS-putkissa ennen kohdistamista."
      },
      {
        "question": "Mitä "lukusyvyys" tarkoittaa?",
        "answers": [
          { "answer": "Mitä kertoja kanta on sekvensoitu" },
          { "answer": "DNA-fragmenttien pituus" },
          { "answer": "Tietojen tallennuskoko" },
          { "answer": "Virheiden määrä järjestyksessä" }
        ],
        "answer": "Mitä kertoja kanta on sekvensoitu",
        "explanation": "Suurempi lukusyvyys parantaa muunnelman tunnistuksen tarkkuutta."
      },
      {
        "question": "Mikä on 'varianttimerkintä'?",
        "answers": [
          { "answer": "Kliinisten/tietokantatietojen lisääminen variantteihin" },
          { "answer": "Geenitietojen salaus" },
          { "answer": "Kromosomien visualisointi" },
          { "answer": "Heikkolaatuisten SNP:iden suodattaminen" }
        ],
        "answer": "Kliinisten/tietokantatietojen lisääminen variantteihin",
        "explanation": "Työkalut, kuten ANNOVAR, automatisoivat raporttien merkinnät."
      },
      {
        "question": "Mihin BED-tiedostoa käytetään?",
        "answers": [
          { "answer": "Mielenkiintoisten genomialueiden määrittely" },
          { "answer": "Potilaiden demografisten tietojen tallentaminen" },
          { "answer": "Salataan tietoja" },
          { "answer": "Sekvenssien tasaaminen" }
        ],
        "answer": "Mielenkiintoisten genomialueiden määrittely",
        "explanation": "BED-tiedostot kohdistuvat sekvensoinnissa eksomiin tai tiettyihin geeneihin."
      },
      {
        "question": "Mikä on "alleelitaajuus" populaatiossa?",
        "answers": [
          { "answer": "Kuinka yleinen alleeli on populaatiossa" },
          { "answer": "Mutaatioiden esiintymisen nopeus" },
          { "answer": "Tiedonsiirtonopeus" },
          { "answer": "Virheiden määrä järjestyksessä" }
        ],
        "answer": "Kuinka yleinen alleeli on populaatiossa",
        "explanation": "Harvinaiset alleelit voivat viitata patogeenisiin variantteihin."
      },
      {
        "question": "Mitä "QC" tarkoittaa NGS:ssä?",
        "answers": [
          { "answer": "Laadunvalvonta" },
          { "answer": "Kvantitatiivinen vertailu" },
          { "answer": "Pikaklooni" },
          { "answer": "Kyselykomento" }
        ],
        "answer": "Laadunvalvonta",
        "explanation": "QC-vaiheet varmistavat, että sekvensointitiedot täyttävät tarkkuuskynnykset."
      },
      {
        "question": "Mihin CRISPR:ää käytetään?",
        "answers": [
          { "answer": "Geenien muokkaus" },
          { "answer": "Tiedon salaus" },
          { "answer": "Varianttimerkintä" },
          { "answer": "Lab-sertifiointi" }
        ],
        "answer": "Geenien muokkaus",
        "explanation": "CRISPR mahdollistaa tarkat DNA-muunnokset. Ei käytetä suoraan testausalustoissa."
      },
      {
        "question": "Mikä on "putkisto" bioinformatiikassa?",
        "answers": [
          { "answer": "Tietojen käsittelyvaiheiden sarja" },
          { "answer": "Fyysinen laboratoriolaite" },
          { "answer": "DNA-tyyppi" },
          { "answer": "Yhteensopivuusstandardi" }
        ],
        "answer": "Tietojenkäsittelyvaiheiden sarja",
        "explanation": "Pielilinjat käsittelevät raakadataa (FASTQ) raporteiksi (VCF/PDF)."
      },
      {
        "question": "Mihin 'plink'ä käytetään?",
        "answers": [
          { "answer": "Genominlaajuiset assosiaatiotutkimukset (GWAS)" },
          { "answer": "Salataan tietoja" },
          { "answer": "Varianttimerkintä" },
          { "answer": "Lab-laskutus" }
        ],
        "answer": "Genominlaajuiset assosiaatiotutkimukset (GWAS)",
        "explanation": "Plink analysoi geneettisiä assosiaatioita ominaisuuksien/sairauksien kanssa."
      },
      {
        "question": "Mikä on 'viitegenomi GRCh38'?",
        "answers": [
          { "answer": "Standardoitu ihmisen genomikokoonpano" },
          { "answer": "RNA:n tyyppi" },
          { "answer": "Laborprotokolla" },
          { "answer": "Tietojen salausmenetelmä" }
        ],
        "answer": "Standardoitu ihmisen genomikokoonpano",
        "explanation": "Sekvensointilukemat on kohdistettu GRCh38:aan johdonmukaisuuden vuoksi."
      },
      {
        "question": "Mikä on 'Exome Sequencing'?",
        "answers": [
          { "answer": "Proteiinia koodaavien alueiden sekvensointi" },
          { "answer": "Koko genomin sekvensointi" },
          { "answer": "Sekvensoi mitokondriaalinen DNA" },
          { "answer": "RNA:n sekvensointi" }
        ],
        "answer": "Proteiinia koodaavien alueiden sekvensointi",
        "explanation": "Exome-sekvensointi on kustannustehokasta kliinisessä testauksessa."
      },
      {
        "question": "Mikä on 'Sanger Sequencing'?",
        "answers": [
          { "answer": "Menetelmä NGS-muunnelmien vahvistamiseen" },
          { "answer": "Suorituskykyinen sekvensointitekniikka" },
          { "answer": "Tietojen tallennusmuoto" },
          { "answer": "Laboratorion todistus" }
        ],
        "answer": "Menetelmä NGS-varianttien validointiin",
        "explanation": "Sanger vahvistaa kriittiset versiot suuren tarkkuutensa vuoksi."
      },
      {
        "question": "Mitä on 'peitto' sekvensoinnissa?",
        "answers": [
          { "answer": "Keskimääräinen lukujen lukumäärä, joka kattaa perustan" },
          { "answer": "Tietojen salauksen leveys" },
          { "answer": "Lab-vakuutus" },
          { "answer": "Potilaan suostumuslomake" }
        ],
        "answer": "Keskimääräinen lukumäärä, joka kattaa perustan",
        "explanation": "30-kertainen kattavuus on vakiona kliinisen koko genomin sekvensoinnissa."
      },
      {
        "question": "Mikä on 'CNV'?",
        "answers": [
          { "answer": "Kopioi numeron muunnelma" },
          { "answer": "Common Nucleotid Variant" },
          { "answer": "Clinical NGS Validation" },
          { "answer": "Suostunut ei-variantti" }
        ],
        "answer": "Kopioi numeron vaihtelu",
        "explanation": "CNV:t ovat suuria deleetioita/duplikaatioita, jotka on havaittu syöpätesteissä."
      },
      {
        "question": "Mihin 'LOINC'ia käytetään?",
        "answers": [
          { "answer": "Labor testikoodien standardointi" },
          { "answer": "Salataan tietoja" },
          { "answer": "Varianttien merkitseminen" },
          { "answer": "Sekvensointilukemien tallentaminen" }
        ],
        "answer": "Standardisoidaan laboratoriotestikoodit",
        "explanation": "LOINC-koodit integroivat geneettiset testit EHR-järjestelmiin."
      },
      {
        "question": "Mitä geneettisen riskin raportin tulee sisältää?",
        "answers": [
          { "answer": "Riskipisteet, luottamusvälit ja suositukset" },
          { "answer": "Vain SNP-raakadata" },
          { "answer": "Laboratoriolaitteiden tiedot" },
          { "answer": "Potilaan sosiaalisen median historia" }
        ],
        "answer": "Riskipisteet, luottamusvälit ja suositukset",
        "explanation": "Käytä visualisointeja (esim. riskimittareita) potilaan ymmärtämiseen."
      },
      {
        "question": "Mikä on "dynaaminen raportti"?",
        "answers": [
          { "answer": "Raportti päivitetään uusilla tieteellisillä tiedoilla" },
          { "answer": "Painettu PDF" },
          { "answer": "Lab-laskutuslasku" },
          { "answer": "Suostumuslomake" }
        ],
        "answer": "Raportti, joka päivitetään uusilla tieteellisillä tiedoilla",
        "explanation": "Dynaamiset raportit lisäävät arvoa tutkimuksen kehittyessä."
      },
      {
        "question": "Mitä on 'toissijaiset löydökset' geneettisessä testauksessa?",
        "answers": [
          { "answer": "Odottamattomia lääketieteellisiä tuloksia" },
          { "answer": "Lab-laskutusvirheet" },
          { "answer": "Datan salausavaimet" },
          { "answer": "Suostumuslomakkeen kirjoitusvirheet" }
        ],
        "answer": "Odottamattomia lääketieteellisiä tuloksia",
        "explanation": "Alustojen on sallittava käyttäjien ottaa käyttöön/poistaa toissijaiset havainnot."
      },
      {
        "question": "Mikä kaavio on paras esi-isien koostumuksen näyttämiseen?",
        "answers": [
          { "answer": "Ympyräkaavio" },
          { "answer": "pylväsdiagrammi" },
          { "answer": "Scatter plot" },
          { "answer": "Lämpökartta" }
        ],
        "answer": "Ympyräkaavio",
        "explanation": "Ympyräkaaviot yksinkertaistavat alueellisia esi-isien prosenttiosuuksia."
      },
      {
        "question": "Mihin 'PDF-raporttivesileimaa' käytetään?",
        "answers": [
          { "answer": "Luvattoman jakamisen estäminen" },
          { "answer": "Lab-logojen lisääminen" },
          { "answer": "Salataan tietoja" },
          { "answer": "Versioiden merkitseminen" }
        ],
        "answer": "Luvattoman jakamisen estäminen",
        "explanation": "Vesimerkit seuraavat vuotaneita raportteja, mutta eivät korvaa salausta."
      },
      {
        "question": "Mikä on 'BRCA1'?",
        "answers": [
          { "answer": "Rintasyöpäriskiin liittyvä geeni" },
          { "answer": "Laboratoriolaite" },
          { "answer": "Tietomuoto" },
          { "answer": "Yrityslaki" }
        ],
        "answer": "Rintasyöpäriskiin liittyvä geeni",
        "explanation": "BRCA1-mutaatioita on raportoitu perinnöllisissä syöpätesteissä."
      },
      {
        "question": "Mitä "kantajaseulonta" testaa?",
        "answers": [
          { "answer": "Resessiivisen sairauden riski jälkeläisillä" },
          { "answer": "Syövän riski" },
          { "answer": "Huumeiden vastaukset" },
          { "answer": "Esivanhemmat" }
        ],
        "answer": "Resessiivisen sairauden riski jälkeläisillä",
        "explanation": "Operaattoriraportit ohjaavat perhesuunnittelupäätöksiä."
      },
      {
        "question": "Mikä on 'FHIR Genomics Resource'?",
        "answers": [
          { "answer": "Standardoitu tapa jakaa geneettisiä tietoja" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Sekvensointimenetelmä" },
          { "answer": "Suostumuslomake" }
        ],
        "answer": "Standardoitu tapa jakaa geneettisiä tietoja",
        "explanation": "FHIR Genomics integroi tiedot kliinikoiden EHR-tietoihin."
      },
      {
        "question": "Mikä on "PGx" lyhenne?",
        "answers": [
          { "answer": "Farmakogenomiikka" },
          { "answer": "Patogenomiikka" },
          { "answer": "Polygeeninen riski" },
          { "answer": "Populaatiogenetiikka" }
        ],
        "answer": "Farmakogenomiikka",
        "explanation": "PGx-raportit ennustavat lääkeaineenvaihduntaa (esim. varfariinin annostusta)."
      },
      {
        "question": "Mitä on 'tunnistetiedot'?",
        "answers": [
          { "answer": "Tiedoista on poistettu henkilökohtaiset tunnisteet" },
          { "answer": "Salatut tiedot" },
          { "answer": "Raaka sekvenssitiedot" },
          { "answer": "Annotoidut muunnelmat" }
        ],
        "answer": "Tiedoista on poistettu henkilökohtaiset tunnisteet",
        "explanation": "Tunnistamisen poistaminen vähentää uudelleentunnistusriskiä HIPAA:n puitteissa."
      },
      {
        "question": "Mikä on 'GDPR'?",
        "answers": [
          { "answer": "EU:n tietosuoja-asetus" },
          { "answer": "Laboratorion todistus" },
          { "answer": "Geenitietokanta" },
          { "answer": "Sekvensointitekniikka" }
        ],
        "answer": "EU:n tietosuoja-asetus",
        "explanation": "GDPR vaatii nimenomaisen suostumuksen EU:n käyttäjien tietojen käsittelyyn."
      },
      {
        "question": "Mikä on 'Data Use Agreement' (DUA)?",
        "answers": [
          { "answer": "Datan jakamista koskeva sopimus" },
          { "answer": "Laboratorioraportti" },
          { "answer": "Suostumuslomake" },
          { "answer": "Varianttiluokitus" }
        ],
        "answer": "Tietojen jakamista koskeva sopimus",
        "explanation": "DUA:t varmistavat, että kumppanit käyttävät tietoja vain sovittuihin tarkoituksiin."
      },
      {
        "question": "Mikä on 'ISO 27001'?",
        "answers": [
          { "answer": "Tietoturvallisuuden hallintastandardi" },
          { "answer": "Laboratorion laitestandardi" },
          { "answer": "Genetic Testing Protocol" },
          { "answer": "Varianttien merkintätyökalu" }
        ],
        "answer": "Tietoturvallisuuden hallintastandardi",
        "explanation": "ISO 27001 -sertifiointi vahvistaa luottamusta tietoturvaan."
      },
      {
        "question": "Mikä on "satunnaiset havainnot"?",
        "answers": [
          { "answer": "Odottamattomia, mutta toimivia tuloksia" },
          { "answer": "Lab-laskutusvirheet" },
          { "answer": "Tietojen salausvirheet" },
          { "answer": "Suostumuslomakkeen ohitukset" }
        ],
        "answer": "Odottamattomia, mutta toimivia tuloksia",
        "explanation": "Alustojen on annettava käyttäjien hyväksyä/poistaa niiden vastaanottaminen."
      },
      {
        "question": "Mikä on 'tarkastusloki'?",
        "answers": [
          { "answer": "Seurantatietojen käyttö/muokkaukset" },
          { "answer": "Sekvensoinnin laadunvalvonta" },
          { "answer": "Varianttimerkintä" },
          { "answer": "Raportin luominen" }
        ],
        "answer": "Seurantatietojen käyttö/muokkaukset",
        "explanation": "Tarkastuslokit ovat tärkeitä HIPAA-yhteensopivuuden ja rikkomustutkimusten kannalta."
      },
      {
        "question": "Mikä on "tietojen minimointi"?",
        "answers": [
          { "answer": "Kerätään vain tarpeellisia tietoja" },
          { "answer": "Salataan kaikki tiedot" },
          { "answer": "Vanhojen raporttien poistaminen" },
          { "answer": "Anonymisoidaan tiedot" }
        ],
        "answer": "Kerää vain tarpeellisia tietoja",
        "explanation": "Vähentää GDPR/HIPAA:n mukaisia ​​vastuu- ja säilytyskustannuksia."
      },
      {
        "question": "Mikä on "break-the-glass" -käyttöoikeus?",
        "answers": [
          { "answer": "Rajoitettujen tietojen hätäkäyttö" },
          { "answer": "Datan salauksen purku" },
          { "answer": "Laboratorion laitteiden ohitus" },
          { "answer": "Suostumuslomakkeen ohitus" }
        ],
        "answer": "Hätäpääsy rajoitettuihin tietoihin",
        "explanation": "Vaatii perustelun ja laukaisee tarkastushälytyksiä."
      },
      {
        "question": "Mikä on "tokenization"?",
        "answers": [
          { "answer": "Arkaluonteisten tietojen korvaaminen tunnuksilla" },
          { "answer": "Tiedon salaus" },
          { "answer": "Varianttimerkintä" },
          { "answer": "Tietojen poistaminen" }
        ],
        "answer": "Arkaluonteisten tietojen korvaaminen tunnuksilla",
        "explanation": "Tokenointi suojaa tietoja analysoinnin/jaon aikana."
      }
    ]
  },
  {
    "name": "Geenitestaus (Perusasiat)",
    "questions": [
      {
        "question": "Mitä on geneettinen testaus?",
        "answers": [
          { "answer": "DNA:n analysointi muutosten tai mutaatioiden tunnistamiseksi" },
          { "answer": "Verensokeritasojen testaus" },
          { "answer": "Vitamiinipuutteiden mittaaminen" },
          { "answer": "Suolistossa olevien bakteerien tutkiminen" }
        ],
        "answer": "DNA:n analysointi muutosten tai mutaatioiden tunnistamiseksi",
        "explanation": "Geneettinen testaus tutkii DNA:ta terveyteen, syntyperään tai ominaisuuksiin liittyvien mutaatioiden havaitsemiseksi."
      },
      {
        "question": "Mitä näytettä käytetään yleisesti kotona tehtävissä DNA-testeissä?",
        "answers": [
          { "answer": "Sylki" },
          { "answer": "Veri" },
          { "answer": "Hiukset" },
          { "answer": "Vitsa" }
        ],
        "answer": "Sylki",
        "explanation": "Kotipakkauksissa käytetään usein putkeen kerättyä sylkeä. Verta käytetään kliinisissä olosuhteissa."
      },
      {
        "question": "Mikä on operaattorin testauksen tarkoitus?",
        "answers": [
          { "answer": "Näyttääksesi, onko sinulla resessiivisen taudin geeni" },
          { "answer": "Syövän diagnosoimiseksi" },
          { "answer": "Vitamiinipuutteiden testaamiseen" },
          { "answer": "Sinun määrittämiseksi" }
        ],
        "answer": "Näyttääksesi, onko sinulla resessiivisen taudin geeni",
        "explanation": "Kantajatestaus auttaa pariskuntia ymmärtämään riskejä geneettisten häiriöiden siirtymisestä lapsille."
      },
      {
        "question": "Mitä "VUS" tarkoittaa geneettisten testien tuloksissa?",
        "answers": [
          { "answer": "Variant of Uncertain Significance" },
          { "answer": "Erittäin kiireellinen tilanne" },
          { "answer": "Arvollinen ainutlaatuinen näyte" },
          { "answer": "Varmistettu epätavallinen oire" }
        ],
        "answer": "Variantti, jolla on epävarma merkitys",
        "explanation": "VUS on DNA-muutos, jolla on tuntematon terveysvaikutus. Lisää tutkimusta tarvitaan."
      },
      {
        "question": "Mikä on geneettinen neuvonantaja?",
        "answers": [
          {
            "answer": "Terveydenhuollon ammattilainen, joka selittää geneettisten testien tulokset"
          },
          { "answer": "Tieteilija, joka sekvensoi DNA:ta" },
          { "answer": "Geenitietosuojaan erikoistunut lakimies" },
          { "answer": "Laboratorio ottaa verta" }
        ],
        "answer": "Terveydenhuollon ammattilainen, joka selittää geneettisten testien tulokset",
        "explanation": "Geneettiset ohjaajat auttavat potilaita ymmärtämään riskejä, testausvaihtoehtoja ja tuloksia."
      },
      {
        "question": "Mitä synnytystä edeltävä testaus tarkistaa?",
        "answers": [
          { "answer": "Sikiön geneettiset sairaudet" },
          { "answer": "Vanhemman suku" },
          { "answer": "Vastasyntyneen kuulovaurio" },
          { "answer": "Aikuisten syövän riski" }
        ],
        "answer": "Sikiön geneettiset olosuhteet",
        "explanation": "Prenataaliset testit (esim. amniocenteesi) seulovat sairauksia, kuten Downin oireyhtymää."
      },
      {
        "question": "Mitä on farmakogenominen testaus?",
        "answers": [
          { "answer": "Testataan, kuinka geenit vaikuttavat lääkevasteisiin" },
          { "answer": "Perinnöllisten syöpien testaus" },
          { "answer": "Liikuntakyvyn testaus" },
          { "answer": "Vitamiinitasojen testaus" }
        ],
        "answer": "Testataan kuinka geenit vaikuttavat lääkevasteisiin",
        "explanation": "Farmakogenomiikka auttaa lääkäreitä määräämään turvallisempia ja tehokkaampia lääkkeitä."
      },
      {
        "question": "Mikä on vastasyntyneiden seulonta?",
        "answers": [
          { "answer": "Vauvojen testaus hoidettavien geneettisten häiriöiden varalta" },
          { "answer": "Vauvan tulevan pituuden ennustaminen" },
          { "answer": "Äidin DNA:n testaus raskauden aikana" },
          { "answer": "Vauvan syntyperän analysoiminen" }
        ],
        "answer": "Vauvojen testaus hoidettavien geneettisten häiriöiden varalta",
        "explanation": "Vastasyntyneen seulonta havaitsee sairaudet, kuten PKU:n, aikaisin komplikaatioiden estämiseksi."
      },
      {
        "question": "Mikä testi tunnistaa sukujuuret?",
        "answers": [
          { "answer": "Autosomaalinen DNA-testaus" },
          { "answer": "Operaattorin testaus" },
          { "answer": "Vastasyntyneen seulonta" },
          { "answer": "kolesterolitesti" }
        ],
        "answer": "Autosomaalinen DNA-testaus",
        "explanation": "Autosomitestit analysoivat molemmilta vanhemmilta perittyä DNA:ta etnisen alkuperän arvioimiseksi."
      },
      {
        "question": "Mitä on diagnostinen geneettinen testaus?",
        "answers": [
          { "answer": "Epäillyn geneettisen sairauden vahvistaminen" },
          { "answer": "Tulevien terveysriskien ennustaminen" },
          { "answer": "Testataan operaattorin tilaa" },
          { "answer": "Lääkereaktioiden analysointi" }
        ],
        "answer": "Epäillyn geneettisen sairauden vahvistaminen",
        "explanation": "Diagnostinen testaus tunnistaa sairaudet, kuten kystisen fibroosin, oireellisilla potilailla."
      },
      {
        "question": "Mikä on bukkaalipuikko?",
        "answers": [
          { "answer": "Poskisolunäyte" },
          { "answer": "Verikoe" },
          { "answer": "Hiusenäyte" },
          { "answer": "virtsatesti" }
        ],
        "answer": "Poskisolunäyte",
        "explanation": "Bukkaalisella vanupuikolla kerätään soluja posken sisäpuolelta DNA-analyysiä varten."
      },
      {
        "kysymys": "Miksi verinäytettä voidaan käyttää geneettiseen testaukseen?",
        "answers": [
          { "answer": "Laadukkaan DNA:n saamiseksi" },
          { "answer": "Se on halvempaa kuin sylki" },
          { "answer": "Testaa infektioiden varalta" },
          { "answer": "Hormonitasojen mittaamiseen" }
        ],
        "answer": "Laadukkaan DNA:n saamiseksi",
        "explanation": "Verinäytteet tarjoavat luotettavan DNA:n, mutta vaativat kliinisen keräyksen."
      },
      {
        "question": "Mitä "positiivinen" geneettisen testin tulos tarkoittaa?",
        "answers": [
          { "answer": "Sairautta aiheuttava mutaatio löydettiin" },
          { "answer": "Mutaatioita ei löytynyt" },
          { "answer": "Testi epäonnistui" },
          { "answer": "Tulos on epävarma" }
        ],
        "answer": "Sairautta aiheuttava mutaatio löydettiin",
        "explanation": "Positiivinen tulos osoittaa mutaation, joka liittyy tiettyyn tilaan."
      },
      {
        "kysymys": "Voiko geneettinen testi ennustaa kaikki tulevat terveysongelmat?",
        "answers": [
          { "answer": "Ei – se arvioi vain tiettyjä mutaatioita" },
          { "answer": "Kyllä, 100 % tarkkuudella" },
          { "answer": "Vain tartuntataudeille" },
          { "answer": "Vain mielenterveysongelmiin" }
        ],
        "answer": "Ei - se arvioi vain tiettyjä mutaatioita",
        "explanation": "Useimmat testit analysoivat ennalta määritettyjä geenejä. Ympäristö ja elämäntavat vaikuttavat myös terveyteen."
      },
      {
        "question": "Mitä on tietoinen suostumus?",
        "answers": [
          {
            "answer": "Suostuminen testaukseen riskien/hyötyjen ymmärtämisen jälkeen"
          },
          { "answer": "Tilaa laboratorion uutiskirje" },
          { "answer": "Maksaa testistä verkossa" },
          { "answer": "DNA-tietojen jakaminen sosiaalisessa mediassa" }
        ],
        "answer": "Suostuminen testaukseen riskien/hyötyjen ymmärtämisen jälkeen",
        "explanation": "Tietoinen suostumus varmistaa, että potilaat tietävät, kuinka tulokset voivat vaikuttaa heihin."
      },
      {
        "kysymys": "Mikä laki kieltää geneettisen syrjinnän sairausvakuutuksessa?",
        "answers": [
          { "answer": "GINA (Genetic Information Nondiscrimination Act)" },
          { "answer": "HIPAA" },
          { "answer": "FDA" },
          { "answer": "CLIA" }
        ],
        "answer": "GINA (Genetic Information Nondiscrimination Act)",
        "explanation": "GINA estää vakuutusyhtiöitä/työnantajia käyttämästä geneettisiä tietoja sinua vastaan."
      },
      {
        "question": "Mikä on DNA?",
        "answers": [
          { "answer": "Molekyyli, joka kuljettaa geneettisiä ohjeita" },
          { "answer": "Eräänlainen proteiinityyppi" },
          { "answer": "Verisolu" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Geneettisiä ohjeita kuljettava molekyyli",
        "explanation": "DNA sisältää koodin organismin rakentamiseen ja ylläpitoon."
      },
      {
        "question": "Mikä on mutaatio?",
        "answers": [
          { "answer": "Muutos DNA-sekvenssissä" },
          { "answer": "Verikokeen tyyppi" },
          { "answer": "A-vitamiinin puutos" },
          { "answer": "Laboratoriovirhe" }
        ],
        "answer": "Muutos DNA-sekvenssissä",
        "explanation": "Mutaatiot voivat olla vaarattomia, hyödyllisiä tai aiheuttaa sairauksia."
      },
      {
        "question": "Mikä on geeni?",
        "answers": [
          { "answer": "DNA-segmentti, joka koodaa proteiinia" },
          { "answer": "Verisolutyyppi" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "DNA-segmentti, joka koodaa proteiinia",
        "explanation": "Geenit määrittävät piirteitä, kuten silmien värin ja vaikuttavat sairausriskiin."
      },
      {
        "kysymys": "Kuinka monta kromosomia ihmisellä on?",
        "answers": [
          { "answer": "46" },
          { "answer": "23" },
          { "answer": "32" },
          { "answer": "50" }
        ],
        "answer": "46",
        "explanation": "Ihmisillä on 23 paria kromosomeja (yhteensä 46) useimmissa soluissa."
      },
      {
        "question": "Mikä on kromosomi?",
        "answers": [
          { "answer": "DNA:n ja proteiinin lankamainen rakenne" },
          { "answer": "Eräänlainen geneettinen testi" },
          { "answer": "Verisairaus" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "DNA:n ja proteiinin lankamainen rakenne",
        "explanation": "Kromosomit pakkaavat DNA:n tiukasti sopimaan solujen sisään."
      },
      {
        "question": "Mikä on alleeli?",
        "answers": [
          { "answer": "Geenin versio" },
          { "answer": "Eräänlainen geneettinen testi" },
          { "answer": "Laboratoriolaite" },
          { "answer": "Verinäyte" }
        ],
        "answer": "Geenin versio",
        "explanation": "Alleelit ovat geenien muunnelmia (esim. siniset vs. ruskeat silmät)."
      },
      {
        "question": "Mitä "resessiivinen" tarkoittaa genetiikassa?",
        "answers": [
          {
            "answer": "Ominaisuus, joka ilmenee vain kahdella alleelin kopiolla"
          },
          { "answer": "Ominaisuus, joka esiintyy aina yhdellä alleelilla" },
          { "answer": "DNA-testin tyyppi" },
          { "answer": "Laboratoriovirhe" }
        ],
        "answer": "Ominaisuus, joka esiintyy vain kahdella alleelin kopiolla",
        "explanation": "Resessiiviset ominaisuudet (kuten kystinen fibroosi) tarvitsevat kaksi kopiota mutatoidusta geenistä."
      },
      {
        "question": "Mitä "dominoiva" tarkoittaa genetiikassa?",
        "answers": [
          { "answer": "Ominaisuus, joka esiintyy yhden alleelin kopion kanssa" },
          { "answer": "Ominaisuus, joka ei koskaan näy" },
          { "answer": "Verikokeen tyyppi" },
          { "answer": "Laboratorion todistus" }
        ],
        "answer": "Ominaisuus, joka esiintyy yhden alleelin kopion kanssa",
        "explanation": "Vallitsevat piirteet (kuten Huntingtonin tauti) vaativat vain yhden mutatoidun geenin."
      },
      {
        "question": "Mikä on genomi?",
        "answers": [
          { "answer": "Kaikki organismin DNA" },
          { "answer": "Eräänlainen geneettinen testi" },
          { "answer": "Verisolu" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Kaikki DNA organismissa",
        "explanation": "Genomi sisältää kaikki geenit ja ei-koodaavan DNA:n."
      },
      {
        "question": "Mikä on geneettinen häiriö?",
        "answers": [
          { "answer": "DNA-muutosten aiheuttama sairaus" },
          { "answer": "Laboratoriovirhe" },
          { "answer": "A-vitamiinin puutos" },
          { "answer": "bakteeri-infektio" }
        ],
        "answer": "DNA-muutosten aiheuttama sairaus",
        "explanation": "Esimerkkejä ovat sirppisoluanemia ja kystinen fibroosi."
      },
      {
        "question": "Mikä on väärä positiivinen geenitestissä?",
        "answers": [
          { "answer": "Tulos, joka näyttää mutaation, jota ei ole olemassa" },
          { "answer": "Oikea tulos" },
          { "answer": "Laboratorion laitevirhe" },
          { "answer": "Peruutettu testi" }
        ],
        "answer": "Tulos, joka näyttää mutaation, jota ei ole olemassa",
        "explanation": "Väärät positiiviset tulokset voivat aiheuttaa tarpeetonta stressiä ja testausta."
      },
      {
        "question": "Mikä on väärä negatiivinen geenitestissä?",
        "answers": [
          { "answer": "Tulosta puuttuu mutaatio, joka on olemassa" },
          { "answer": "Oikea tulos" },
          { "answer": "Laboratorioonnettomuus" },
          { "answer": "Peruutettu testi" }
        ],
        "answer": "Tulosta puuttuu läsnä oleva mutaatio",
        "explanation": "Väärät negatiivit voivat viivyttää tarvittavaa lääketieteellistä hoitoa."
      },
      {
        "question": "Mitä on kuluttajalle suoritettava geneettinen testaus?",
        "answers": [
          { "answer": "Testit myydään suoraan yleisölle ilman lääkäriä" },
          { "answer": "Sairaaloissa tehdyt testit" },
          { "answer": "Vastasyntyneiden testit" },
          { "answer": "Tarttatautitestit" }
        ],
        "answer": "Suoraan yleisölle ilman lääkäriä myytävät testit",
        "explanation": "Esimerkkejä ovat syntyperä- ja hyvinvointitestit yrityksiltä, ​​kuten 23andMe."
      },
      {
        "question": "Mikä on BRCA1-geeni?",
        "answers": [
          { "answer": "Rintasyöpäriskiin liittyvä geeni" },
          { "answer": "Silmien värin geeni" },
          { "answer": "Vitamiinien imeytymistä edistävä geeni" },
          { "answer": "Pituuden geeni" }
        ],
        "answer": "Rintasyöpäriskiin liittyvä geeni",
        "explanation": "BRCA1-mutaatiot lisäävät rinta- ja munasarjasyöpien riskiä."
      },
      {
        "question": "Mikä on geneettinen syntyperä?",
        "answers": [
          { "answer": "Arvio, missä esivanhempasi asuivat" },
          { "answer": "Tautien testaus" },
          { "answer": "Analysoidaan lääkereaktioita" },
          { "answer": "Bakteereiden tutkiminen" }
        ],
        "answer": "Arvioi, missä esivanhempasi asuivat",
        "explanation": "Esivanhempaintestit vertaavat DNA:tasi maailmanlaajuisiin vertailupopulaatioihin."
      },
      {
        "question": "Mikä on geneettinen ominaisuus?",
        "answers": [
          { "answer": "Ominaisuus, johon geenit vaikuttavat" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Verikoe" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Geenien vaikuttama ominaisuus",
        "explanation": "Esimerkkejä ovat silmien väri, pituus ja laktoosi-intoleranssi."
      },
      {
        "question": "Mikä on perheen terveyshistoria?",
        "answers": [
          { "answer": "Tieto sukulaisten sairauksista" },
          { "answer": "Geenitesti" },
          { "answer": "Laboratorioraportti" },
          { "answer": "DNA-näyte" }
        ],
        "answer": "Tieto sukulaisten sairauksista",
        "explanation": "Sukuhistoria auttaa arvioimaan geneettisten sairauksien riskejä."
      },
      {
        "question": "Mikä on geneettinen riskipiste?",
        "answers": [
          { "answer": "DNA:han perustuva arvio sairausriskistä" },
          { "answer": "Laboratorion todistus" },
          { "answer": "Verenpainelukema" },
          { "answer": "A-vitamiinitaso" }
        ],
        "answer": "DNA:han perustuva arvio sairausriskistä",
        "explanation": "Polygeeniset riskipisteet yhdistävät useita geneettisiä muunnelmia."
      },
      {
        "question": "Mikä on DNA-osuma?",
        "answers": [
          { "answer": "Jaetun DNA:n perusteella tunnistettu sukulainen" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Veriryhmävastaavuus" },
          { "answer": "A-vitamiiniyhteensopivuus" }
        ],
        "answer": "Jaetun DNA:n perusteella tunnistettu sukulainen",
        "explanation": "DNA-sovitus auttaa rakentamaan sukupuita esi-isien testauksessa."
      },
      {
        "question": "Mikä on geneettinen variantti?",
        "answers": [
          { "answer": "Ero DNA-sekvenssissä" },
          { "answer": "Lab-virhe" },
          { "answer": "Verisairaus" },
          { "answer": "A-vitamiinin puutos" }
        ],
        "answer": "Ero DNA-sekvenssissä",
        "explanation": "Vaihtoehdot voivat olla vaarattomia, hyödyllisiä tai haitallisia."
      },
      {
        "question": "Mikä on DNA-profiili?",
        "answers": [
          { "answer": "Ainutlaatuinen joukko geneettisiä markkereita" },
          { "answer": "Laboratorioraportti" },
          { "answer": "Veriryhmä" },
          { "answer": "Vitamiinitaulukko" }
        ],
        "answer": "Ainutlaatuinen joukko geneettisiä markkereita",
        "explanation": "Käytetään oikeuslääketieteessä ja isyystesteissä yksilöiden tunnistamiseen."
      },
      {
        "question": "Mikä on geneettinen merkki?",
        "answers": [
          { "answer": "DNA-sekvenssi, jolla on tunnettu sijainti" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Verinäyte" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "DNA-sekvenssi, jonka sijainti tunnetaan",
        "explanation": "Markerit auttavat jäljittämään geenejä perheissä tai populaatioissa."
      },
      {
        "question": "Mikä on geneettinen taipumus?",
        "answers": [
          { "answer": "Geenien aiheuttama lisääntynyt sairausriski" },
          { "answer": "Immuniteetti sairautta vastaan" },
          { "answer": "Lab-virhe" },
          { "answer": "A-vitamiinin puutos" }
        ],
        "answer": "Geenien aiheuttama lisääntynyt sairausriski",
        "explanation": "Tapaus ei takaa taudin kehittymistä."
      },
      {
        "question": "Mikä on sylkepakkaus?",
        "answers": [
          { "answer": "Syljenkeräyssarja DNA-testausta varten" },
          { "answer": "Verikoepakkaus" },
          { "answer": "Hiustenäytepakkaus" },
          { "answer": "Vitsan testipakkaus" }
        ],
        "answer": "Syljenkeräyssarja DNA-testaukseen",
        "explanation": "Käytetään kotitesteissä DNA:n keräämiseen syljestä."
      },
      {
        "question": "Mikä on laboratorioraportti?",
        "answers": [
          { "answer": "Testituloksia selittävä asiakirja" },
          { "answer": "Verinäyte" },
          { "answer": "Geneettinen mutaatio" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Testituloksia selittävä asiakirja",
        "explanation": "Raportit sisältävät yhteenvedon havainnoista ja voivat sisältää suosituksia."
      },
      {
        "question": "Mikä on DNA-tietokanta?",
        "answers": [
          { "answer": "Geneettisten profiilien kokoelma" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Veripankki" },
          { "answer": "Vitamiiniluettelo" }
        ],
        "answer": "Geneettisten profiilien kokoelma",
        "explanation": "Käytetään tutkimuksessa, rikoslääketieteessä ja esivanhempainpalveluissa."
      },
      {
        "question": "Mikä on suostumuslomake?",
        "answers": [
          { "answer": "Asiakirja, jossa hyväksytään testausehdot" },
          { "answer": "Laboratorioraportti" },
          { "answer": "Verinäyte" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Asiakirja, joka hyväksyy testausehdot",
        "explanation": "Varmistaa, että potilaat ymmärtävät testauksen riskit/edut ennen jatkamista."
      },
      {
        "question": "Mitä on tunnistamaton data?",
        "answers": [
          { "answer": "Data ilman henkilökohtaisia ​​tunnisteita" },
          { "answer": "Salatut tiedot" },
          { "answer": "Raaka-DNA-tiedot" },
          { "answer": "Laboratoriotyökalu" }
        ],
        "answer": "Tiedot ilman henkilökohtaisia ​​tunnisteita",
        "explanation": "Suojaa yksityisyyttä poistamalla nimiä, osoitteita jne."
      },
      {
        "question": "Mikä on geneettinen testaussarja?",
        "answers": [
          { "answer": "Paketti DNA-näytteiden keräämiseen ja lähettämiseen" },
          { "answer": "Laboratoriolaite" },
          { "answer": "Verenpainemittari" },
          { "answer": "Vitamiinipullo" }
        ],
        "answer": "Paketti DNA-näytteiden keräämiseen ja lähettämiseen",
        "explanation": "Sisältää ohjeet, putket ja palautuspakkauksen."
      },
      {
        "question": "Mikä on raaka-DNA-tiedosto?",
        "answers": [
          { "answer": "Geenitietojen tekstitiedosto" },
          { "answer": "Laboratorioraportti" },
          { "answer": "Verinäyte" },
          { "answer": "Vitamiiniluettelo" }
        ],
        "answer": "Geenitietojen tekstitiedosto",
        "explanation": "Käyttäjät voivat ladata tämän tiedoston kolmannen osapuolen analyyseja varten."
      },
      {
        "question": "Mikä on kolmannen osapuolen tulkkauspalvelu?",
        "answers": [
          { "answer": "Työkalu raaka-DNA-tietojen analysointiin" },
          { "answer": "Laboratorion todistus" },
          { "answer": "Verikoe" },
          { "answer": "Vitamiinitoimittaja" }
        ],
        "answer": "Työkalu raaka-DNA-tietojen analysointiin",
        "explanation": "Palvelut, kuten Promethease, tarjoavat lisää terveystietoja."
      },
      {
        "question": "Mikä on DNA:n suhteellinen vastaavuus?",
        "answers": [
          { "answer": "Geneettisten sukulaisten tunnistaminen jaetun DNA:n avulla" },
          { "answer": "Vastaavat verityypit" },
          { "answer": "Vitamiiniyhteensopivuuden löytäminen" },
          { "answer": "Laboratoriovirhe" }
        ],
        "answer": "Geneettisten sukulaisten tunnistaminen yhteisen DNA:n avulla",
        "explanation": "Yleinen esi-isien testausalustoissa, kuten AncestryDNA."
      },
      {
        "question": "Mikä on geneettinen testauspaneeli?",
        "answers": [
          { "answer": "Testi, joka analysoi useita geenejä kerralla" },
          { "answer": "Laboratoriotyökalu" },
          { "answer": "Verenottomenetelmä" },
          { "answer": "Vitamiinitaulukko" }
        ],
        "answer": "Testi, joka analysoi useita geenejä kerralla",
        "explanation": "Paneelit seulovat sairauksia, kuten perinnöllisiä syöpäoireyhtymiä."
      },
      {
        "question": "Mitä on koko eksomin sekvensointi?",
        "answers": [
          { "answer": "Sekvensoidaan kaikki proteiinia koodaavat geenit" },
          { "answer": "Sekvensoi mitokondriaalinen DNA" },
          { "answer": "Verikoe" },
          { "answer": "Vitamiinitesti" }
        ],
        "answer": "Kaikkien proteiinia koodaavien geenien sekvensointi",
        "explanation": "Exome-sekvensointi keskittyy 1-2 prosenttiin genomista, mutta kattaa useimmat sairauteen liittyvät geenit."
      },
      {
        "question": "Mikä on geneettisen testauksen tuloksen kantaja?",
        "answers": [
          { "answer": "Joku, jolla on yksi kopio resessiivisestä mutaatiosta" },
          { "answer": "Joku, jolla on kaksi kopiota mutaatiosta" },
          { "answer": "Joku, joka on immuuni taudille" },
          { "answer": "Laboratorio" }
        ],
        "answer": "Joku, jolla on yksi kopio resessiivisestä mutaatiosta",
        "explanation": "Kantajat eivät osoita oireita, mutta voivat välittää mutaation lapsille."
      },
      {
        "question": "Mikä on negatiivinen testitulos?",
        "answers": [
          { "answer": "Testatuista geeneistä ei löytynyt mutaatioita" },
          { "answer": "Tapahtui laboratoriovirhe" },
          { "answer": "Koe peruutettiin" },
          { "answer": "Vitamiinipuutos havaittiin" }
        ],
        "answer": "Testatuista geeneistä ei löytynyt mutaatioita",
        "explanation": "Negatiivinen tulos vähentää sairauden riskiä, ​​mutta ei poista sitä."
      }
    ]
  },
  {
    "name": "Blueprint Genetics",
    "questions": [
      {
        "question": "Mikä on Blueprint Geneticsin pääpaino?",
        "answers": [
          { "answer": "Harvinaisten sairauksien diagnostinen geneettinen testaus" },
          { "answer": "Suoraan kuluttajille suunnatut hyvinvointiraportit" },
          { "answer": "Farmakogenominen lääkekehitys" },
          { "answer": "Tarttatautien diagnostiikka" }
        ],
        "answer": "Harvinaisten sairauksien diagnostinen geneettinen testaus",
        "explanation": "Blueprint Genetics on erikoistunut kliiniseen eksomien sekvensointiin ja kohdennettuihin geenipaneeleihin harvinaisten perinnöllisten sairauksien, kuten kardiomyopatioiden, aineenvaihduntahäiriöiden ja hermoston kehityssairauksien, diagnosoimiseksi."
      },
      {
        "question": "Mitä sertifikaatteja Blueprint Geneticsillä on?",
        "answers": [
          { "answer": "CLIA ja CAP" },
          { "answer": "FDA ja CE-IVD" },
          { "answer": "Vain ISO 9001" },
          { "answer": "HIPAA ja GDPR" }
        ],
        "answer": "CLIA ja CAP",
        "explanation": "Heidän laboratorionsa on CLIA-sertifioitu (Clinical Laboratory Improvement Changes) ja CAP-akkreditoitu (College of American Pathologists), mikä varmistaa Yhdysvaltojen kliinisten testausstandardien noudattamisen."
      },
      {
        "question": "Mitä tekniikkaa Blueprint Genetics ensisijaisesti käyttää sekvensointiin?",
        "answers": [
          { "answer": "Next-Generation Sequencing (NGS)" },
          { "answer": "Sangerin sekvensointi" },
          { "answer": "Microarray-analyysi" },
          { "answer": "PCR-pohjainen genotyypitys" }
        ],
        "answer": "Seuraavan sukupolven sekvensointi (NGS)",
        "explanation": "NGS mahdollistaa satojen tai tuhansien geenien tehokkaan ja kustannustehokkaan analyysin samanaikaisesti suurella tarkkuudella ja kattavuudella."
      },
      {
        "question": "Mikä on 'Exome+Solution'?",
        "answers": [
          { "answer": "Koko eksomin sekvensointi + CNV-analyysi" },
          { "answer": "Yhden geenin testaus" },
          { "answer": "RNA-sekvensointi" },
          { "answer": "Mikrobioanalyysi" }
        ],
        "answer": "Koko eksomin sekvensointi + CNV-analyysi",
        "explanation": "Exome+Solution sekvensoi kaikki proteiinia koodaavat alueet (n. 20 000 geeniä) ja havaitsee kopiolukuvariaatioita (CNV:t), mikä tarjoaa kattavan diagnostisen lähestymistavan."
      },
      {
        "question": "Kuka voi tilata Blueprint Genetics -testin?",
        "answers": [
          { "answer": "Lisensoidut terveydenhuollon tarjoajat" },
          { "answer": "Potilaat suoraan" },
          { "answer": "Apteekkarit" },
          { "answer": "Tutkijat" }
        ],
        "answer": "Lisensoidut terveydenhuollon tarjoajat",
        "explanation": "Testit ovat kliinisesti validoituja ja vaativat palveluntarjoajan määräyksen asianmukaisen käytön ja tulkinnan varmistamiseksi."
      },
      {
        "question": "Mihin Cardio Panelia käytetään?",
        "answers": [
          { "answer": "Perinnöllisten sydän- ja verisuonisairauksien diagnosointi" },
          { "answer": "Arvioimalla kolesterolitasoja" },
          { "answer": "Verenpaineen seuranta" },
          { "answer": "Sydänkohtausten testaus" }
        ],
        "answer": "Perinnöllisten sydän- ja verisuonisairauksien diagnosointi",
        "explanation": "Kardiopaneeli analysoi geenejä, jotka liittyvät sellaisiin tiloihin kuin hypertrofinen kardiomyopatia, pitkä QT-oireyhtymä ja familiaalinen hyperkolesterolemia."
      },
      {
        "question": "Minkä paneelin lääkäri tilaa lapselle, jolla on kehityshäiriö?",
        "answers": [
          { "answer": "Neuropaneeli" },
          { "answer": "Syöpäpaneeli" },
          { "answer": "Metabolic Panel" },
          { "answer": "Prenataalipaneeli" }
        ],
        "answer": "Neuropaneeli",
        "explanation": "Neuropaneeli keskittyy geeneihin, jotka liittyvät hermoston kehityshäiriöihin, epilepsiaan ja kehitysvammaisuuteen."
      },
      {
        "question": "Mitä 'Rapid Exome' -testi priorisoi?",
        "answers": [
          { "answer": "Nopea käsittely kriittisesti sairaille potilaille" },
          { "answer": "Edullinen järjestys" },
          { "answer": "Operaattorin tarkistus" },
          { "answer": "Esivanhempien analyysi" }
        ],
        "answer": "Nopea käsittely kriittisesti sairaille potilaille",
        "explanation": "Rapid Exome Sekvensointia (2–3 viikkoa) käytetään vastasyntyneiden teho-osastoilla tai akuuttihoidossa diagnoosin nopeuttamiseksi."
      },
      {
        "question": "Mitä Metabolic Panel on suunniteltu havaitsemaan?",
        "answers": [
          { "answer": "Synnynnäiset aineenvaihduntavirheet" },
          { "answer": "Diabetesriski" },
          { "answer": "Vitamiinin puutteet" },
          { "answer": "kilpirauhasen toimintahäiriöt" }
        ],
        "answer": "Synnynnäiset aineenvaihduntavirheet",
        "explanation": "Tämä paneeli tunnistaa mutaatiot geeneissä, kuten *PAH* (fenyyliketonuria) tai *GALT* (galaktosemia), jotka ohjaavat ruokavalio- tai hoitotoimenpiteitä."
      },
      {
        "question": "Mikä testi on sopiva epäillylle kromosomideleetiolle?",
        "answers": [
          { "answer": "Exome+Solution with CNV-analyysi" },
          { "answer": "Yhden geenin Sanger-sekvensointi" },
          { "answer": "Operaattorin tarkistuspaneeli" },
          { "answer": "Farmakogenominen testaus" }
        ],
        "answer": "Exome+Solution CNV-analyysillä",
        "explanation": "Exome+Solution sisältää CNV-tunnistuksen, jonka avulla voidaan tunnistaa suuret deleetiot/duplikaatiot, jotka geenipaneeleista puuttuvat."
      },
      {
        "question": "Mitä '30x kattavuus' tarkoittaa järjestyksessä?",
        "answers": [
          { "answer": "Jokainen DNA-emäs luetaan keskimäärin 30 kertaa" },
          { "answer": "30 geeniä analysoidaan" },
          { "answer": "Testi maksaa 30 dollaria" },
          { "answer": "30 päivän toimitusaika" }
        ],
        "answer": "Jokainen DNA-emäs luetaan keskimäärin 30 kertaa",
        "explanation": "Suurimpi peitto (esim. 100x) parantaa tarkkuutta vähentämällä virheitä ja havaitsemalla matalan mosaiikkitason."
      },
      {
        "question": "Kuinka Blueprint Genetics käsittelee pseudogeenejä?",
        "answers": [
          { "answer": "Käyttää anturin suunnittelua ristiinhybridisaation välttämiseksi" },
          { "answer": "Ohittaa ne analyysin aikana" },
          { "answer": "Raportoi ne patogeenisiksi" },
          { "answer": "Käyttää yksinomaan Sanger-sekvensointia" }
        ],
        "answer": "Käyttää anturin suunnittelua ristiinhybridisaation välttämiseksi",
        "explanation": "Pseudogeenit (ei-toiminnalliset geenikopiot) voivat aiheuttaa vääriä positiivisia tuloksia; erikoistuneet koettimet minimoivat tämän riskin."
      },
      {
        "question": "Mikä on 'BAM-tiedosto'?",
        "answers": [
          { "answer": "Tiedosto, joka tallentaa tasatut sekvenssilukemat" },
          { "answer": "Laboratorion suostumuslomake" },
          { "answer": "Laskutusasiakirja" },
          { "answer": "Versioiden luokitteluraportti" }
        ],
        "answer": "Tiedosto, joka tallentaa kohdistettuja lukuja",
        "explanation": "BAM-tiedostot yhdistävät DNA-sekvenssit referenssigenomiin ja niitä käytetään muunnelmien kutsumiseen ja laadunvalvontaan."
      },
      {
        "question": "Mitä 'Tier 1' -muunnelman luokitus tarkoittaa?",
        "answers": [
          { "answer": "Patogeeninen tai todennäköisesti patogeeninen" },
          { "answer": "Hyvänlaatuinen" },
          { "answer": "Variant of Uncertain Significance (VUS)" },
          { "answer": "Tekninen artefakti" }
        ],
        "answer": "Patogeeninen tai todennäköisesti patogeeninen",
        "explanation": "Tier 1 -muunnelmilla on vahvaa näyttöä, joka yhdistää ne sairauteen ACMG:n ohjeiden mukaisesti."
      },
      {
        "question": "Mikä on 'VUS'?",
        "answers": [
          { "answer": "Variantti, jolla on epäselvä kliininen merkitys" },
          { "answer": "Vahvistettu hyvänlaatuinen variantti" },
          { "answer": "Lab-virhe" },
          { "answer": "Uusi geenilöytö" }
        ],
        "answer": "Variantti, jolla on epäselvä kliininen merkitys",
        "explanation": "VUS-tulokset vaativat seurantaa, kuten perhetutkimuksia tai säännöllistä uudelleenanalyysiä."
      },
      {
        "question": "Milloin 'carrier seulonta' suositellaan?",
        "answers": [
          { "answer": "Ennen raskautta tai raskauden aikana" },
          { "answer": "Syöpädiagnoosin jälkeen" },
          { "answer": "Esivanhempien analyysiä varten" },
          { "answer": "Infektioiden diagnosointiin" }
        ],
        "answer": "Ennen raskautta tai sen aikana",
        "explanation": "Kantajaseulonta tunnistaa resessiiviset mutaatiot (esim. kystinen fibroosi) mahdollisilla vanhemmilla."
      },
      {
        "question": "Mikä on Cancer Panelin kliininen hyöty?",
        "answers": [
          { "answer": "Perinnöllisten syöpäoireiden tunnistaminen" },
          { "answer": "Kemoterapiavasteen seuranta" },
          { "answer": "Tuumorimutaatioiden havaitseminen" },
          { "answer": "Syövän uusiutumisen ennustaminen" }
        ],
        "answer": "Perinnöllisten syöpäoireiden tunnistaminen",
        "explanation": "Tämä paneeli testaa geenejä, kuten *BRCA1/2* tai *TP53* perinnöllisten syöpäriskien arvioimiseksi."
      },
      {
        "question": "Miltä GINA suojaa?",
        "answers": [
          { "answer": "Geneettinen syrjintä sairausvakuutuksessa" },
          { "answer": "Tietoturvaloukkaukset" },
          { "answer": "Lab errors" },
          { "answer": "tartuntataudit" }
        ],
        "answer": "Geneettinen syrjintä sairausvakuutuksessa",
        "explanation": "Genetic Information Nondiscrimination Act (GINA) kieltää vakuutusyhtiöitä käyttämästä geneettisiä tietoja kattavuuden estämiseen."
      },
      {
        "question": "Mitä geenitestauksen tietoon perustuva suostumus sisältyy?",
        "answers": [
          { "answer": "Riskit, edut ja tiedonkäyttö" },
          { "answer": "Laboratoriolaitteiden tiedot" },
          { "answer": "Vakuutuksen laskutuskoodit" },
          { "answer": "Lääkealan tarjoukset" }
        ],
        "answer": "Riskit, edut ja tiedonkäyttö",
        "explanation": "Potilaiden on ymmärrettävä mahdolliset tulokset, tietosuojakäytännöt ja kuinka tulokset voivat vaikuttaa perheenjäseniin."
      },
      {
        "kysymys": "Vastasyntyneelle, jolla on kohtauksia ja kehitysviive, suoritetaan Rapid Exome -sekvensointi. *SCN1A*-variantti löytyy. Mikä on todennäköinen diagnoosi?",
        "answers": [
          { "answer": "Dravetin oireyhtymä" },
          { "answer": "Kystinen fibroosi" },
          { "answer": "Huntingtonin tauti" },
          { "answer": "Marfanin oireyhtymä" }
        ],
        "answer": "Dravetin oireyhtymä",
        "explanation": "*SCN1A*-mutaatiot aiheuttavat Dravetin oireyhtymän, vakavan epilepsiahäiriön. Varhainen diagnoosi ohjaa hoitoa natriumkanavasalpaajilla."
      }
    ]
  },
  {
    "name": "Geenit ja DNA (Perustiedot)",
    "questions": [
      {
        "question": "Mikä on geeni?",
        "answers": [
          { "answer": "Tietty DNA-sekvenssi" },
          { "answer": "Eräänlainen proteiinityyppi" },
          { "answer": "Verisolu" },
          { "answer": "A-vitamiini" }
        ],
        "answer": "Tietytty DNA-sekvenssi",
        "explanation": "Geeni on DNA-segmentti, jossa on ainutlaatuinen emässekvenssi (A, T, C, G), joka koodaa toiminnallista tuotetta."
      },
      {
        "kysymys": "Mistä molekyyleistä muodostuu DNA-portaiden "askelmat"?",
        "answers": [
          { "answer": "A, T, C, G emäkset" },
          { "answer": "Proteiinit" },
          { "answer": "Sokerit" },
          { "answer": "Lipidit" }
        ],
        "answer": "A, T, C, G emäkset",
        "explanation": "DNA koostuu kahdesta säikeestä, jotka on kierretty kaksoiskierteeksi, ja emäkset (A-T ja C-G) muodostavat puolat."
      },
      {
        "question": "Missä geenit sijaitsevat?",
        "answers": [
          { "answer": "Kromosomeissa" },
          { "answer": "Solukalvossa" },
          { "answer": "Vain mitokondrioissa" },
          { "answer": "Vitamiinissa" }
        ],
        "answer": "Kromosomeissa",
        "explanation": "Geenit on järjestetty lineaarisesti kromosomeihin, jotka löytyvät solun ytimestä."
      },
      {
        "question": "Kuinka monta geeniä ihmisellä on suunnilleen?",
        "answers": [
          { "answer": "~20 000" },
          { "answer": "~100 000" },
          { "answer": "~5 000" },
          { "answer": "~1 000" }
        ],
        "answer": "~20 000",
        "explanation": "Ihmisillä on noin 20 000 geeniä, jotka muodostavat vain ~1-2% koko DNA:sta."
      },
      {
        "question": "Mitä geenit koodaavat?",
        "answers": [
          { "answer": "Proteiinit tai RNA-molekyylit" },
          { "answer": "Hiilihydraatit" },
          { "answer": "Hormonit" },
          { "answer": "Vitamiinit" }
        ],
        "answer": "Proteiinit tai RNA-molekyylit",
        "explanation": "Geenit antavat ohjeita proteiinien (esim. entsyymien) tai toiminnallisen RNA:n (esim. tRNA) rakentamiseen."
      },
      {
        "question": "Mikä geeni on vastuussa hemoglobiinista?",
        "answers": [
          { "answer": "HBB" },
          { "answer": "BRCA1" },
          { "answer": "CFTR" },
          { "answer": "TP53" }
        ],
        "answer": "HBB",
        "explanation": "HBB-geeni koodaa osaa hemoglobiinista, proteiinista, joka kuljettaa happea punasoluissa."
      },
      {
        "question": "Mitä tapahtuu, jos HBB-geeni mutatoituu?",
        "answers": [
          { "answer": "Sirppisoluanemia" },
          { "answer": "Kystinen fibroosi" },
          { "answer": "Huntingtonin tauti" },
          { "answer": "Diabetes" }
        ],
        "answer": "Sirppisoluanemia",
        "explanation": "Yksittäinen emäksen muutos HBB:ssä aiheuttaa sirppimuotoisia punasoluja, mikä johtaa sirppisoluanemiaan."
      },
      {
        "question": "Mikä on geenin ja DNA:n välinen suhde?",
        "answers": [
          { "answer": "Geeni on DNA:n toiminnallinen yksikkö" },
          { "answer": "DNA on eräänlainen geeni" },
          { "answer": "Geenit koostuvat RNA:sta" },
          { "answer": "DNA ja geenit eivät liity toisiinsa" }
        ],
        "answer": "Geeni on DNA:n toiminnallinen yksikkö",
        "explanation": "DNA on koko molekyyli, kun taas geenit ovat tiettyjä segmenttejä, jotka koodaavat tuotteita."
      },
      {
        "question": "Kuinka prosenttiosuus ihmisen DNA:sta koodaa geenejä?",
        "answers": [
          { "answer": "1-2%" },
          { "answer": "50%" },
          { "answer": "25%" },
          { "answer": "99%" }
        ],
        "answer": "1-2%",
        "explanation": "Suurin osa DNA:sta ei koodaa ja sisältää säätelyalueita tai "roska"-DNA:ta."
      },
      {
        "question": "Mikä on geenien tarkoitus?",
        "answers": [
          { "answer": "Anna ohjeet ominaisuuksille" },
          { "answer": "Varastoi energiaa" },
          { "answer": "Taistele infektioita vastaan" },
          { "answer": "Suorita ruoka" }
        ],
        "answer": "Anna ohjeet ominaisuuksista",
        "explanation": "Geenit määrittävät piirteitä, kuten silmien värin, pituuden ja taudille alttiuden."
      },
      {
        "kysymys": "Kuinka monta kromosomiparia ihmisillä on?",
        "answers": [
          { "answer": "23" },
          { "answer": "46" },
          { "answer": "10" },
          { "answer": "32" }
        ],
        "answer": "23",
        "explanation": "Ihmisillä on 23 paria kromosomeja (yhteensä 46) useimmissa soluissa."
      },
      {
        "question": "Mitä eroa on geenillä ja genomilla?",
        "answers": [
          {
            "answer": "Geeni on DNA-segmentti; genomi on kaikki organismin DNA"
          },
          { "answer": "Genomi on geenityyppi" },
          { "answer": "Geenit koostuvat RNA:sta; genomit on tehty DNA:sta" },
          { "answer": "Ei eroa" }
        ],
        "answer": "Geeni on DNA-segmentti; genomi on kaikki organismin DNA",
        "explanation": "Genomi sisältää kaikki organismin geenit ja ei-koodaavan DNA:n."
      },
      {
        "question": "Mikä rooli ei-koodaavilla DNA-alueilla on?",
        "answers": [
          { "answer": "Säädä geenien toimintaa" },
          { "answer": "Proteiinien koodi" },
          { "answer": "Kanna happea" },
          { "answer": "Suorita ruoka" }
        ],
        "answer": "Säädä geenien toimintaa",
        "explanation": "Koodaamaton DNA ohjaa, milloin ja missä geenit ilmentyvät."
      },
      {
        "question": "Oikein vai tarin: Kaikki DNA-sekvenssit ovat geenejä."
        "vastaukset": [{ "answer": "False" }, { "answer": "True" }],
        "answer": "Epätosi",
        "explanation": "Vain ~1-2% DNA:sta koostuu geeneistä; loput sisältävät säätely- ja ei-toiminnallisia alueita."
      },
      {
        "question": "Mihin geeni on paras verrattuna?",
        "answers": [
          { "answer": "Resepti keittokirjassa" },
          { "answer": "Keittiökone" },
          { "answer": "Kokki" },
          { "answer": "Ateria" }
        ],
        "answer": "Resepti keittokirjassa",
        "explanation": "Geeni tarjoaa vaiheittaiset ohjeet tuotteen valmistamiseksi, kuten resepti."
      },
      {
        "question": "Mikä osa DNA:sta EI ole osa geeniä?",
        "answers": [
          { "answer": "Sääntelyalueet" },
          { "answer": "Koodaussekvenssi" },
          { "answer": "Promoottorialue" },
          { "answer": "Exons" }
        ],
        "answer": "Sääntelyalueet",
        "explanation": "Säätelyalueet säätelevät geenin aktiivisuutta, mutta eivät ole osa geenin koodaussekvenssiä."
      },
      {
        "question": "Mitä tapahtuu, jos geeni mutatoituu?",
        "answers": [
          { "answer": "Se voi muuttaa proteiinia, jota se koodaa" },
          { "answer": "Se tulee osaksi kromosomia" },
          { "answer": "Se muuttuu RNA:ksi" },
          { "answer": "Ei mitään – mutaatiot ovat aina vaarattomia" }
        ],
        "answer": "Se voi muuttaa proteiinia, jota se koodaa",
        "explanation": "Mutaatiot voivat häiritä proteiinin toimintaa ja aiheuttaa sairauksia, kuten kystistä fibroosia."
      },
      {
        "question": "Mikä on DNA?",
        "answers": [
          { "answer": "Molekyyli, joka tallentaa geneettistä tietoa" },
          { "answer": "Yksi geenityyppi" },
          { "answer": "Proteiini" },
          { "answer": "hiilihydraatti" }
        ],
        "answer": "Molekyyli, joka tallentaa geneettistä tietoa",
        "explanation": "DNA on molekyyli, joka sisältää kaikki geenit ja ei-koodaavat sekvenssit."
      },
      {
        "question": "Mitä hemoglobiini tekee?",
        "answers": [
          { "answer": "Siirtää happea punasoluissa" },
          { "answer": "Taistelee infektioita vastaan" },
          { "answer": "Sigmentää ruokaa" },
          { "answer": "Varastaa energiaa" }
        ],
        "answer": "Siirtää happea punasoluissa",
        "explanation": "HBB-geenin koodaama hemoglobiini sitoo happea kuljettaakseen veren läpi."
      },
      {
        "kysymys": "Millä nimellä kutsutaan koko DNA-sarjaa organismissa?",
        "answers": [
          { "answer": "Genomi" },
          { "answer": "kromosomi" },
          { "answer": "Geenivarasto" },
          { "answer": "Proteomi" }
        ],
        "answer": "Genomi",
        "explanation": "Genomi sisältää kaikki organismin geenit ja ei-koodaavan DNA:n."
      }
    ]
  }
]


